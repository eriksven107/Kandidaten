/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/viewer/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/asn1js/node_modules/pvutils/build/utils.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/asn1js/node_modules/pvutils/build/utils.es.js ***!
  \********************************************************************/
/*! exports provided: arrayBufferToString, bufferToHexCodes, checkBufferParams, clearProps, fromBase64, getParametersValue, getUTCDate, isEqualBuffer, nearestPowerOf2, padNumber, stringToArrayBuffer, toBase64, utilConcatBuf, utilConcatView, utilDecodeTC, utilEncodeTC, utilFromBase, utilToBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayBufferToString", function() { return arrayBufferToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToHexCodes", function() { return bufferToHexCodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkBufferParams", function() { return checkBufferParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearProps", function() { return clearProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromBase64", function() { return fromBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParametersValue", function() { return getParametersValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUTCDate", function() { return getUTCDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEqualBuffer", function() { return isEqualBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nearestPowerOf2", function() { return nearestPowerOf2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padNumber", function() { return padNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringToArrayBuffer", function() { return stringToArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toBase64", function() { return toBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilConcatBuf", function() { return utilConcatBuf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilConcatView", function() { return utilConcatView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilDecodeTC", function() { return utilDecodeTC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilEncodeTC", function() { return utilEncodeTC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilFromBase", function() { return utilFromBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilToBase", function() { return utilToBase; });
/*!
 Copyright (c) Peculiar Ventures, LLC
*/

function getUTCDate(date) {
    return new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
}
function getParametersValue(parameters, name, defaultValue) {
    var _a;
    if ((parameters instanceof Object) === false) {
        return defaultValue;
    }
    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
}
function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false) {
    let result = "";
    for (const item of (new Uint8Array(inputBuffer, inputOffset, inputLength))) {
        const str = item.toString(16).toUpperCase();
        if (str.length === 1) {
            result += "0";
        }
        result += str;
        if (insertSpace) {
            result += " ";
        }
    }
    return result.trim();
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof ArrayBuffer)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}
function utilFromBase(inputBuffer, inputBase) {
    let result = 0;
    if (inputBuffer.length === 1) {
        return inputBuffer[0];
    }
    for (let i = (inputBuffer.length - 1); i >= 0; i--) {
        result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);
    }
    return result;
}
function utilToBase(value, base, reserved = (-1)) {
    const internalReserved = reserved;
    let internalValue = value;
    let result = 0;
    let biggest = Math.pow(2, base);
    for (let i = 1; i < 8; i++) {
        if (value < biggest) {
            let retBuf;
            if (internalReserved < 0) {
                retBuf = new ArrayBuffer(i);
                result = i;
            }
            else {
                if (internalReserved < i) {
                    return (new ArrayBuffer(0));
                }
                retBuf = new ArrayBuffer(internalReserved);
                result = internalReserved;
            }
            const retView = new Uint8Array(retBuf);
            for (let j = (i - 1); j >= 0; j--) {
                const basis = Math.pow(2, j * base);
                retView[result - j - 1] = Math.floor(internalValue / basis);
                internalValue -= (retView[result - j - 1]) * basis;
            }
            return retBuf;
        }
        biggest *= Math.pow(2, base);
    }
    return new ArrayBuffer(0);
}
function utilConcatBuf(...buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for (const buffer of buffers) {
        outputLength += buffer.byteLength;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const buffer of buffers) {
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
    }
    return retBuf;
}
function utilConcatView(...views) {
    let outputLength = 0;
    let prevLength = 0;
    for (const view of views) {
        outputLength += view.length;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const view of views) {
        retView.set(view, prevLength);
        prevLength += view.length;
    }
    return retView;
}
function utilDecodeTC() {
    const buf = new Uint8Array(this.valueHex);
    if (this.valueHex.byteLength >= 2) {
        const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);
        const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);
        if (condition1 || condition2) {
            this.warnings.push("Needlessly long format");
        }
    }
    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const bigIntView = new Uint8Array(bigIntBuffer);
    for (let i = 0; i < this.valueHex.byteLength; i++) {
        bigIntView[i] = 0;
    }
    bigIntView[0] = (buf[0] & 0x80);
    const bigInt = utilFromBase(bigIntView, 8);
    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const smallIntView = new Uint8Array(smallIntBuffer);
    for (let j = 0; j < this.valueHex.byteLength; j++) {
        smallIntView[j] = buf[j];
    }
    smallIntView[0] &= 0x7F;
    const smallInt = utilFromBase(smallIntView, 8);
    return (smallInt - bigInt);
}
function utilEncodeTC(value) {
    const modValue = (value < 0) ? (value * (-1)) : value;
    let bigInt = 128;
    for (let i = 1; i < 8; i++) {
        if (modValue <= bigInt) {
            if (value < 0) {
                const smallInt = bigInt - modValue;
                const retBuf = utilToBase(smallInt, 8, i);
                const retView = new Uint8Array(retBuf);
                retView[0] |= 0x80;
                return retBuf;
            }
            let retBuf = utilToBase(modValue, 8, i);
            let retView = new Uint8Array(retBuf);
            if (retView[0] & 0x80) {
                const tempBuf = retBuf.slice(0);
                const tempView = new Uint8Array(tempBuf);
                retBuf = new ArrayBuffer(retBuf.byteLength + 1);
                retView = new Uint8Array(retBuf);
                for (let k = 0; k < tempBuf.byteLength; k++) {
                    retView[k + 1] = tempView[k];
                }
                retView[0] = 0x00;
            }
            return retBuf;
        }
        bigInt *= Math.pow(2, 8);
    }
    return (new ArrayBuffer(0));
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
        return false;
    }
    const view1 = new Uint8Array(inputBuffer1);
    const view2 = new Uint8Array(inputBuffer2);
    for (let i = 0; i < view1.length; i++) {
        if (view1[i] !== view2[i]) {
            return false;
        }
    }
    return true;
}
function padNumber(inputNumber, fullLength) {
    const str = inputNumber.toString(10);
    if (fullLength < str.length) {
        return "";
    }
    const dif = fullLength - str.length;
    const padding = new Array(dif);
    for (let i = 0; i < dif; i++) {
        padding[i] = "0";
    }
    const paddingString = padding.join("");
    return paddingString.concat(str);
}
const base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
    let i = 0;
    let flag1 = 0;
    let flag2 = 0;
    let output = "";
    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
    if (skipLeadingZeros) {
        let nonZeroPosition = 0;
        for (let i = 0; i < input.length; i++) {
            if (input.charCodeAt(i) !== 0) {
                nonZeroPosition = i;
                break;
            }
        }
        input = input.slice(nonZeroPosition);
    }
    while (i < input.length) {
        const chr1 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag1 = 1;
        }
        const chr2 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag2 = 1;
        }
        const chr3 = input.charCodeAt(i++);
        const enc1 = chr1 >> 2;
        const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);
        let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);
        let enc4 = chr3 & 0x3F;
        if (flag1 === 1) {
            enc3 = enc4 = 64;
        }
        else {
            if (flag2 === 1) {
                enc4 = 64;
            }
        }
        if (skipPadding) {
            if (enc3 === 64) {
                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
            }
            else {
                if (enc4 === 64) {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
                }
                else {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
                }
            }
        }
        else {
            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        }
    }
    return output;
}
function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
    function indexOf(toSearch) {
        for (let i = 0; i < 64; i++) {
            if (template.charAt(i) === toSearch)
                return i;
        }
        return 64;
    }
    function test(incoming) {
        return ((incoming === 64) ? 0x00 : incoming);
    }
    let i = 0;
    let output = "";
    while (i < input.length) {
        const enc1 = indexOf(input.charAt(i++));
        const enc2 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const enc3 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const enc4 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);
        const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);
        const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    if (cutTailZeros) {
        const outputLength = output.length;
        let nonZeroStart = (-1);
        for (let i = (outputLength - 1); i >= 0; i--) {
            if (output.charCodeAt(i) !== 0) {
                nonZeroStart = i;
                break;
            }
        }
        if (nonZeroStart !== (-1)) {
            output = output.slice(0, nonZeroStart + 1);
        }
        else {
            output = "";
        }
    }
    return output;
}
function arrayBufferToString(buffer) {
    let resultString = "";
    const view = new Uint8Array(buffer);
    for (const element of view) {
        resultString += String.fromCharCode(element);
    }
    return resultString;
}
function stringToArrayBuffer(str) {
    const stringLength = str.length;
    const resultBuffer = new ArrayBuffer(stringLength);
    const resultView = new Uint8Array(resultBuffer);
    for (let i = 0; i < stringLength; i++) {
        resultView[i] = str.charCodeAt(i);
    }
    return resultBuffer;
}
const log2 = Math.log(2);
function nearestPowerOf2(length) {
    const base = (Math.log(length) / log2);
    const floor = Math.floor(base);
    const round = Math.round(base);
    return ((floor === round) ? floor : round);
}
function clearProps(object, propsArray) {
    for (const prop of propsArray) {
        delete object[prop];
    }
}




/***/ }),

/***/ "./node_modules/asn1js/src/asn1.js":
/*!*****************************************!*\
  !*** ./node_modules/asn1js/src/asn1.js ***!
  \*****************************************/
/*! exports provided: HexBlock, ValueBlock, BaseBlock, Primitive, Constructed, EndOfContent, Boolean, Sequence, Set, Null, OctetString, BitString, Integer, Enumerated, ObjectIdentifier, Utf8String, RelativeObjectIdentifier, BmpString, UniversalString, NumericString, PrintableString, TeletexString, VideotexString, IA5String, GraphicString, VisibleString, GeneralString, CharacterString, UTCTime, GeneralizedTime, DATE, TimeOfDay, DateTime, Duration, TIME, Choice, Any, Repeated, RawData, fromBER, compareSchema, verifySchema, fromJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HexBlock", function() { return HexBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ValueBlock", function() { return ValueBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseBlock", function() { return BaseBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Primitive", function() { return Primitive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Constructed", function() { return Constructed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EndOfContent", function() { return EndOfContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Boolean", function() { return Boolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sequence", function() { return Sequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Set", function() { return Set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Null", function() { return Null; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctetString", function() { return OctetString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BitString", function() { return BitString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Integer", function() { return Integer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Enumerated", function() { return Enumerated; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectIdentifier", function() { return ObjectIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Utf8String", function() { return Utf8String; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RelativeObjectIdentifier", function() { return RelativeObjectIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BmpString", function() { return BmpString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniversalString", function() { return UniversalString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumericString", function() { return NumericString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrintableString", function() { return PrintableString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TeletexString", function() { return TeletexString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideotexString", function() { return VideotexString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IA5String", function() { return IA5String; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicString", function() { return GraphicString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VisibleString", function() { return VisibleString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeneralString", function() { return GeneralString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CharacterString", function() { return CharacterString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UTCTime", function() { return UTCTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeneralizedTime", function() { return GeneralizedTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATE", function() { return DATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeOfDay", function() { return TimeOfDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateTime", function() { return DateTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Duration", function() { return Duration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TIME", function() { return TIME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Choice", function() { return Choice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Any", function() { return Any; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Repeated", function() { return Repeated; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawData", function() { return RawData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromBER", function() { return fromBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareSchema", function() { return compareSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifySchema", function() { return verifySchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromJSON", function() { return fromJSON; });
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pvutils */ "./node_modules/asn1js/node_modules/pvutils/build/utils.es.js");
/* eslint-disable indent */
/*
 * Copyright (c) 2016-2018, Peculiar Ventures
 * All rights reserved.
 *
 * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */
//**************************************************************************************

//**************************************************************************************
//region Other utility functions
//**************************************************************************************
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")
  }
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of global variables
//**************************************************************************************
const powers2 = [new Uint8Array([1])];
const digitsString = "0123456789";
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration for "LocalBaseBlock" class
//**************************************************************************************
/**
 * Class used as a base block for all remaining ASN.1 classes
 * @typedef LocalBaseBlock
 * @interface
 * @property {number} blockLength
 * @property {string} error
 * @property {Array.<string>} warnings
 * @property {ArrayBuffer} valueBeforeDecode
 */
class LocalBaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBaseBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueBeforeDecode]
	 */
	constructor(parameters = {})
	{
		/**
		 * @type {number} blockLength
		 */
		this.blockLength = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "blockLength", 0);
		/**
		 * @type {string} error
		 */
		this.error = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "error", "");
		/**
		 * @type {Array.<string>} warnings
		 */
		this.warnings = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "warnings", []);
		//noinspection JSCheckFunctionSignatures
		/**
		 * @type {ArrayBuffer} valueBeforeDecode
		 */
		if("valueBeforeDecode" in parameters)
			this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);
		else
			this.valueBeforeDecode = new ArrayBuffer(0);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "baseBlock";
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		return {
			blockName: this.constructor.blockName(),
			blockLength: this.blockLength,
			error: this.error,
			warnings: this.warnings,
			valueBeforeDecode: Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)
		};
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Description for "HexBlock" class
//**************************************************************************************
/**
 * Class used as a base block for all remaining ASN.1 classes
 * @extends LocalBaseBlock
 * @typedef HexBlock
 * @property {number} blockLength
 * @property {string} error
 * @property {Array.<string>} warnings
 * @property {ArrayBuffer} valueBeforeDecode
 * @property {boolean} isHexOnly
 * @property {ArrayBuffer} valueHex
 */
//noinspection JSUnusedLocalSymbols
const HexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass
{
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Constructor for "HexBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		/**
		 * @type {boolean}
		 */
		this.isHexOnly = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "isHexOnly", false);
		/**
		 * @type {ArrayBuffer}
		 */
		if("valueHex" in parameters)
			this.valueHex = parameters.valueHex.slice(0);
		else
			this.valueHex = new ArrayBuffer(0);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "hexBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//endregion

		//region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//endregion

		//region Initial checks
		if(intBuffer.length === 0)
		{
			this.warnings.push("Zero buffer length");
			return inputOffset;
		}
		//endregion

		//region Copy input buffer to internal buffer
		this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);
		//endregion

		this.blockLength = inputLength;

		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		if(this.isHexOnly !== true)
		{
			this.error = "Flag \"isHexOnly\" is not set, abort";
			return new ArrayBuffer(0);
		}

		if(sizeOnly === true)
			return new ArrayBuffer(this.valueHex.byteLength);

		//noinspection JSCheckFunctionSignatures
		return this.valueHex.slice(0);
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.blockName = this.constructor.blockName();
		object.isHexOnly = this.isHexOnly;
		object.valueHex = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueHex, 0, this.valueHex.byteLength);

		return object;
	}
	//**********************************************************************************
};
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of identification block class
//**************************************************************************************
class LocalIdentificationBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBaseBlock" class
	 * @param {Object} [parameters={}]
	 * @property {Object} [idBlock]
	 */
	constructor(parameters = {})
	{
		super();

		if("idBlock" in parameters)
		{
			//region Properties from hexBlock class
			this.isHexOnly = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters.idBlock, "isHexOnly", false);
			this.valueHex = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters.idBlock, "valueHex", new ArrayBuffer(0));
			//endregion

			this.tagClass = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters.idBlock, "tagClass", (-1));
			this.tagNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters.idBlock, "tagNumber", (-1));
			this.isConstructed = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters.idBlock, "isConstructed", false);
		}
		else
		{
			this.tagClass = (-1);
			this.tagNumber = (-1);
			this.isConstructed = false;
		}
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "identificationBlock";
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//region Initial variables
		let firstOctet = 0;
		let retBuf;
		let retView;
		//endregion

		switch(this.tagClass)
		{
			case 1:
				firstOctet |= 0x00; // UNIVERSAL
				break;
			case 2:
				firstOctet |= 0x40; // APPLICATION
				break;
			case 3:
				firstOctet |= 0x80; // CONTEXT-SPECIFIC
				break;
			case 4:
				firstOctet |= 0xC0; // PRIVATE
				break;
			default:
				this.error = "Unknown tag class";
				return (new ArrayBuffer(0));
		}

		if(this.isConstructed)
			firstOctet |= 0x20;

		if((this.tagNumber < 31) && (!this.isHexOnly))
		{
			retBuf = new ArrayBuffer(1);
			retView = new Uint8Array(retBuf);

			if(!sizeOnly)
			{
				let number = this.tagNumber;
				number &= 0x1F;
				firstOctet |= number;

				retView[0] = firstOctet;
			}

			return retBuf;
		}

		if(this.isHexOnly === false)
		{
			const encodedBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilToBase"])(this.tagNumber, 7);
			const encodedView = new Uint8Array(encodedBuf);
			const size = encodedBuf.byteLength;

			retBuf = new ArrayBuffer(size + 1);
			retView = new Uint8Array(retBuf);
			retView[0] = (firstOctet | 0x1F);

			if(!sizeOnly)
			{
				for(let i = 0; i < (size - 1); i++)
					retView[i + 1] = encodedView[i] | 0x80;

				retView[size] = encodedView[size - 1];
			}

			return retBuf;
		}

		retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
		retView = new Uint8Array(retBuf);

		retView[0] = (firstOctet | 0x1F);

		if(sizeOnly === false)
		{
			const curView = new Uint8Array(this.valueHex);

			for(let i = 0; i < (curView.length - 1); i++)
				retView[i + 1] = curView[i] | 0x80;

			retView[this.valueHex.byteLength] = curView[curView.length - 1];
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//endregion

		//region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//endregion

		//region Initial checks
		if(intBuffer.length === 0)
		{
			this.error = "Zero buffer length";
			return (-1);
		}
		//endregion

		//region Find tag class
		const tagClassMask = intBuffer[0] & 0xC0;

		switch(tagClassMask)
		{
			case 0x00:
				this.tagClass = (1); // UNIVERSAL
				break;
			case 0x40:
				this.tagClass = (2); // APPLICATION
				break;
			case 0x80:
				this.tagClass = (3); // CONTEXT-SPECIFIC
				break;
			case 0xC0:
				this.tagClass = (4); // PRIVATE
				break;
			default:
				this.error = "Unknown tag class";
				return (-1);
		}
		//endregion

		//region Find it's constructed or not
		this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
		//endregion

		//region Find tag number
		this.isHexOnly = false;

		const tagNumberMask = intBuffer[0] & 0x1F;

		//region Simple case (tag number < 31)
		if(tagNumberMask !== 0x1F)
		{
			this.tagNumber = (tagNumberMask);
			this.blockLength = 1;
		}
		//endregion
		//region Tag number bigger or equal to 31
		else
		{
			let count = 1;

			this.valueHex = new ArrayBuffer(255);
			let tagNumberBufferMaxLength = 255;
			let intTagNumberBuffer = new Uint8Array(this.valueHex);

			//noinspection JSBitwiseOperatorUsage
			while(intBuffer[count] & 0x80)
			{
				intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
				count++;

				if(count >= intBuffer.length)
				{
					this.error = "End of input reached before message was fully decoded";
					return (-1);
				}

				//region In case if tag number length is greater than 255 bytes (rare but possible case)
				if(count === tagNumberBufferMaxLength)
				{
					tagNumberBufferMaxLength += 255;

					const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);
					const tempBufferView = new Uint8Array(tempBuffer);

					for(let i = 0; i < intTagNumberBuffer.length; i++)
						tempBufferView[i] = intTagNumberBuffer[i];

					this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);
					intTagNumberBuffer = new Uint8Array(this.valueHex);
				}
				//endregion
			}

			this.blockLength = (count + 1);
			intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer

			//region Cut buffer
			const tempBuffer = new ArrayBuffer(count);
			const tempBufferView = new Uint8Array(tempBuffer);

			for(let i = 0; i < count; i++)
				tempBufferView[i] = intTagNumberBuffer[i];

			this.valueHex = new ArrayBuffer(count);
			intTagNumberBuffer = new Uint8Array(this.valueHex);
			intTagNumberBuffer.set(tempBufferView);
			//endregion

			//region Try to convert long tag number to short form
			if(this.blockLength <= 9)
				this.tagNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilFromBase"])(intTagNumberBuffer, 7);
			else
			{
				this.isHexOnly = true;
				this.warnings.push("Tag too long, represented as hex-coded");
			}
			//endregion
		}
		//endregion
		//endregion

		//region Check if constructed encoding was using for primitive type
		if(((this.tagClass === 1)) &&
			(this.isConstructed))
		{
			switch(this.tagNumber)
			{
				case 1:  // Boolean
				case 2:  // REAL
				case 5:  // Null
				case 6:  // OBJECT IDENTIFIER
				case 9:  // REAL
				case 13: // RELATIVE OBJECT IDENTIFIER
				case 14: // Time
				case 23:
				case 24:
				case 31:
				case 32:
				case 33:
				case 34:
					this.error = "Constructed encoding used for primitive type";
					return (-1);
				default:
			}
		}
		//endregion

		return (inputOffset + this.blockLength); // Return current offset in input buffer
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {{blockName: string,
	 *  tagClass: number,
	 *  tagNumber: number,
	 *  isConstructed: boolean,
	 *  isHexOnly: boolean,
	 *  valueHex: ArrayBuffer,
	 *  blockLength: number,
	 *  error: string, warnings: Array.<string>,
	 *  valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.blockName = this.constructor.blockName();
		object.tagClass = this.tagClass;
		object.tagNumber = this.tagNumber;
		object.isConstructed = this.isConstructed;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of length block class
//**************************************************************************************
class LocalLengthBlock extends LocalBaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalLengthBlock" class
	 * @param {Object} [parameters={}]
	 * @property {Object} [lenBlock]
	 */
	constructor(parameters = {})
	{
		super();

		if("lenBlock" in parameters)
		{
			this.isIndefiniteForm = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters.lenBlock, "isIndefiniteForm", false);
			this.longFormUsed = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters.lenBlock, "longFormUsed", false);
			this.length = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters.lenBlock, "length", 0);
		}
		else
		{
			this.isIndefiniteForm = false;
			this.longFormUsed = false;
			this.length = 0;
		}
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "lengthBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//endregion

		//region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//endregion

		//region Initial checks
		if(intBuffer.length === 0)
		{
			this.error = "Zero buffer length";
			return (-1);
		}

		if(intBuffer[0] === 0xFF)
		{
			this.error = "Length block 0xFF is reserved by standard";
			return (-1);
		}
		//endregion

		//region Check for length form type
		this.isIndefiniteForm = intBuffer[0] === 0x80;
		//endregion

		//region Stop working in case of indefinite length form
		if(this.isIndefiniteForm === true)
		{
			this.blockLength = 1;
			return (inputOffset + this.blockLength);
		}
		//endregion

		//region Check is long form of length encoding using
		this.longFormUsed = !!(intBuffer[0] & 0x80);
		//endregion

		//region Stop working in case of short form of length value
		if(this.longFormUsed === false)
		{
			this.length = (intBuffer[0]);
			this.blockLength = 1;
			return (inputOffset + this.blockLength);
		}
		//endregion

		//region Calculate length value in case of long form
		const count = intBuffer[0] & 0x7F;

		if(count > 8) // Too big length value
		{
			this.error = "Too big integer";
			return (-1);
		}

		if((count + 1) > intBuffer.length)
		{
			this.error = "End of input reached before message was fully decoded";
			return (-1);
		}

		const lengthBufferView = new Uint8Array(count);

		for(let i = 0; i < count; i++)
			lengthBufferView[i] = intBuffer[i + 1];

		if(lengthBufferView[count - 1] === 0x00)
			this.warnings.push("Needlessly long encoded length");

		this.length = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilFromBase"])(lengthBufferView, 8);

		if(this.longFormUsed && (this.length <= 127))
			this.warnings.push("Unnecessary usage of long length form");

		this.blockLength = count + 1;
		//endregion

		return (inputOffset + this.blockLength); // Return current offset in input buffer
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//region Initial variables
		let retBuf;
		let retView;
		//endregion

		if(this.length > 127)
			this.longFormUsed = true;

		if(this.isIndefiniteForm)
		{
			retBuf = new ArrayBuffer(1);

			if(sizeOnly === false)
			{
				retView = new Uint8Array(retBuf);
				retView[0] = 0x80;
			}

			return retBuf;
		}

		if(this.longFormUsed === true)
		{
			const encodedBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilToBase"])(this.length, 8);

			if(encodedBuf.byteLength > 127)
			{
				this.error = "Too big length";
				return (new ArrayBuffer(0));
			}

			retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);

			if(sizeOnly === true)
				return retBuf;

			const encodedView = new Uint8Array(encodedBuf);
			retView = new Uint8Array(retBuf);

			retView[0] = encodedBuf.byteLength | 0x80;

			for(let i = 0; i < encodedBuf.byteLength; i++)
				retView[i + 1] = encodedView[i];

			return retBuf;
		}

		retBuf = new ArrayBuffer(1);

		if(sizeOnly === false)
		{
			retView = new Uint8Array(retBuf);

			retView[0] = this.length;
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.blockName = this.constructor.blockName();
		object.isIndefiniteForm = this.isIndefiniteForm;
		object.longFormUsed = this.longFormUsed;
		object.length = this.length;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of value block class
//**************************************************************************************
class ValueBlock extends LocalBaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "ValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "valueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region Throw an exception for a function which needs to be specified in extended classes
		throw TypeError("User need to make a specific function in a class which extends \"ValueBlock\"");
		//endregion
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//region Throw an exception for a function which needs to be specified in extended classes
		throw TypeError("User need to make a specific function in a class which extends \"ValueBlock\"");
		//endregion
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of basic ASN.1 block class
//**************************************************************************************
class BaseBlock extends LocalBaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "BaseBlock" class
	 * @param {Object} [parameters={}]
	 * @property {Object} [primitiveSchema]
	 * @property {string} [name]
	 * @property {boolean} [optional]
	 * @param valueBlockType Type of value block
	 */
	constructor(parameters = {}, valueBlockType = ValueBlock)
	{
		super(parameters);

		if("name" in parameters)
			this.name = parameters.name;
		if("optional" in parameters)
			this.optional = parameters.optional;
		if("primitiveSchema" in parameters)
			this.primitiveSchema = parameters.primitiveSchema;

		this.idBlock = new LocalIdentificationBlock(parameters);
		this.lenBlock = new LocalLengthBlock(parameters);
		this.valueBlock = new valueBlockType(parameters);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "BaseBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		let retBuf;

		const idBlockBuf = this.idBlock.toBER(sizeOnly);
		const valueBlockSizeBuf = this.valueBlock.toBER(true);

		this.lenBlock.length = valueBlockSizeBuf.byteLength;
		const lenBlockBuf = this.lenBlock.toBER(sizeOnly);

		retBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilConcatBuf"])(idBlockBuf, lenBlockBuf);

		let valueBlockBuf;

		if(sizeOnly === false)
			valueBlockBuf = this.valueBlock.toBER(sizeOnly);
		else
			valueBlockBuf = new ArrayBuffer(this.lenBlock.length);

		retBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilConcatBuf"])(retBuf, valueBlockBuf);

		if(this.lenBlock.isIndefiniteForm === true)
		{
			const indefBuf = new ArrayBuffer(2);

			if(sizeOnly === false)
			{
				const indefView = new Uint8Array(indefBuf);

				indefView[0] = 0x00;
				indefView[1] = 0x00;
			}

			retBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilConcatBuf"])(retBuf, indefBuf);
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.idBlock = this.idBlock.toJSON();
		object.lenBlock = this.lenBlock.toJSON();
		object.valueBlock = this.valueBlock.toJSON();

		if("name" in this)
			object.name = this.name;
		if("optional" in this)
			object.optional = this.optional;
		if("primitiveSchema" in this)
			object.primitiveSchema = this.primitiveSchema.toJSON();

		return object;
	}
	//**********************************************************************************
	toString() {
		return `${this.constructor.blockName()} : ${Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueBlock.valueHex)}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of basic block for all PRIMITIVE types
//**************************************************************************************
class LocalPrimitiveValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalPrimitiveValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueBeforeDecode]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		//region Variables from "hexBlock" class
		if("valueHex" in parameters)
			this.valueHex = parameters.valueHex.slice(0);
		else
			this.valueHex = new ArrayBuffer(0);

		this.isHexOnly = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "isHexOnly", true);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//endregion

		//region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//endregion

		//region Initial checks
		if(intBuffer.length === 0)
		{
			this.warnings.push("Zero buffer length");
			return inputOffset;
		}
		//endregion

		//region Copy input buffer into internal buffer
		this.valueHex = new ArrayBuffer(intBuffer.length);
		const valueHexView = new Uint8Array(this.valueHex);

		for(let i = 0; i < intBuffer.length; i++)
			valueHexView[i] = intBuffer[i];
		//endregion

		this.blockLength = inputLength;

		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		return this.valueHex.slice(0);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "PrimitiveValueBlock";
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.valueHex = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueHex, 0, this.valueHex.byteLength);
		object.isHexOnly = this.isHexOnly;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class Primitive extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Primitive" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalPrimitiveValueBlock);

		this.idBlock.isConstructed = false;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "PRIMITIVE";
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of basic block for all CONSTRUCTED types
//**************************************************************************************
class LocalConstructedValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalConstructedValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "value", []);
		this.isIndefiniteForm = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "isIndefiniteForm", false);
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region Store initial offset and length
		const initialOffset = inputOffset;
		const initialLength = inputLength;
		//endregion

		//region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//endregion

		//region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//endregion

		//region Initial checks
		if(intBuffer.length === 0)
		{
			this.warnings.push("Zero buffer length");
			return inputOffset;
		}
		//endregion

		//region Aux function
		function checkLen(indefiniteLength, length)
		{
			if(indefiniteLength === true)
				return 1;

			return length;
		}
		//endregion

		let currentOffset = inputOffset;

		while(checkLen(this.isIndefiniteForm, inputLength) > 0)
		{
			const returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);
			if(returnObject.offset === (-1))
			{
				this.error = returnObject.result.error;
				this.warnings.concat(returnObject.result.warnings);
				return (-1);
			}

			currentOffset = returnObject.offset;

			this.blockLength += returnObject.result.blockLength;
			inputLength -= returnObject.result.blockLength;

			this.value.push(returnObject.result);

			if((this.isIndefiniteForm === true) && (returnObject.result.constructor.blockName() === EndOfContent.blockName()))
				break;
		}

		if(this.isIndefiniteForm === true)
		{
			if(this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName())
				this.value.pop();
			else
				this.warnings.push("No EndOfContent block encoded");
		}

		//region Copy "inputBuffer" to "valueBeforeDecode"
		this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);
		//endregion

		return currentOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		let retBuf = new ArrayBuffer(0);

		for(let i = 0; i < this.value.length; i++)
		{
			const valueBuf = this.value[i].toBER(sizeOnly);
			retBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilConcatBuf"])(retBuf, valueBuf);
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "ConstructedValueBlock";
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.isIndefiniteForm = this.isIndefiniteForm;
		object.value = [];
		for(let i = 0; i < this.value.length; i++)
			object.value.push(this.value[i].toJSON());

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class Constructed extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Constructed" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalConstructedValueBlock);

		this.idBlock.isConstructed = true;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "CONSTRUCTED";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	toString() {
		const values = [];
		for (const value of this.valueBlock.value) {
			values.push(value.toString().split("\n").map(o => `  ${o}`).join("\n"));
		}
		const blockName = this.idBlock.tagClass === 3
			? `[${this.idBlock.tagNumber}]`
			: this.constructor.blockName();
		return values.length 
			? `${blockName} :\n${values.join("\n")}` // items
			: `${blockName} :`; // empty
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of ASN.1 EndOfContent type class
//**************************************************************************************
class LocalEndOfContentValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalEndOfContentValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number}
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region There is no "value block" for EndOfContent type and we need to return the same offset
		return inputOffset;
		//endregion
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		return new ArrayBuffer(0);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "EndOfContentValueBlock";
	}
	//**********************************************************************************
}
//**************************************************************************************
class EndOfContent extends BaseBlock
{
	//**********************************************************************************
	constructor(paramaters = {})
	{
		super(paramaters, LocalEndOfContentValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 0; // EndOfContent
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "EndOfContent";
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of ASN.1 Boolean type class
//**************************************************************************************
class LocalBooleanValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBooleanValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);
		
		this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "value", false);
		this.isHexOnly = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "isHexOnly", false);
		
		if("valueHex" in parameters)
			this.valueHex = parameters.valueHex.slice(0);
		else
		{
			this.valueHex = new ArrayBuffer(1);
			if(this.value === true)
			{
				const view = new Uint8Array(this.valueHex);
				view[0] = 0xFF;
			}
		}
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//endregion

		//region Getting Uint8Array from ArrayBuffer
		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
		//endregion

		if(inputLength > 1)
			this.warnings.push("Boolean value encoded in more then 1 octet");

		this.isHexOnly = true;

		//region Copy input buffer to internal array
		this.valueHex = new ArrayBuffer(intBuffer.length);
		const view = new Uint8Array(this.valueHex);

		for(let i = 0; i < intBuffer.length; i++)
			view[i] = intBuffer[i];
		//endregion
		
		if(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilDecodeTC"].call(this) !== 0 )
			this.value = true;
		else
			this.value = false;

		this.blockLength = inputLength;

		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		return this.valueHex;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "BooleanValueBlock";
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.value = this.value;
		object.isHexOnly = this.isHexOnly;
		object.valueHex = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueHex, 0, this.valueHex.byteLength);

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class Boolean extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Boolean" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalBooleanValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 1; // Boolean
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "BOOLEAN";
	}
	//**********************************************************************************
	toString() {
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of ASN.1 Sequence and Set type classes
//**************************************************************************************
class Sequence extends Constructed
{
	//**********************************************************************************
	/**
	 * Constructor for "Sequence" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 16; // Sequence
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "SEQUENCE";
	}
	//**********************************************************************************
}
//**************************************************************************************
class Set extends Constructed
{
	//**********************************************************************************
	/**
	 * Constructor for "Set" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 17; // Set
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "SET";
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of ASN.1 Null type class
//**************************************************************************************
class Null extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Null" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalBaseBlock); // We will not have a call to "Null value block" because of specified "fromBER" and "toBER" functions

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 5; // Null
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "NULL";
	}
	//**********************************************************************************
	//noinspection JSUnusedLocalSymbols
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		if(this.lenBlock.length > 0)
			this.warnings.push("Non-zero length of value block for Null type");

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;
		
		this.blockLength += inputLength;
		
		if((inputOffset + inputLength) > inputBuffer.byteLength)
		{
			this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
			return (-1);
		}
		
		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		const retBuf = new ArrayBuffer(2);

		if(sizeOnly === true)
			return retBuf;

		const retView = new Uint8Array(retBuf);
		retView[0] = 0x05;
		retView[1] = 0x00;

		return retBuf;
	}
	//**********************************************************************************
	toString() {
		return `${this.constructor.blockName()}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of ASN.1 OctetString type class
//**************************************************************************************
class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalOctetStringValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.isConstructed = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "isConstructed", false);
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		let resultOffset = 0;

		if(this.isConstructed === true)
		{
			this.isHexOnly = false;

			resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
			if(resultOffset === (-1))
				return resultOffset;

			for(let i = 0; i < this.value.length; i++)
			{
				const currentBlockName = this.value[i].constructor.blockName();

				if(currentBlockName === EndOfContent.blockName())
				{
					if(this.isIndefiniteForm === true)
						break;
					else
					{
						this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
						return (-1);
					}
				}

				if(currentBlockName !== OctetString.blockName())
				{
					this.error = "OCTET STRING may consists of OCTET STRINGs only";
					return (-1);
				}
			}
		}
		else
		{
			this.isHexOnly = true;

			resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
			this.blockLength = inputLength;
		}

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		if(this.isConstructed === true)
			return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);

		let retBuf = new ArrayBuffer(this.valueHex.byteLength);

		if(sizeOnly === true)
			return retBuf;

		if(this.valueHex.byteLength === 0)
			return retBuf;

		retBuf = this.valueHex.slice(0);

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "OctetStringValueBlock";
	}
	//**********************************************************************************
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.isConstructed = this.isConstructed;
		object.isHexOnly = this.isHexOnly;
		object.valueHex = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueHex, 0, this.valueHex.byteLength);

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class OctetString extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "OctetString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalOctetStringValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 4; // OctetString
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		this.valueBlock.isConstructed = this.idBlock.isConstructed;
		this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

		//region Ability to encode empty OCTET STRING
		if(inputLength === 0)
		{
			if(this.idBlock.error.length === 0)
				this.blockLength += this.idBlock.blockLength;

			if(this.lenBlock.error.length === 0)
				this.blockLength += this.lenBlock.blockLength;

			return inputOffset;
		}
		//endregion

		if (!this.valueBlock.isConstructed) {
			const buf = inputBuffer.slice(inputOffset, inputOffset + inputLength);
			try {
				const asn = fromBER(buf);
				if (asn.offset !== -1 && asn.offset === inputLength) {
					this.valueBlock.value = [asn.result];
				}
			} catch (e) {
				// nothing
			}
		}

		return super.fromBER(inputBuffer, inputOffset, inputLength);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "OCTET STRING";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Checking that two OCTETSTRINGs are equal
	 * @param {OctetString} octetString
	 */
	isEqual(octetString)
	{
		//region Check input type
		if((octetString instanceof OctetString) === false)
			return false;
		//endregion

		//region Compare two JSON strings
		if(JSON.stringify(this) !== JSON.stringify(octetString))
			return false;
		//endregion

		return true;
	}
	//**********************************************************************************
	toString() {
		if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {
			return Constructed.prototype.toString.call(this);
		} else {
			return `${this.constructor.blockName()} : ${Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueBlock.valueHex)}`;
		}
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of ASN.1 BitString type class
//**************************************************************************************
class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBitStringValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.unusedBits = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "unusedBits", 0);
		this.isConstructed = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "isConstructed", false);
		this.blockLength = this.valueHex.byteLength;
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region Ability to decode zero-length BitString value
		if(inputLength === 0)
			return inputOffset;
		//endregion

		let resultOffset = (-1);

		//region If the BISTRING supposed to be a constructed value
		if(this.isConstructed === true)
		{
			resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
			if(resultOffset === (-1))
				return resultOffset;

			for(let i = 0; i < this.value.length; i++)
			{
				const currentBlockName = this.value[i].constructor.blockName();

				if(currentBlockName === EndOfContent.blockName())
				{
					if(this.isIndefiniteForm === true)
						break;
					else
					{
						this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
						return (-1);
					}
				}

				if(currentBlockName !== BitString.blockName())
				{
					this.error = "BIT STRING may consists of BIT STRINGs only";
					return (-1);
				}

				if((this.unusedBits > 0) && (this.value[i].valueBlock.unusedBits > 0))
				{
					this.error = "Using of \"unused bits\" inside constructive BIT STRING allowed for least one only";
					return (-1);
				}

				this.unusedBits = this.value[i].valueBlock.unusedBits;
				if(this.unusedBits > 7)
				{
					this.error = "Unused bits for BitString must be in range 0-7";
					return (-1);
				}
			}

			return resultOffset;
		}
		//endregion
		//region If the BitString supposed to be a primitive value
		//region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//endregion

		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

		this.unusedBits = intBuffer[0];
		
		if(this.unusedBits > 7)
		{
			this.error = "Unused bits for BitString must be in range 0-7";
			return (-1);
		}

		if (!this.unusedBits) {
			const buf = inputBuffer.slice(inputOffset + 1, inputOffset + inputLength);
			try {
				const asn = fromBER(buf);
				if (asn.offset !== -1 && asn.offset === (inputLength - 1)) {
					this.value = [asn.result];
				}
			} catch(e) {
				// nothing
			}
		}

		//region Copy input buffer to internal buffer
		this.valueHex = new ArrayBuffer(intBuffer.length - 1);
		const view = new Uint8Array(this.valueHex);
		for(let i = 0; i < (inputLength - 1); i++)
			view[i] = intBuffer[i + 1];
		//endregion

		this.blockLength = intBuffer.length;

		return (inputOffset + inputLength);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		if(this.isConstructed === true)
			return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);

		if(sizeOnly === true)
			return (new ArrayBuffer(this.valueHex.byteLength + 1));

		if(this.valueHex.byteLength === 0)
			return (new ArrayBuffer(0));

		const curView = new Uint8Array(this.valueHex);

		const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);
		const retView = new Uint8Array(retBuf);

		retView[0] = this.unusedBits;

		for(let i = 0; i < this.valueHex.byteLength; i++)
			retView[i + 1] = curView[i];

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "BitStringValueBlock";
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.unusedBits = this.unusedBits;
		object.isConstructed = this.isConstructed;
		object.isHexOnly = this.isHexOnly;
		object.valueHex = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueHex, 0, this.valueHex.byteLength);

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class BitString extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "BitString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalBitStringValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 3; // BitString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "BIT STRING";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		//region Ability to encode empty BitString
		if(inputLength === 0)
			return inputOffset;
		//endregion

		this.valueBlock.isConstructed = this.idBlock.isConstructed;
		this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;

		return super.fromBER(inputBuffer, inputOffset, inputLength);
	}
	//**********************************************************************************
	/**
	 * Checking that two BITSTRINGs are equal
	 * @param {BitString} bitString
	 */
	isEqual(bitString)
	{
		//region Check input type
		if((bitString instanceof BitString) === false)
			return false;
		//endregion

		//region Compare two JSON strings
		if(JSON.stringify(this) !== JSON.stringify(bitString))
			return false;
		//endregion

		return true;
	}
	//**********************************************************************************
	toString() {
		if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {
			return Constructed.prototype.toString.call(this);
		} else {
			// convert bytes to bits
			const bits = [];
			const valueHex = new Uint8Array(this.valueBlock.valueHex);
			for (const byte of valueHex) {
				bits.push(byte.toString(2).padStart(8, "0"));
			}
			return `${this.constructor.blockName()} : ${bits.join("")}`;
		}
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of ASN.1 Integer type class
//**************************************************************************************
/**
 * @extends ValueBlock
 */
class LocalIntegerValueBlock extends HexBlock(ValueBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalIntegerValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		if("value" in parameters)
			this.valueDec = parameters.value;
	}
	//**********************************************************************************
	/**
	 * Setter for "valueHex"
	 * @param {ArrayBuffer} _value
	 */
	set valueHex(_value)
	{
		this._valueHex = _value.slice(0);

		if(_value.byteLength >= 4)
		{
			this.warnings.push("Too big Integer for decoding, hex only");
			this.isHexOnly = true;
			this._valueDec = 0;
		}
		else
		{
			this.isHexOnly = false;

			if(_value.byteLength > 0)
				this._valueDec = pvutils__WEBPACK_IMPORTED_MODULE_0__["utilDecodeTC"].call(this);
		}
	}
	//**********************************************************************************
	/**
	 * Getter for "valueHex"
	 * @returns {ArrayBuffer}
	 */
	get valueHex()
	{
		return this._valueHex;
	}
	//**********************************************************************************
	/**
	 * Getter for "valueDec"
	 * @param {number} _value
	 */
	set valueDec(_value)
	{
		this._valueDec = _value;

		this.isHexOnly = false;
		this._valueHex = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilEncodeTC"])(_value);
	}
	//**********************************************************************************
	/**
	 * Getter for "valueDec"
	 * @returns {number}
	 */
	get valueDec()
	{
		return this._valueDec;
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from DER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @param {number} [expectedLength=0] Expected length of converted "valueHex" buffer
	 * @returns {number} Offset after least decoded byte
	 */
	fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0)
	{
		const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
		if(offset === (-1))
			return offset;

		const view = new Uint8Array(this._valueHex);

		if((view[0] === 0x00) && ((view[1] & 0x80) !== 0))
		{
			const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
			const updatedView = new Uint8Array(updatedValueHex);

			updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

			this._valueHex = updatedValueHex.slice(0);
		}
		else
		{
			if(expectedLength !== 0)
			{
				if(this._valueHex.byteLength < expectedLength)
				{
					if((expectedLength - this._valueHex.byteLength) > 1)
						expectedLength = this._valueHex.byteLength + 1;
					
					const updatedValueHex = new ArrayBuffer(expectedLength);
					const updatedView = new Uint8Array(updatedValueHex);

					updatedView.set(view, expectedLength - this._valueHex.byteLength);

					this._valueHex = updatedValueHex.slice(0);
				}
			}
		}

		return offset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toDER(sizeOnly = false)
	{
		const view = new Uint8Array(this._valueHex);

		switch(true)
		{
			case ((view[0] & 0x80) !== 0):
				{
					const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);
					const updatedView = new Uint8Array(updatedValueHex);

					updatedView[0] = 0x00;
					updatedView.set(view, 1);

					this._valueHex = updatedValueHex.slice(0);
				}
				break;
			case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):
				{
					const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);
					const updatedView = new Uint8Array(updatedValueHex);

					updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));

					this._valueHex = updatedValueHex.slice(0);
				}
				break;
			default:
		}

		return this.toBER(sizeOnly);
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
		if(resultOffset === (-1))
			return resultOffset;

		this.blockLength = inputLength;

		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//noinspection JSCheckFunctionSignatures
		return this.valueHex.slice(0);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "IntegerValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.valueDec = this.valueDec;

		return object;
	}
	//**********************************************************************************
	/**
	 * Convert current value to decimal string representation
	 */
	toString()
	{
		//region Aux functions
		function viewAdd(first, second)
		{
			//region Initial variables
			const c = new Uint8Array([0]);
			
			let firstView = new Uint8Array(first);
			let secondView = new Uint8Array(second);
			
			let firstViewCopy = firstView.slice(0);
			const firstViewCopyLength = firstViewCopy.length - 1;
			let secondViewCopy = secondView.slice(0);
			const secondViewCopyLength = secondViewCopy.length - 1;
			
			let value = 0;
			
			const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;
			
			let counter = 0;
			//endregion
			
			for(let i = max; i >= 0; i--, counter++)
			{
				switch(true)
				{
					case (counter < secondViewCopy.length):
						value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
						break;
					default:
						value = firstViewCopy[firstViewCopyLength - counter] + c[0];
				}
				
				c[0] = value / 10;
				
				switch(true)
				{
					case (counter >= firstViewCopy.length):
						firstViewCopy = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilConcatView"])(new Uint8Array([value % 10]), firstViewCopy);
						break;
					default:
						firstViewCopy[firstViewCopyLength - counter] = value % 10;
				}
			}
			
			if(c[0] > 0)
				firstViewCopy = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilConcatView"])(c, firstViewCopy);
			
			return firstViewCopy.slice(0);
		}
		
		function power2(n)
		{
			if(n >= powers2.length)
			{
				for(let p = powers2.length; p <= n; p++)
				{
					const c = new Uint8Array([0]);
					let digits = (powers2[p - 1]).slice(0);
					
					for(let i = (digits.length - 1); i >=0; i--)
					{
						const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
						c[0] = newValue[0] / 10;
						digits[i] = newValue[0] % 10;
					}
					
					if (c[0] > 0)
						digits = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilConcatView"])(c, digits);
					
					powers2.push(digits);
				}
			}
			
			return powers2[n];
		}
		
		function viewSub(first, second)
		{
			//region Initial variables
			let b = 0;
			
			let firstView = new Uint8Array(first);
			let secondView = new Uint8Array(second);
			
			let firstViewCopy = firstView.slice(0);
			const firstViewCopyLength = firstViewCopy.length - 1;
			let secondViewCopy = secondView.slice(0);
			const secondViewCopyLength = secondViewCopy.length - 1;
			
			let value;
			
			let counter = 0;
			//endregion
			
			for(let i = secondViewCopyLength; i >= 0; i--, counter++)
			{
				value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
				
				switch(true)
				{
					case (value < 0):
						b = 1;
						firstViewCopy[firstViewCopyLength - counter] = value + 10;
						break;
					default:
						b = 0;
						firstViewCopy[firstViewCopyLength - counter] = value;
				}
			}
			
			if(b > 0)
			{
				for(let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++)
				{
					value = firstViewCopy[firstViewCopyLength - counter] - b;
					
					if(value < 0)
					{
						b = 1;
						firstViewCopy[firstViewCopyLength - counter] = value + 10;
					}
					else
					{
						b = 0;
						firstViewCopy[firstViewCopyLength - counter] = value;
						break;
					}
				}
			}
			
			return firstViewCopy.slice();
		}
		//endregion
		
		//region Initial variables
		const firstBit = (this._valueHex.byteLength * 8) - 1;
		
		let digits = new Uint8Array((this._valueHex.byteLength * 8) / 3);
		let bitNumber = 0;
		let currentByte;
		
		const asn1View = new Uint8Array(this._valueHex);
		
		let result = "";
		
		let flag = false;
		//endregion
		
		//region Calculate number
		for(let byteNumber = (this._valueHex.byteLength - 1); byteNumber >= 0; byteNumber--)
		{
			currentByte = asn1View[byteNumber];
			
			for(let i = 0; i < 8; i++)
			{
				if((currentByte & 1) === 1)
				{
					switch(bitNumber)
					{
						case firstBit:
							digits = viewSub(power2(bitNumber), digits);
							result = "-";
							break;
						default:
							digits = viewAdd(digits, power2(bitNumber));
					}
				}
				
				bitNumber++;
				currentByte >>= 1;
			}
		}
		//endregion
		
		//region Print number
		for(let i = 0; i < digits.length; i++)
		{
			if(digits[i])
				flag = true;
			
			if(flag)
				result += digitsString.charAt(digits[i]);
		}
		
		if(flag === false)
			result += digitsString.charAt(0);
		//endregion
		
		return result;
	}
	//**********************************************************************************
}
//**************************************************************************************
class Integer extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Integer" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalIntegerValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 2; // Integer
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "INTEGER";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Compare two Integer object, or Integer and ArrayBuffer objects
	 * @param {!Integer|ArrayBuffer} otherValue
	 * @returns {boolean}
	 */
	isEqual(otherValue)
	{
		if(otherValue instanceof Integer)
		{
			if(this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers
				return Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["isEqualBuffer"])(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);

			if(this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly)
				return (this.valueBlock.valueDec === otherValue.valueBlock.valueDec);

			return false;
		}
		
		if(otherValue instanceof ArrayBuffer)
			return Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["isEqualBuffer"])(this.valueBlock.valueHex, otherValue);

		return false;
	}
	//**********************************************************************************
	/**
	 * Convert current Integer value from BER into DER format
	 * @returns {Integer}
	 */
	convertToDER()
	{
		const integer = new Integer({ valueHex: this.valueBlock.valueHex });
		integer.valueBlock.toDER();

		return integer;
	}
	//**********************************************************************************
	/**
	 * Convert current Integer value from DER to BER format
	 * @returns {Integer}
	 */
	convertFromDER()
	{
		const expectedLength = (this.valueBlock.valueHex.byteLength % 2) ? (this.valueBlock.valueHex.byteLength + 1) : this.valueBlock.valueHex.byteLength;
		const integer = new Integer({ valueHex: this.valueBlock.valueHex });
		integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);
		
		return integer;
	}
	//**********************************************************************************
	toString() {
		assertBigInt();
		const hex = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueBlock.valueHex);
		const bigInt = BigInt(`0x${hex}`);
		return `${this.constructor.blockName()} : ${bigInt.toString()}`;
	}
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of ASN.1 Enumerated type class
//**************************************************************************************
class Enumerated extends Integer
{
	//**********************************************************************************
	/**
	 * Constructor for "Enumerated" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 10; // Enumerated
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "ENUMERATED";
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of ASN.1 ObjectIdentifier type class
//**************************************************************************************
class LocalSidValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalSidValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {number} [valueDec]
	 * @property {boolean} [isFirstSid]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.valueDec = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "valueDec", -1);
		this.isFirstSid = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "isFirstSid", false);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "sidBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		if(inputLength === 0)
			return inputOffset;

		//region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//endregion

		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

		this.valueHex = new ArrayBuffer(inputLength);
		let view = new Uint8Array(this.valueHex);

		for(let i = 0; i < inputLength; i++)
		{
			view[i] = intBuffer[i] & 0x7F;

			this.blockLength++;

			if((intBuffer[i] & 0x80) === 0x00)
				break;
		}

		//region Ajust size of valueHex buffer
		const tempValueHex = new ArrayBuffer(this.blockLength);
		const tempView = new Uint8Array(tempValueHex);

		for(let i = 0; i < this.blockLength; i++)
			tempView[i] = view[i];

		//noinspection JSCheckFunctionSignatures
		this.valueHex = tempValueHex.slice(0);
		view = new Uint8Array(this.valueHex);
		//endregion

		if((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)
		{
			this.error = "End of input reached before message was fully decoded";
			return (-1);
		}

		if(view[0] === 0x00)
			this.warnings.push("Needlessly long format of SID encoding");

		if(this.blockLength <= 8)
			this.valueDec = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilFromBase"])(view, 7);
		else
		{
			this.isHexOnly = true;
			this.warnings.push("Too big SID for decoding, hex only");
		}

		return (inputOffset + this.blockLength);
	}
//**********************************************************************************
	/**
	 * Save a BigInt value immediately as an array of octects.
	 */
 set valueBigInt(value) {

	assertBigInt();

	let bits = BigInt(value).toString(2);
	while (bits.length % 7) {
		bits = '0' + bits
	}
	const bytes = new Uint8Array(bits.length / 7)
	for (let i = 0; i < bytes.length; i++) {
		bytes[i] = parseInt(bits.slice(i*7, i*7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0)
	}
	this.fromBER(bytes.buffer, 0, bytes.length)
}
//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//region Initial variables
		let retBuf;
		let retView;
		//endregion

		if(this.isHexOnly)
		{
			if(sizeOnly === true)
				return (new ArrayBuffer(this.valueHex.byteLength));

			const curView = new Uint8Array(this.valueHex);

			retBuf = new ArrayBuffer(this.blockLength);
			retView = new Uint8Array(retBuf);

			for(let i = 0; i < (this.blockLength - 1); i++)
				retView[i] = curView[i] | 0x80;

			retView[this.blockLength - 1] = curView[this.blockLength - 1];

			return retBuf;
		}

		const encodedBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilToBase"])(this.valueDec, 7);
		if(encodedBuf.byteLength === 0)
		{
			this.error = "Error during encoding SID value";
			return (new ArrayBuffer(0));
		}

		retBuf = new ArrayBuffer(encodedBuf.byteLength);

		if(sizeOnly === false)
		{
			const encodedView = new Uint8Array(encodedBuf);
			retView = new Uint8Array(retBuf);

			for(let i = 0; i < (encodedBuf.byteLength - 1); i++)
				retView[i] = encodedView[i] | 0x80;

			retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Create string representation of current SID block
	 * @returns {string}
	 */
	toString()
	{
		let result = "";

		if(this.isHexOnly === true)
			result = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueHex, 0, this.valueHex.byteLength);
		else
		{
			if(this.isFirstSid)
			{
				let sidValue = this.valueDec;

				if(this.valueDec <= 39)
					result = "0.";
				else
				{
					if(this.valueDec <= 79)
					{
						result = "1.";
						sidValue -= 40;
					}
					else
					{
						result = "2.";
						sidValue -= 80;
					}
				}

				result += sidValue.toString();
			}
			else
				result = this.valueDec.toString();
		}

		return result;
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.valueDec = this.valueDec;
		object.isFirstSid = this.isFirstSid;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class LocalObjectIdentifierValueBlock extends ValueBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalObjectIdentifierValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.fromString(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "value", ""));
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		let resultOffset = inputOffset;

		while(inputLength > 0)
		{
			const sidBlock = new LocalSidValueBlock();
			resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
			if(resultOffset === (-1))
			{
				this.blockLength = 0;
				this.error = sidBlock.error;
				return resultOffset;
			}

			if(this.value.length === 0)
				sidBlock.isFirstSid = true;

			this.blockLength += sidBlock.blockLength;
			inputLength -= sidBlock.blockLength;

			this.value.push(sidBlock);
		}

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		let retBuf = new ArrayBuffer(0);

		for(let i = 0; i < this.value.length; i++)
		{
			const valueBuf = this.value[i].toBER(sizeOnly);
			if(valueBuf.byteLength === 0)
			{
				this.error = this.value[i].error;
				return (new ArrayBuffer(0));
			}

			retBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilConcatBuf"])(retBuf, valueBuf);
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Create "LocalObjectIdentifierValueBlock" class from string
	 * @param {string} string Input string to convert from
	 * @returns {boolean}
	 */
	fromString(string)
	{
		this.value = []; // Clear existing SID values

		let pos1 = 0;
		let pos2 = 0;

		let sid = "";

		let flag = false;

		do
		{
			pos2 = string.indexOf(".", pos1);
			if(pos2 === (-1))
				sid = string.substr(pos1);
			else
				sid = string.substr(pos1, pos2 - pos1);

			pos1 = pos2 + 1;

			if(flag)
			{
				const sidBlock = this.value[0];

				let plus = 0;

				switch(sidBlock.valueDec)
				{
					case 0:
						break;
					case 1:
						plus = 40;
						break;
					case 2:
						plus = 80;
						break;
					default:
						this.value = []; // clear SID array
						return false; // ???
				}

				const parsedSID = parseInt(sid, 10);
				if(isNaN(parsedSID))
					return true;

				sidBlock.valueDec = parsedSID + plus;

				flag = false;
			}
			else
			{
				const sidBlock = new LocalSidValueBlock();
        if (sid > Number.MAX_SAFE_INTEGER) {
					assertBigInt();
					const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec)) return true;  
        }

				if(this.value.length === 0)
				{
					sidBlock.isFirstSid = true;
					flag = true;
				}

				this.value.push(sidBlock);
			}
		} while(pos2 !== (-1));

		return true;
	}
	//**********************************************************************************
	/**
	 * Converts "LocalObjectIdentifierValueBlock" class to string
	 * @returns {string}
	 */
	toString()
	{
		let result = "";
		let isHexOnly = false;

		for(let i = 0; i < this.value.length; i++)
		{
			isHexOnly = this.value[i].isHexOnly;

			let sidStr = this.value[i].toString();

			if(i !== 0)
				result = `${result}.`;

			if(isHexOnly)
			{
				sidStr = `{${sidStr}}`;

				if(this.value[i].isFirstSid)
					result = `2.{${sidStr} - 80}`;
				else
					result += sidStr;
			}
			else
				result += sidStr;
		}

		return result;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "ObjectIdentifierValueBlock";
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.value = this.toString();
		object.sidArray = [];
		for(let i = 0; i < this.value.length; i++)
			object.sidArray.push(this.value[i].toJSON());

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class ObjectIdentifier extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "ObjectIdentifier" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalObjectIdentifierValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "OBJECT IDENTIFIER";
	}
	//**********************************************************************************
	toString() {
		return `${this.constructor.blockName()} : ${this.valueBlock.toString()}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of all string's classes
//**************************************************************************************
class LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Constructor for "LocalUtf8StringValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.isHexOnly = true;
		this.value = ""; // String representation of decoded ArrayBuffer
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "Utf8StringValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.value = this.value;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class Utf8String extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "Utf8String" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalUtf8StringValueBlock);

		if("value" in parameters)
			this.fromString(parameters.value);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 12; // Utf8String
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "UTF8String";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));

		try
		{
			//noinspection JSDeprecatedSymbols
			this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));
		}
		catch(ex)
		{
			this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
		}
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		//noinspection JSDeprecatedSymbols
		const str = unescape(encodeURIComponent(inputString));
		const strLen = str.length;

		this.valueBlock.valueHex = new ArrayBuffer(strLen);
		const view = new Uint8Array(this.valueBlock.valueHex);

		for(let i = 0; i < strLen; i++)
			view[i] = str.charCodeAt(i);

		this.valueBlock.value = inputString;
	}
	//**********************************************************************************
	toString() {
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
//region Declaration of ASN.1 RelativeObjectIdentifier type class
//**************************************************************************************
class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalRelativeSidValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {number} [valueDec]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.valueDec = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "valueDec", -1);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "relativeSidBlock";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		if (inputLength === 0)
			return inputOffset;

		//region Basic check for parameters
		//noinspection JSCheckFunctionSignatures
		if (Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(this, inputBuffer, inputOffset, inputLength) === false)
			return (-1);
		//endregion

		const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);

		this.valueHex = new ArrayBuffer(inputLength);
		let view = new Uint8Array(this.valueHex);

		for (let i = 0; i < inputLength; i++)
		{
			view[i] = intBuffer[i] & 0x7F;

			this.blockLength++;

			if ((intBuffer[i] & 0x80) === 0x00)
				break;
		}

		//region Ajust size of valueHex buffer
		const tempValueHex = new ArrayBuffer(this.blockLength);
		const tempView = new Uint8Array(tempValueHex);

		for (let i = 0; i < this.blockLength; i++)
			tempView[i] = view[i];

		//noinspection JSCheckFunctionSignatures
		this.valueHex = tempValueHex.slice(0);
		view = new Uint8Array(this.valueHex);
		//endregion

		if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)
		{
			this.error = "End of input reached before message was fully decoded";
			return (-1);
		}

		if (view[0] === 0x00)
			this.warnings.push("Needlessly long format of SID encoding");

		if (this.blockLength <= 8)
			this.valueDec = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilFromBase"])(view, 7);
		else
		{
			this.isHexOnly = true;
			this.warnings.push("Too big SID for decoding, hex only");
		}

		return (inputOffset + this.blockLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		//region Initial variables
		let retBuf;
		let retView;
		//endregion

		if (this.isHexOnly)
		{
			if (sizeOnly === true)
				return (new ArrayBuffer(this.valueHex.byteLength));

			const curView = new Uint8Array(this.valueHex);

			retBuf = new ArrayBuffer(this.blockLength);
			retView = new Uint8Array(retBuf);

			for (let i = 0; i < (this.blockLength - 1); i++)
				retView[i] = curView[i] | 0x80;

			retView[this.blockLength - 1] = curView[this.blockLength - 1];

			return retBuf;
		}

		const encodedBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilToBase"])(this.valueDec, 7);
		if (encodedBuf.byteLength === 0)
		{
			this.error = "Error during encoding SID value";
			return (new ArrayBuffer(0));
		}

		retBuf = new ArrayBuffer(encodedBuf.byteLength);

		if (sizeOnly === false)
		{
			const encodedView = new Uint8Array(encodedBuf);
			retView = new Uint8Array(retBuf);

			for (let i = 0; i < (encodedBuf.byteLength - 1); i++)
				retView[i] = encodedView[i] | 0x80;

			retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Create string representation of current SID block
	 * @returns {string}
	 */
	toString()
	{
		let result = "";

		if (this.isHexOnly === true)
			result = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["bufferToHexCodes"])(this.valueHex, 0, this.valueHex.byteLength);
		else {
			result = this.valueDec.toString();
		}

		return result;
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try {
			object = super.toJSON();
		} catch (ex) {}
		//endregion

		object.valueDec = this.valueDec;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
	//**********************************************************************************
	/**
	 * Constructor for "LocalRelativeObjectIdentifierValueBlock" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.fromString(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "value", ""));
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		let resultOffset = inputOffset;

		while (inputLength > 0)
		{
			const sidBlock = new LocalRelativeSidValueBlock();
			resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
			if (resultOffset === (-1))
			{
				this.blockLength = 0;
				this.error = sidBlock.error;
				return resultOffset;
			}

			this.blockLength += sidBlock.blockLength;
			inputLength -= sidBlock.blockLength;

			this.value.push(sidBlock);
		}

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		let retBuf = new ArrayBuffer(0);

		for (let i = 0; i < this.value.length; i++)
		{
			const valueBuf = this.value[i].toBER(sizeOnly);
			if (valueBuf.byteLength === 0)
			{
				this.error = this.value[i].error;
				return (new ArrayBuffer(0));
			}

			retBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilConcatBuf"])(retBuf, valueBuf);
		}

		return retBuf;
	}
	//**********************************************************************************
	/**
	 * Create "LocalRelativeObjectIdentifierValueBlock" class from string
	 * @param {string} string Input string to convert from
	 * @returns {boolean}
	 */
	fromString(string)
	{
		this.value = []; // Clear existing SID values

		let pos1 = 0;
		let pos2 = 0;

		let sid = "";

		do
		{
			pos2 = string.indexOf(".", pos1);
			if (pos2 === (-1))
				sid = string.substr(pos1);
			else
				sid = string.substr(pos1, pos2 - pos1);

			pos1 = pos2 + 1;

			const sidBlock = new LocalRelativeSidValueBlock();
			sidBlock.valueDec = parseInt(sid, 10);
			if (isNaN(sidBlock.valueDec))
				return true;

			this.value.push(sidBlock);

		} while (pos2 !== (-1));

		return true;
	}
	//**********************************************************************************
	/**
	 * Converts "LocalRelativeObjectIdentifierValueBlock" class to string
	 * @returns {string}
	 */
	toString()
	{
		let result = "";
		let isHexOnly = false;

		for (let i = 0; i < this.value.length; i++)
		{
			isHexOnly = this.value[i].isHexOnly;

			let sidStr = this.value[i].toString();

			if (i !== 0)
				result = `${result}.`;

			if (isHexOnly)
			{
				sidStr = `{${sidStr}}`;
				result += sidStr;
			} else
				result += sidStr;
		}

		return result;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "RelativeObjectIdentifierValueBlock";
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};

		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		} catch (ex) {}
		//endregion

		object.value = this.toString();
		object.sidArray = [];
		for (let i = 0; i < this.value.length; i++)
			object.sidArray.push(this.value[i].toJSON());

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class RelativeObjectIdentifier extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "RelativeObjectIdentifier" class
	 * @param {Object} [parameters={}]
	 * @property {ArrayBuffer} [valueHex]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalRelativeObjectIdentifierValueBlock);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "RelativeObjectIdentifier";
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
/**
 * @extends LocalBaseBlock
 * @extends HexBlock
 */
class LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalBmpStringValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.isHexOnly = true;
		this.value = "";
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "BmpStringValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.value = this.value;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class BmpString extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "BmpString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalBmpStringValueBlock);

		if("value" in parameters)
			this.fromString(parameters.value);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 30; // BmpString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "BMPString";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		//noinspection JSCheckFunctionSignatures
		const copyBuffer = inputBuffer.slice(0);
		const valueView = new Uint8Array(copyBuffer);

		for(let i = 0; i < valueView.length; i += 2)
		{
			const temp = valueView[i];

			valueView[i] = valueView[i + 1];
			valueView[i + 1] = temp;
		}

		this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		const strLength = inputString.length;

		this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);
		const valueHexView = new Uint8Array(this.valueBlock.valueHex);

		for(let i = 0; i < strLength; i++)
		{
			const codeBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilToBase"])(inputString.charCodeAt(i), 8);
			const codeView = new Uint8Array(codeBuf);
			if(codeView.length > 2)
				continue;

			const dif = 2 - codeView.length;

			for(let j = (codeView.length - 1); j >= 0; j--)
				valueHexView[i * 2 + j + dif] = codeView[j];
		}

		this.valueBlock.value = inputString;
	}
	//**********************************************************************************
	toString() {
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
class LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalUniversalStringValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.isHexOnly = true;
		this.value = "";
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "UniversalStringValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.value = this.value;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class UniversalString extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "UniversalString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalUniversalStringValueBlock);

		if("value" in parameters)
			this.fromString(parameters.value);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 28; // UniversalString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "UniversalString";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		//noinspection JSCheckFunctionSignatures
		const copyBuffer = inputBuffer.slice(0);
		const valueView = new Uint8Array(copyBuffer);

		for(let i = 0; i < valueView.length; i += 4)
		{
			valueView[i] = valueView[i + 3];
			valueView[i + 1] = valueView[i + 2];
			valueView[i + 2] = 0x00;
			valueView[i + 3] = 0x00;
		}

		this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		const strLength = inputString.length;

		this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);
		const valueHexView = new Uint8Array(this.valueBlock.valueHex);

		for(let i = 0; i < strLength; i++)
		{
			const codeBuf = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["utilToBase"])(inputString.charCodeAt(i), 8);
			const codeView = new Uint8Array(codeBuf);
			if(codeView.length > 4)
				continue;

			const dif = 4 - codeView.length;

			for(let j = (codeView.length - 1); j >= 0; j--)
				valueHexView[i * 4 + j + dif] = codeView[j];
		}

		this.valueBlock.value = inputString;
	}
	//**********************************************************************************
	toString() {
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
class LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock)
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalSimpleStringValueBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.value = "";
		this.isHexOnly = true;
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "SimpleStringValueBlock";
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.value = this.value;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends BaseBlock
 */
class LocalSimpleStringBlock extends BaseBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "LocalSimpleStringBlock" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters, LocalSimpleStringValueBlock);

		if("value" in parameters)
			this.fromString(parameters.value);
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "SIMPLESTRING";
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		const strLen = inputString.length;

		this.valueBlock.valueHex = new ArrayBuffer(strLen);
		const view = new Uint8Array(this.valueBlock.valueHex);

		for(let i = 0; i < strLen; i++)
			view[i] = inputString.charCodeAt(i);

		this.valueBlock.value = inputString;
	}
	//**********************************************************************************
	toString() {
		return `${this.constructor.blockName()} : ${this.valueBlock.value}`;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class NumericString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "NumericString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 18; // NumericString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "NumericString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class PrintableString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "PrintableString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 19; // PrintableString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "PrintableString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class TeletexString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "TeletexString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 20; // TeletexString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "TeletexString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class VideotexString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "VideotexString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 21; // VideotexString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "VideotexString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class IA5String extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "IA5String" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 22; // IA5String
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "IA5String";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class GraphicString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "GraphicString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 25; // GraphicString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "GraphicString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class VisibleString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "VisibleString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 26; // VisibleString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "VisibleString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class GeneralString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "GeneralString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 27; // GeneralString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "GeneralString";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends LocalSimpleStringBlock
 */
class CharacterString extends LocalSimpleStringBlock
{
	//**********************************************************************************
	/**
	 * Constructor for "CharacterString" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 29; // CharacterString
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "CharacterString";
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of all date and time classes
//**************************************************************************************
/**
 * @extends VisibleString
 */
class UTCTime extends VisibleString
{
	//**********************************************************************************
	/**
	 * Constructor for "UTCTime" class
	 * @param {Object} [parameters={}]
	 * @property {string} [value] String representatio of the date
	 * @property {Date} [valueDate] JavaScript "Date" object
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.year = 0;
		this.month = 0;
		this.day = 0;
		this.hour = 0;
		this.minute = 0;
		this.second = 0;

		//region Create UTCTime from ASN.1 UTC string value
		if("value" in parameters)
		{
			this.fromString(parameters.value);

			this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < parameters.value.length; i++)
				view[i] = parameters.value.charCodeAt(i);
		}
		//endregion
		//region Create GeneralizedTime from JavaScript Date type
		if("valueDate" in parameters)
		{
			this.fromDate(parameters.valueDate);
			this.valueBlock.valueHex = this.toBuffer();
		}
		//endregion

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 23; // UTCTime
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
	}
	//**********************************************************************************
	/**
	 * Function converting ASN.1 internal string into ArrayBuffer
	 * @returns {ArrayBuffer}
	 */
	toBuffer()
	{
		const str = this.toString();

		const buffer = new ArrayBuffer(str.length);
		const view = new Uint8Array(buffer);

		for(let i = 0; i < str.length; i++)
			view[i] = str.charCodeAt(i);

		return buffer;
	}
	//**********************************************************************************
	/**
	 * Function converting "Date" object into ASN.1 internal string
	 * @param {!Date} inputDate JavaScript "Date" object
	 */
	fromDate(inputDate)
	{
		this.year = inputDate.getUTCFullYear();
		this.month = inputDate.getUTCMonth() + 1;
		this.day = inputDate.getUTCDate();
		this.hour = inputDate.getUTCHours();
		this.minute = inputDate.getUTCMinutes();
		this.second = inputDate.getUTCSeconds();
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Function converting ASN.1 internal string into "Date" object
	 * @returns {Date}
	 */
	toDate()
	{
		return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		//region Parse input string
		const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
		const parserArray = parser.exec(inputString);
		if(parserArray === null)
		{
			this.error = "Wrong input string for convertion";
			return;
		}
		//endregion

		//region Store parsed values
		const year = parseInt(parserArray[1], 10);
		if(year >= 50)
			this.year = 1900 + year;
		else
			this.year = 2000 + year;

		this.month = parseInt(parserArray[2], 10);
		this.day = parseInt(parserArray[3], 10);
		this.hour = parseInt(parserArray[4], 10);
		this.minute = parseInt(parserArray[5], 10);
		this.second = parseInt(parserArray[6], 10);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Function converting ASN.1 internal class into JavaScript string
	 * @returns {string}
	 */
	toString()
	{
		const outputArray = new Array(7);

		outputArray[0] = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);
		outputArray[1] = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.month, 2);
		outputArray[2] = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.day, 2);
		outputArray[3] = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.hour, 2);
		outputArray[4] = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.minute, 2);
		outputArray[5] = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.second, 2);
		outputArray[6] = "Z";

		return outputArray.join("");
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "UTCTime";
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.year = this.year;
		object.month = this.month;
		object.day = this.day;
		object.hour = this.hour;
		object.minute = this.minute;
		object.second = this.second;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends VisibleString
 */
class GeneralizedTime extends VisibleString
{
	//**********************************************************************************
	/**
	 * Constructor for "GeneralizedTime" class
	 * @param {Object} [parameters={}]
	 * @property {string} [value] String representatio of the date
	 * @property {Date} [valueDate] JavaScript "Date" object
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.year = 0;
		this.month = 0;
		this.day = 0;
		this.hour = 0;
		this.minute = 0;
		this.second = 0;
		this.millisecond = 0;

		//region Create UTCTime from ASN.1 UTC string value
		if("value" in parameters)
		{
			this.fromString(parameters.value);

			this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);
			const view = new Uint8Array(this.valueBlock.valueHex);

			for(let i = 0; i < parameters.value.length; i++)
				view[i] = parameters.value.charCodeAt(i);
		}
		//endregion
		//region Create GeneralizedTime from JavaScript Date type
		if("valueDate" in parameters)
		{
			this.fromDate(parameters.valueDate);
			this.valueBlock.valueHex = this.toBuffer();
		}
		//endregion

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 24; // GeneralizedTime
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);
		if(resultOffset === (-1))
		{
			this.error = this.valueBlock.error;
			return resultOffset;
		}

		this.fromBuffer(this.valueBlock.valueHex);

		if(this.idBlock.error.length === 0)
			this.blockLength += this.idBlock.blockLength;

		if(this.lenBlock.error.length === 0)
			this.blockLength += this.lenBlock.blockLength;

		if(this.valueBlock.error.length === 0)
			this.blockLength += this.valueBlock.blockLength;

		return resultOffset;
	}
	//**********************************************************************************
	/**
	 * Function converting ArrayBuffer into ASN.1 internal string
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 */
	fromBuffer(inputBuffer)
	{
		this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));
	}
	//**********************************************************************************
	/**
	 * Function converting ASN.1 internal string into ArrayBuffer
	 * @returns {ArrayBuffer}
	 */
	toBuffer()
	{
		const str = this.toString();

		const buffer = new ArrayBuffer(str.length);
		const view = new Uint8Array(buffer);

		for(let i = 0; i < str.length; i++)
			view[i] = str.charCodeAt(i);

		return buffer;
	}
	//**********************************************************************************
	/**
	 * Function converting "Date" object into ASN.1 internal string
	 * @param {!Date} inputDate JavaScript "Date" object
	 */
	fromDate(inputDate)
	{
		this.year = inputDate.getUTCFullYear();
		this.month = inputDate.getUTCMonth() + 1;
		this.day = inputDate.getUTCDate();
		this.hour = inputDate.getUTCHours();
		this.minute = inputDate.getUTCMinutes();
		this.second = inputDate.getUTCSeconds();
		this.millisecond = inputDate.getUTCMilliseconds();
	}
	//**********************************************************************************
	//noinspection JSUnusedGlobalSymbols
	/**
	 * Function converting ASN.1 internal string into "Date" object
	 * @returns {Date}
	 */
	toDate()
	{
		return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));
	}
	//**********************************************************************************
	/**
	 * Function converting JavaScript string into ASN.1 internal class
	 * @param {!string} inputString ASN.1 BER encoded array
	 */
	fromString(inputString)
	{
		//region Initial variables
		let isUTC = false;

		let timeString = "";
		let dateTimeString = "";
		let fractionPart = 0;

		let parser;

		let hourDifference = 0;
		let minuteDifference = 0;
		//endregion

		//region Convert as UTC time
		if(inputString[inputString.length - 1] === "Z")
		{
			timeString = inputString.substr(0, inputString.length - 1);

			isUTC = true;
		}
		//endregion
		//region Convert as local time
		else
		{
			//noinspection JSPrimitiveTypeWrapperUsage
			const number = new Number(inputString[inputString.length - 1]);

			if(isNaN(number.valueOf()))
				throw new Error("Wrong input string for convertion");

			timeString = inputString;
		}
		//endregion

		//region Check that we do not have a "+" and "-" symbols inside UTC time
		if(isUTC)
		{
			if(timeString.indexOf("+") !== (-1))
				throw new Error("Wrong input string for convertion");

			if(timeString.indexOf("-") !== (-1))
				throw new Error("Wrong input string for convertion");
		}
		//endregion
		//region Get "UTC time difference" in case of local time
		else
		{
			let multiplier = 1;
			let differencePosition = timeString.indexOf("+");
			let differenceString = "";

			if(differencePosition === (-1))
			{
				differencePosition = timeString.indexOf("-");
				multiplier = (-1);
			}

			if(differencePosition !== (-1))
			{
				differenceString = timeString.substr(differencePosition + 1);
				timeString = timeString.substr(0, differencePosition);

				if((differenceString.length !== 2) && (differenceString.length !== 4))
					throw new Error("Wrong input string for convertion");

				//noinspection JSPrimitiveTypeWrapperUsage
				let number = new Number(differenceString.substr(0, 2));

				if(isNaN(number.valueOf()))
					throw new Error("Wrong input string for convertion");

				hourDifference = multiplier * number;

				if(differenceString.length === 4)
				{
					//noinspection JSPrimitiveTypeWrapperUsage
					number = new Number(differenceString.substr(2, 2));

					if(isNaN(number.valueOf()))
						throw new Error("Wrong input string for convertion");

					minuteDifference = multiplier * number;
				}
			}
		}
		//endregion

		//region Get position of fraction point
		let fractionPointPosition = timeString.indexOf("."); // Check for "full stop" symbol
		if(fractionPointPosition === (-1))
			fractionPointPosition = timeString.indexOf(","); // Check for "comma" symbol
		//endregion

		//region Get fraction part
		if(fractionPointPosition !== (-1))
		{
			//noinspection JSPrimitiveTypeWrapperUsage
			const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);

			if(isNaN(fractionPartCheck.valueOf()))
				throw new Error("Wrong input string for convertion");

			fractionPart = fractionPartCheck.valueOf();

			dateTimeString = timeString.substr(0, fractionPointPosition);
		}
		else
			dateTimeString = timeString;
		//endregion

		//region Parse internal date
		switch(true)
		{
			case (dateTimeString.length === 8): // "YYYYMMDD"
				parser = /(\d{4})(\d{2})(\d{2})/ig;
				if(fractionPointPosition !== (-1))
					throw new Error("Wrong input string for convertion"); // Here we should not have a "fraction point"
				break;
			case (dateTimeString.length === 10): // "YYYYMMDDHH"
				parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;

				if(fractionPointPosition !== (-1))
				{
					let fractionResult = 60 * fractionPart;
					this.minute = Math.floor(fractionResult);

					fractionResult = 60 * (fractionResult - this.minute);
					this.second = Math.floor(fractionResult);

					fractionResult = 1000 * (fractionResult - this.second);
					this.millisecond = Math.floor(fractionResult);
				}
				break;
			case (dateTimeString.length === 12): // "YYYYMMDDHHMM"
				parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

				if(fractionPointPosition !== (-1))
				{
					let fractionResult = 60 * fractionPart;
					this.second = Math.floor(fractionResult);

					fractionResult = 1000 * (fractionResult - this.second);
					this.millisecond = Math.floor(fractionResult);
				}
				break;
			case (dateTimeString.length === 14): // "YYYYMMDDHHMMSS"
				parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;

				if(fractionPointPosition !== (-1))
				{
					const fractionResult = 1000 * fractionPart;
					this.millisecond = Math.floor(fractionResult);
				}
				break;
			default:
				throw new Error("Wrong input string for convertion");
		}
		//endregion

		//region Put parsed values at right places
		const parserArray = parser.exec(dateTimeString);
		if(parserArray === null)
			throw new Error("Wrong input string for convertion");

		for(let j = 1; j < parserArray.length; j++)
		{
			switch(j)
			{
				case 1:
					this.year = parseInt(parserArray[j], 10);
					break;
				case 2:
					this.month = parseInt(parserArray[j], 10);
					break;
				case 3:
					this.day = parseInt(parserArray[j], 10);
					break;
				case 4:
					this.hour = parseInt(parserArray[j], 10) + hourDifference;
					break;
				case 5:
					this.minute = parseInt(parserArray[j], 10) + minuteDifference;
					break;
				case 6:
					this.second = parseInt(parserArray[j], 10);
					break;
				default:
					throw new Error("Wrong input string for convertion");
			}
		}
		//endregion

		//region Get final date
		if(isUTC === false)
		{
			const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);

			this.year = tempDate.getUTCFullYear();
			this.month = tempDate.getUTCMonth();
			this.day = tempDate.getUTCDay();
			this.hour = tempDate.getUTCHours();
			this.minute = tempDate.getUTCMinutes();
			this.second = tempDate.getUTCSeconds();
			this.millisecond = tempDate.getUTCMilliseconds();
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Function converting ASN.1 internal class into JavaScript string
	 * @returns {string}
	 */
	toString()
	{
		const outputArray = [];

		outputArray.push(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.year, 4));
		outputArray.push(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.month, 2));
		outputArray.push(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.day, 2));
		outputArray.push(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.hour, 2));
		outputArray.push(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.minute, 2));
		outputArray.push(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.second, 2));
		if(this.millisecond !== 0)
		{
			outputArray.push(".");
			outputArray.push(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["padNumber"])(this.millisecond, 3));
		}
		outputArray.push("Z");

		return outputArray.join("");
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "GeneralizedTime";
	}
	//**********************************************************************************
	/**
	 * Convertion for the block to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		let object = {};
		
		//region Seems at the moment (Sep 2016) there is no way how to check method is supported in "super" object
		try
		{
			object = super.toJSON();
		}
		catch(ex){}
		//endregion

		object.year = this.year;
		object.month = this.month;
		object.day = this.day;
		object.hour = this.hour;
		object.minute = this.minute;
		object.second = this.second;
		object.millisecond = this.millisecond;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class DATE extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "DATE" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 31; // DATE
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "DATE";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class TimeOfDay extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "TimeOfDay" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 32; // TimeOfDay
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "TimeOfDay";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class DateTime extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "DateTime" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 33; // DateTime
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "DateTime";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class Duration extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "Duration" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 34; // Duration
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "Duration";
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * @extends Utf8String
 */
class TIME extends Utf8String
{
	//**********************************************************************************
	/**
	 * Constructor for "Time" class
	 * @param {Object} [parameters={}]
	 */
	constructor(parameters = {})
	{
		super(parameters);

		this.idBlock.tagClass = 1; // UNIVERSAL
		this.idBlock.tagNumber = 14; // Time
	}
	//**********************************************************************************
	/**
	 * Aux function, need to get a block name. Need to have it here for inhiritence
	 * @returns {string}
	 */
	static blockName()
	{
		return "TIME";
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of special ASN.1 schema type Choice
//**************************************************************************************
class Choice
{
	//**********************************************************************************
	/**
	 * Constructor for "Choice" class
	 * @param {Object} [parameters={}]
	 * @property {Array} [value] Array of ASN.1 types for make a choice from
	 * @property {boolean} [optional]
	 */
	constructor(parameters = {})
	{
		this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "value", []);
		this.optional = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "optional", false);
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of special ASN.1 schema type Any
//**************************************************************************************
class Any
{
	//**********************************************************************************
	/**
	 * Constructor for "Any" class
	 * @param {Object} [parameters={}]
	 * @property {string} [name]
	 * @property {boolean} [optional]
	 */
	constructor(parameters = {})
	{
		this.name = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "name", "");
		this.optional = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "optional", false);
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of special ASN.1 schema type Repeated
//**************************************************************************************
class Repeated
{
	//**********************************************************************************
	/**
	 * Constructor for "Repeated" class
	 * @param {Object} [parameters={}]
	 * @property {string} [name]
	 * @property {boolean} [optional]
	 */
	constructor(parameters = {})
	{
		this.name = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "name", "");
		this.optional = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "optional", false);
		this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "value", new Any());
		this.local = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "local", false); // Could local or global array to store elements
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of special ASN.1 schema type RawData
//**************************************************************************************
/**
 * @description Special class providing ability to have "toBER/fromBER" for raw ArrayBuffer
 */
class RawData
{
	//**********************************************************************************
	/**
	 * Constructor for "Repeated" class
	 * @param {Object} [parameters={}]
	 * @property {string} [name]
	 * @property {boolean} [optional]
	 */
	constructor(parameters = {})
	{
		this.data = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "data", new ArrayBuffer(0));
	}
	//**********************************************************************************
	/**
	 * Base function for converting block from BER encoded array of bytes
	 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
	 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
	 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
	 * @returns {number} Offset after least decoded byte
	 */
	fromBER(inputBuffer, inputOffset, inputLength)
	{
		this.data = inputBuffer.slice(inputOffset, inputLength);
		return (inputOffset + inputLength);
	}
	//**********************************************************************************
	/**
	 * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)
	 * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes
	 * @returns {ArrayBuffer}
	 */
	toBER(sizeOnly = false)
	{
		return this.data;
	}
	//**********************************************************************************
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Major ASN.1 BER decoding function
//**************************************************************************************
/**
 * Internal library function for decoding ASN.1 BER
 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array
 * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started
 * @param {!number} inputLength Maximum length of array of bytes which can be using in this function
 * @returns {{offset: number, result: Object}}
 */
function LocalFromBER(inputBuffer, inputOffset, inputLength)
{
	const incomingOffset = inputOffset; // Need to store initial offset since "inputOffset" is changing in the function

	//region Local function changing a type for ASN.1 classes
	function localChangeType(inputObject, newType)
	{
		if(inputObject instanceof newType)
			return inputObject;

		const newObject = new newType();
		newObject.idBlock = inputObject.idBlock;
		newObject.lenBlock = inputObject.lenBlock;
		newObject.warnings = inputObject.warnings;
		//noinspection JSCheckFunctionSignatures
		newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);

		return newObject;
	}
	//endregion

	//region Create a basic ASN.1 type since we need to return errors and warnings from the function
	let returnObject = new BaseBlock({}, Object);
	//endregion

	//region Basic check for parameters
	const baseBlock = new LocalBaseBlock();
	if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["checkBufferParams"])(baseBlock, inputBuffer, inputOffset, inputLength) === false)
	{
		returnObject.error = baseBlock.error;
		return {
			offset: (-1),
			result: returnObject
		};
	}
	//endregion

	//region Getting Uint8Array from ArrayBuffer
	const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);
	//endregion

	//region Initial checks
	if(intBuffer.length === 0)
	{
		returnObject.error = "Zero buffer length";
		return {
			offset: (-1),
			result: returnObject
		};
	}
	//endregion

	//region Decode indentifcation block of ASN.1 BER structure
	let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
	returnObject.warnings.concat(returnObject.idBlock.warnings);
	if(resultOffset === (-1))
	{
		returnObject.error = returnObject.idBlock.error;
		return {
			offset: (-1),
			result: returnObject
		};
	}

	inputOffset = resultOffset;
	inputLength -= returnObject.idBlock.blockLength;
	//endregion

	//region Decode length block of ASN.1 BER structure
	resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
	returnObject.warnings.concat(returnObject.lenBlock.warnings);
	if(resultOffset === (-1))
	{
		returnObject.error = returnObject.lenBlock.error;
		return {
			offset: (-1),
			result: returnObject
		};
	}

	inputOffset = resultOffset;
	inputLength -= returnObject.lenBlock.blockLength;
	//endregion

	//region Check for usign indefinite length form in encoding for primitive types
	if((returnObject.idBlock.isConstructed === false) &&
		(returnObject.lenBlock.isIndefiniteForm === true))
	{
		returnObject.error = "Indefinite length form used for primitive encoding form";
		return {
			offset: (-1),
			result: returnObject
		};
	}
	//endregion

	//region Switch ASN.1 block type
	let newASN1Type = BaseBlock;

	switch(returnObject.idBlock.tagClass)
	{
		//region UNIVERSAL
		case 1:
			//region Check for reserved tag numbers
			if((returnObject.idBlock.tagNumber >= 37) &&
				(returnObject.idBlock.isHexOnly === false))
			{
				returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
				return {
					offset: (-1),
					result: returnObject
				};
			}
			//endregion

			switch(returnObject.idBlock.tagNumber)
			{
				//region EndOfContent type
				case 0:
					//region Check for EndOfContent type
					if((returnObject.idBlock.isConstructed === true) &&
						(returnObject.lenBlock.length > 0))
					{
						returnObject.error = "Type [UNIVERSAL 0] is reserved";
						return {
							offset: (-1),
							result: returnObject
						};
					}
					//endregion

					newASN1Type = EndOfContent;

					break;
				//endregion
				//region Boolean type
				case 1:
					newASN1Type = Boolean;
					break;
				//endregion
				//region Integer type
				case 2:
					newASN1Type = Integer;
					break;
				//endregion
				//region BitString type
				case 3:
					newASN1Type = BitString;
					break;
				//endregion
				//region OctetString type
				case 4:
					newASN1Type = OctetString;
					break;
				//endregion
				//region Null type
				case 5:
					newASN1Type = Null;
					break;
				//endregion
				//region OBJECT IDENTIFIER type
				case 6:
					newASN1Type = ObjectIdentifier;
					break;
				//endregion
				//region Enumerated type
				case 10:
					newASN1Type = Enumerated;
					break;
				//endregion
				//region Utf8String type
				case 12:
					newASN1Type = Utf8String;
					break;
				//endregion
				//region Time type
				//region RELATIVE OBJECT IDENTIFIER type
				case 13:
					newASN1Type = RelativeObjectIdentifier;
					break;
				//endregion
				case 14:
					newASN1Type = TIME;
					break;
				//endregion
				//region ASN.1 reserved type
				case 15:
					returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
					return {
						offset: (-1),
						result: returnObject
					};
				//endregion
				//region Sequence type
				case 16:
					newASN1Type = Sequence;
					break;
				//endregion
				//region Set type
				case 17:
					newASN1Type = Set;
					break;
				//endregion
				//region NumericString type
				case 18:
					newASN1Type = NumericString;
					break;
				//endregion
				//region PrintableString type
				case 19:
					newASN1Type = PrintableString;
					break;
				//endregion
				//region TeletexString type
				case 20:
					newASN1Type = TeletexString;
					break;
				//endregion
				//region VideotexString type
				case 21:
					newASN1Type = VideotexString;
					break;
				//endregion
				//region IA5String type
				case 22:
					newASN1Type = IA5String;
					break;
				//endregion
				//region UTCTime type
				case 23:
					newASN1Type = UTCTime;
					break;
				//endregion
				//region GeneralizedTime type
				case 24:
					newASN1Type = GeneralizedTime;
					break;
				//endregion
				//region GraphicString type
				case 25:
					newASN1Type = GraphicString;
					break;
				//endregion
				//region VisibleString type
				case 26:
					newASN1Type = VisibleString;
					break;
				//endregion
				//region GeneralString type
				case 27:
					newASN1Type = GeneralString;
					break;
				//endregion
				//region UniversalString type
				case 28:
					newASN1Type = UniversalString;
					break;
				//endregion
				//region CharacterString type
				case 29:
					newASN1Type = CharacterString;
					break;
				//endregion
				//region BmpString type
				case 30:
					newASN1Type = BmpString;
					break;
				//endregion
				//region DATE type
				case 31:
					newASN1Type = DATE;
					break;
				//endregion
				//region TimeOfDay type
				case 32:
					newASN1Type = TimeOfDay;
					break;
				//endregion
				//region Date-Time type
				case 33:
					newASN1Type = DateTime;
					break;
				//endregion
				//region Duration type
				case 34:
					newASN1Type = Duration;
					break;
				//endregion
				//region default
				default:
					{
						let newObject;

						if(returnObject.idBlock.isConstructed === true)
							newObject = new Constructed();
						else
							newObject = new Primitive();

						newObject.idBlock = returnObject.idBlock;
						newObject.lenBlock = returnObject.lenBlock;
						newObject.warnings = returnObject.warnings;

						returnObject = newObject;
					}
				//endregion
			}
			break;
		//endregion
		//region All other tag classes
		case 2: // APPLICATION
		case 3: // CONTEXT-SPECIFIC
		case 4: // PRIVATE
		default:
			{
				if(returnObject.idBlock.isConstructed === true)
					newASN1Type = Constructed;
				else
					newASN1Type = Primitive;
			}
		//endregion
	}
	//endregion

	//region Change type and perform BER decoding
	returnObject = localChangeType(returnObject, newASN1Type);
	resultOffset = returnObject.fromBER(inputBuffer, inputOffset, (returnObject.lenBlock.isIndefiniteForm === true) ? inputLength : returnObject.lenBlock.length);
	//endregion

	//region Coping incoming buffer for entire ASN.1 block
	returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);
	//endregion

	return {
		offset: resultOffset,
		result: returnObject
	};
}
//**************************************************************************************
/**
 * Major function for decoding ASN.1 BER array into internal library structuries
 * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes
 */
function fromBER(inputBuffer)
{
	if(inputBuffer.byteLength === 0)
	{
		const result = new BaseBlock({}, Object);
		result.error = "Input buffer has zero length";

		return {
			offset: (-1),
			result
		};
	}

	return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Major scheme verification function
//**************************************************************************************
/**
 * Compare of two ASN.1 object trees
 * @param {!Object} root Root of input ASN.1 object tree
 * @param {!Object} inputData Input ASN.1 object tree
 * @param {!Object} inputSchema Input ASN.1 schema to compare with
 * @return {{verified: boolean}|{verified:boolean, result: Object}}
 */
function compareSchema(root, inputData, inputSchema)
{
	//region Special case for Choice schema element type
	if(inputSchema instanceof Choice)
	{
		const choiceResult = false;

		for(let j = 0; j < inputSchema.value.length; j++)
		{
			const result = compareSchema(root, inputData, inputSchema.value[j]);
			if(result.verified === true)
			{
				return {
					verified: true,
					result: root
				};
			}
		}

		if(choiceResult === false)
		{
			const _result = {
				verified: false,
				result: {
					error: "Wrong values for Choice type"
				}
			};

			if(inputSchema.hasOwnProperty("name"))
				_result.name = inputSchema.name;

			return _result;
		}
	}
	//endregion

	//region Special case for Any schema element type
	if(inputSchema instanceof Any)
	{
		//region Add named component of ASN.1 schema
		if(inputSchema.hasOwnProperty("name"))
			root[inputSchema.name] = inputData;
		//endregion

		return {
			verified: true,
			result: root
		};
	}
	//endregion

	//region Initial check
	if((root instanceof Object) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong root object" }
		};
	}

	if((inputData instanceof Object) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 data" }
		};
	}

	if((inputSchema instanceof Object) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(("idBlock" in inputSchema) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}
	//endregion

	//region Comparing idBlock properties in ASN.1 data and ASN.1 schema
	//region Encode and decode ASN.1 schema idBlock
	/// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>
	if(("fromBER" in inputSchema.idBlock) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(("toBER" in inputSchema.idBlock) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	const encodedId = inputSchema.idBlock.toBER(false);
	if(encodedId.byteLength === 0)
	{
		return {
			verified: false,
			result: { error: "Error encoding idBlock for ASN.1 schema" }
		};
	}

	const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
	if(decodedOffset === (-1))
	{
		return {
			verified: false,
			result: { error: "Error decoding idBlock for ASN.1 schema" }
		};
	}
	//endregion

	//region tagClass
	if(inputSchema.idBlock.hasOwnProperty("tagClass") === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass)
	{
		return {
			verified: false,
			result: root
		};
	}
	//endregion
	//region tagNumber
	if(inputSchema.idBlock.hasOwnProperty("tagNumber") === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber)
	{
		return {
			verified: false,
			result: root
		};
	}
	//endregion
	//region isConstructed
	if(inputSchema.idBlock.hasOwnProperty("isConstructed") === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed)
	{
		return {
			verified: false,
			result: root
		};
	}
	//endregion
	//region isHexOnly
	if(("isHexOnly" in inputSchema.idBlock) === false) // Since 'isHexOnly' is an inhirited property
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema" }
		};
	}

	if(inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly)
	{
		return {
			verified: false,
			result: root
		};
	}
	//endregion
	//region valueHex
	if(inputSchema.idBlock.isHexOnly === true)
	{
		if(("valueHex" in inputSchema.idBlock) === false) // Since 'valueHex' is an inhirited property
		{
			return {
				verified: false,
				result: { error: "Wrong ASN.1 schema" }
			};
		}

		const schemaView = new Uint8Array(inputSchema.idBlock.valueHex);
		const asn1View = new Uint8Array(inputData.idBlock.valueHex);

		if(schemaView.length !== asn1View.length)
		{
			return {
				verified: false,
				result: root
			};
		}

		for(let i = 0; i < schemaView.length; i++)
		{
			if(schemaView[i] !== asn1View[1])
			{
				return {
					verified: false,
					result: root
				};
			}
		}
	}
	//endregion
	//endregion

	//region Add named component of ASN.1 schema
	if(inputSchema.hasOwnProperty("name"))
	{
		inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
		if(inputSchema.name !== "")
			root[inputSchema.name] = inputData;
	}
	//endregion

	//region Getting next ASN.1 block for comparition
	if(inputSchema.idBlock.isConstructed === true)
	{
		let admission = 0;
		let result = { verified: false };

		let maxLength = inputSchema.valueBlock.value.length;

		if(maxLength > 0)
		{
			if(inputSchema.valueBlock.value[0] instanceof Repeated)
				maxLength = inputData.valueBlock.value.length;
		}

		//region Special case when constructive value has no elements
		if(maxLength === 0)
		{
			return {
				verified: true,
				result: root
			};
		}
		//endregion

		//region Special case when "inputData" has no values and "inputSchema" has all optional values
		if((inputData.valueBlock.value.length === 0) &&
			(inputSchema.valueBlock.value.length !== 0))
		{
			let _optional = true;

			for(let i = 0; i < inputSchema.valueBlock.value.length; i++)
				_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);

			if(_optional === true)
			{
				return {
					verified: true,
					result: root
				};
			}

			//region Delete early added name of block
			if(inputSchema.hasOwnProperty("name"))
			{
				inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
				if(inputSchema.name !== "")
					delete root[inputSchema.name];
			}
			//endregion

			root.error = "Inconsistent object length";

			return {
				verified: false,
				result: root
			};
		}
		//endregion

		for(let i = 0; i < maxLength; i++)
		{
			//region Special case when there is an "optional" element of ASN.1 schema at the end
			if((i - admission) >= inputData.valueBlock.value.length)
			{
				if(inputSchema.valueBlock.value[i].optional === false)
				{
					const _result = {
						verified: false,
						result: root
					};

					root.error = "Inconsistent length between ASN.1 data and schema";

					//region Delete early added name of block
					if(inputSchema.hasOwnProperty("name"))
					{
						inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
						if(inputSchema.name !== "")
						{
							delete root[inputSchema.name];
							_result.name = inputSchema.name;
						}
					}
					//endregion

					return _result;
				}
			}
			//endregion
			else
			{
				//region Special case for Repeated type of ASN.1 schema element
				if(inputSchema.valueBlock.value[0] instanceof Repeated)
				{
					result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
					if(result.verified === false)
					{
						if(inputSchema.valueBlock.value[0].optional === true)
							admission++;
						else
						{
							//region Delete early added name of block
							if(inputSchema.hasOwnProperty("name"))
							{
								inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
								if(inputSchema.name !== "")
									delete root[inputSchema.name];
							}
							//endregion

							return result;
						}
					}

					if(("name" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0))
					{
						let arrayRoot = {};

						if(("local" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local === true))
							arrayRoot = inputData;
						else
							arrayRoot = root;

						if(typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
							arrayRoot[inputSchema.valueBlock.value[0].name] = [];

						arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
					}
				}
				//endregion
				else
				{
					result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
					if(result.verified === false)
					{
						if(inputSchema.valueBlock.value[i].optional === true)
							admission++;
						else
						{
							//region Delete early added name of block
							if(inputSchema.hasOwnProperty("name"))
							{
								inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
								if(inputSchema.name !== "")
									delete root[inputSchema.name];
							}
							//endregion

							return result;
						}
					}
				}
			}
		}

		if(result.verified === false) // The situation may take place if last element is "optional" and verification failed
		{
			const _result = {
				verified: false,
				result: root
			};

			//region Delete early added name of block
			if(inputSchema.hasOwnProperty("name"))
			{
				inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
				if(inputSchema.name !== "")
				{
					delete root[inputSchema.name];
					_result.name = inputSchema.name;
				}
			}
			//endregion

			return _result;
		}

		return {
			verified: true,
			result: root
		};
	}
	//endregion
	//region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)
	if(("primitiveSchema" in inputSchema) &&
		("valueHex" in inputData.valueBlock))
	{
		//region Decoding of raw ASN.1 data
		const asn1 = fromBER(inputData.valueBlock.valueHex);
		if(asn1.offset === (-1))
		{
			const _result = {
				verified: false,
				result: asn1.result
			};

			//region Delete early added name of block
			if(inputSchema.hasOwnProperty("name"))
			{
				inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, "");
				if(inputSchema.name !== "")
				{
					delete root[inputSchema.name];
					_result.name = inputSchema.name;
				}
			}
			//endregion

			return _result;
		}
		//endregion

		return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
	}

	return {
		verified: true,
		result: root
	};
	//endregion
}
//**************************************************************************************
//noinspection JSUnusedGlobalSymbols
/**
 * ASN.1 schema verification for ArrayBuffer data
 * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data
 * @param {!Object} inputSchema Input ASN.1 schema to verify against to
 * @return {{verified: boolean}|{verified:boolean, result: Object}}
 */
function verifySchema(inputBuffer, inputSchema)
{
	//region Initial check
	if((inputSchema instanceof Object) === false)
	{
		return {
			verified: false,
			result: { error: "Wrong ASN.1 schema type" }
		};
	}
	//endregion

	//region Decoding of raw ASN.1 data
	const asn1 = fromBER(inputBuffer);
	if(asn1.offset === (-1))
	{
		return {
			verified: false,
			result: asn1.result
		};
	}
	//endregion

	//region Compare ASN.1 struct with input schema
	return compareSchema(asn1.result, asn1.result, inputSchema);
	//endregion
}
//**************************************************************************************
//endregion
//**************************************************************************************
//region Major function converting JSON to ASN.1 objects
//**************************************************************************************
//noinspection JSUnusedGlobalSymbols
/**
 * Converting from JSON to ASN.1 objects
 * @param {string|Object} json JSON string or object to convert to ASN.1 objects
 */
function fromJSON(json)
{
	// TODO Implement
}
//**************************************************************************************
//endregion
//**************************************************************************************


/***/ }),

/***/ "./node_modules/bytestreamjs/src/bytestream.js":
/*!*****************************************************!*\
  !*** ./node_modules/bytestreamjs/src/bytestream.js ***!
  \*****************************************************/
/*! exports provided: ByteStream, SeqStream, parseByteMap, BitStream, SeqBitStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteStream", function() { return ByteStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SeqStream", function() { return SeqStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseByteMap", function() { return parseByteMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BitStream", function() { return BitStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SeqBitStream", function() { return SeqBitStream; });
/*
 * Copyright (c) 2016-2018, Peculiar Ventures
 * All rights reserved.
 *
 * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.
 *
 */
//**************************************************************************************
class ByteStream
{
	//**********************************************************************************
	// noinspection FunctionWithMultipleLoopsJS
	/**
	 * Constructor for ByteStream class
	 * @param {{[length]: number, [stub]: number, [view]: Uint8Array, [buffer]: ArrayBuffer, [string]: string, [hexstring]: string}} parameters
	 */
	constructor(parameters = {})
	{
		this.clear();
		
		for(const key of Object.keys(parameters))
		{
			switch(key)
			{
				case "length":
					this.length = parameters.length;
					break;
				case "stub":
					// noinspection NonBlockStatementBodyJS
					for(let i = 0; i < this._view.length; i++)
						this._view[i] = parameters.stub;
					break;
				case "view":
					this.fromUint8Array(parameters.view);
					break;
				case "buffer":
					this.fromArrayBuffer(parameters.buffer);
					break;
				case "string":
					this.fromString(parameters.string);
					break;
				case "hexstring":
					this.fromHexString(parameters.hexstring);
					break;
				default:
			}
		}
	}
	//**********************************************************************************
	/**
	 * Setter for "buffer"
	 * @param {ArrayBuffer} value
	 */
	set buffer(value)
	{
		this._buffer = value.slice(0);
		this._view = new Uint8Array(this._buffer);
	}
	//**********************************************************************************
	/**
	 * Getter for "buffer"
	 * @returns {ArrayBuffer}
	 */
	get buffer()
	{
		return this._buffer;
	}
	//**********************************************************************************
	/**
	 * Setter for "view"
	 * @param {Uint8Array} value
	 */
	set view(value)
	{
		this._buffer = new ArrayBuffer(value.length);
		this._view = new Uint8Array(this._buffer);
		
		this._view.set(value);
	}
	//**********************************************************************************
	/**
	 * Getter for "view"
	 * @returns {Uint8Array}
	 */
	get view()
	{
		return this._view;
	}
	//**********************************************************************************
	/**
	 * Getter for "length"
	 * @returns {number}
	 */
	get length()
	{
		return this._buffer.byteLength;
	}
	//**********************************************************************************
	/**
	 * Setter for "length"
	 * @param {number} value
	 */
	set length(value)
	{
		this._buffer = new ArrayBuffer(value);
		this._view = new Uint8Array(this._buffer);
	}
	//**********************************************************************************
	/**
	 * Clear existing stream
	 */
	clear()
	{
		this._buffer = new ArrayBuffer(0);
		this._view = new Uint8Array(this._buffer);
	}
	//**********************************************************************************
	/**
	 * Initialize "Stream" object from existing "ArrayBuffer"
	 * @param {!ArrayBuffer} array The ArrayBuffer to copy from
	 */
	fromArrayBuffer(array)
	{
		this.buffer = array;
	}
	//**********************************************************************************
	// noinspection FunctionNamingConventionJS
	/**
	 * Initialize "Stream" object from existing "Uint8Array"
	 * @param {!Uint8Array} array The Uint8Array to copy from
	 */
	fromUint8Array(array)
	{
		this._buffer = new ArrayBuffer(array.length);
		this._view = new Uint8Array(this._buffer);
		
		this._view.set(array);
	}
	//**********************************************************************************
	/**
	 * Initialize "Stream" object from existing string
	 * @param {string} string The string to initialize from
	 */
	fromString(string)
	{
		const stringLength = string.length;
		
		this.length = stringLength;
		
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < stringLength; i++)
			this.view[i] = string.charCodeAt(i);
	}
	//**********************************************************************************
	/**
	 * Represent "Stream" object content as a string
	 * @param {number} [start] Start position to convert to string
	 * @param {number} [length] Length of array to convert to string
	 * @returns {string}
	 */
	toString(start = 0, length = (this.view.length - start))
	{
		//region Initial variables
		let result = "";
		//endregion
		
		//region Check input parameters
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((start >= this.view.length) || (start < 0))
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((length >= this.view.length) || (length < 0))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.view.length - start;
		}
		//endregion
		
		//region Convert array of bytes to string
		// noinspection NonBlockStatementBodyJS
		for(let i = start; i < (start + length); i++)
			result += String.fromCharCode(this.view[i]);
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionTooLongJS
	/**
	 * Initialize "Stream" object from existing hexdecimal string
	 * @param {string} hexString String to initialize from
	 */
	fromHexString(hexString)
	{
		//region Initial variables
		const stringLength = hexString.length;
		
		this.buffer = new ArrayBuffer(stringLength >> 1);
		this.view = new Uint8Array(this.buffer);
		
		const hexMap = new Map();
		
		// noinspection MagicNumberJS
		hexMap.set("0", 0x00);
		// noinspection MagicNumberJS
		hexMap.set("1", 0x01);
		// noinspection MagicNumberJS
		hexMap.set("2", 0x02);
		// noinspection MagicNumberJS
		hexMap.set("3", 0x03);
		// noinspection MagicNumberJS
		hexMap.set("4", 0x04);
		// noinspection MagicNumberJS
		hexMap.set("5", 0x05);
		// noinspection MagicNumberJS
		hexMap.set("6", 0x06);
		// noinspection MagicNumberJS
		hexMap.set("7", 0x07);
		// noinspection MagicNumberJS
		hexMap.set("8", 0x08);
		// noinspection MagicNumberJS
		hexMap.set("9", 0x09);
		// noinspection MagicNumberJS
		hexMap.set("A", 0x0A);
		// noinspection MagicNumberJS
		hexMap.set("a", 0x0A);
		// noinspection MagicNumberJS
		hexMap.set("B", 0x0B);
		// noinspection MagicNumberJS
		hexMap.set("b", 0x0B);
		// noinspection MagicNumberJS
		hexMap.set("C", 0x0C);
		// noinspection MagicNumberJS
		hexMap.set("c", 0x0C);
		// noinspection MagicNumberJS
		hexMap.set("D", 0x0D);
		// noinspection MagicNumberJS
		hexMap.set("d", 0x0D);
		// noinspection MagicNumberJS
		hexMap.set("E", 0x0E);
		// noinspection MagicNumberJS
		hexMap.set("e", 0x0E);
		// noinspection MagicNumberJS
		hexMap.set("F", 0x0F);
		// noinspection MagicNumberJS
		hexMap.set("f", 0x0F);
		
		let j = 0;
		// noinspection MagicNumberJS
		let temp = 0x00;
		//endregion
		
		//region Convert char-by-char
		for(let i = 0; i < stringLength; i++)
		{
			// noinspection NegatedIfStatementJS
			if(!(i % 2))
			{
				// noinspection NestedFunctionCallJS
				temp = hexMap.get(hexString.charAt(i)) << 4;
			}
			else
			{
				// noinspection NestedFunctionCallJS
				temp |= hexMap.get(hexString.charAt(i));
				
				this.view[j] = temp;
				j++;
			}
		}
		//endregion
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Represent "Stream" object content as a hexdecimal string
	 * @param {number} [start=0] Start position to convert to string
	 * @param {number} [length=(this.view.length - start)] Length of array to convert to string
	 * @returns {string}
	 */
	toHexString(start = 0, length = (this.view.length - start))
	{
		//region Initial variables
		let result = "";
		//endregion
		
		//region Check input parameters
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((start >= this.view.length) || (start < 0))
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((length >= this.view.length) || (length < 0))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.view.length - start;
		}
		//endregion

		for(let i = start; i < (start + length); i++)
		{
			// noinspection ChainedFunctionCallJS
			const str = this.view[i].toString(16).toUpperCase();
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS
			result = result + ((str.length == 1) ? "0" : "") + str;
		}
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Return copy of existing "Stream"
	 * @param {number} [start=0] Start position of the copy
	 * @param {number} [length=this.view.length] Length of the copy
	 * @returns {ByteStream}
	 */
	copy(start = 0, length = (this._buffer.byteLength - start))
	{
		//region Check input parameters
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if((start === 0) && (this._buffer.byteLength === 0))
			return new ByteStream();
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if((start < 0) || (start > (this._buffer.byteLength - 1)))
			throw new Error(`Wrong start position: ${start}`);
		//endregion
		
		const stream = new ByteStream();
		
		stream._buffer = this._buffer.slice(start, start + length);
		stream._view = new Uint8Array(stream._buffer);
		
		return stream;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Return slice of existing "Stream"
	 * @param {number} [start=0] Start position of the slice
	 * @param {number} [end=this._buffer.byteLength] End position of the slice
	 * @returns {ByteStream}
	 */
	slice(start = 0, end = this._buffer.byteLength)
	{
		//region Check input parameters
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if((start === 0) && (this._buffer.byteLength === 0))
			return new ByteStream();
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if((start < 0) || (start > (this._buffer.byteLength - 1)))
			throw new Error(`Wrong start position: ${start}`);
		//endregion
		
		const stream = new ByteStream();
		
		stream._buffer = this._buffer.slice(start, end);
		stream._view = new Uint8Array(stream._buffer);
		
		return stream;
	}
	//**********************************************************************************
	/**
	 * Change size of existing "Stream"
	 * @param {!number} size Size for new "Stream"
	 */
	realloc(size)
	{
		//region Initial variables
		const buffer = new ArrayBuffer(size);
		const view = new Uint8Array(buffer);
		//endregion
		
		//region Create a new ArrayBuffer content
		// noinspection NonBlockStatementBodyJS
		if(size > this._view.length)
			view.set(this._view);
		else
		{
			// noinspection NestedFunctionCallJS
			view.set(new Uint8Array(this._buffer, 0, size));
		}
		//endregion
		
		//region Initialize "Stream" with new "ArrayBuffer"
		this._buffer = buffer.slice(0);
		this._view = new Uint8Array(this._buffer);
		//endregion
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Append a new "Stream" content to the current "Stream"
	 * @param {ByteStream} stream A new "stream" to append to current "stream"
	 */
	append(stream)
	{
		//region Initial variables
		const initialSize = this._buffer.byteLength;
		const streamViewLength = stream._buffer.byteLength;
		
		const copyView = stream._view.slice();
		//endregion
		
		//region Re-allocate current internal buffer
		this.realloc(initialSize + streamViewLength);
		//endregion
		
		//region Copy input stream content to a new place
		this._view.set(copyView, initialSize);
		//endregion
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Insert "Stream" content to the current "Stream" at specific position
	 * @param {ByteStream} stream A new "stream" to insert to current "stream"
	 * @param {number} [start=0] Start position to insert to
	 * @param {number} [length]
	 * @returns {boolean}
	 */
	insert(stream, start = 0, length = (this._buffer.byteLength - start))
	{
		//region Initial variables
		// noinspection NonBlockStatementBodyJS
		if(start > (this._buffer.byteLength - 1))
			return false;
		
		if(length > (this._buffer.byteLength - start))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this._buffer.byteLength - start;
		}
		//endregion
		
		//region Check input variables
		if(length > stream._buffer.byteLength)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = stream._buffer.byteLength;
		}
		//endregion
		
		//region Update content of the current stream
		// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(length == stream._buffer.byteLength)
			this._view.set(stream._view, start);
		else
		{
			// noinspection NestedFunctionCallJS
			this._view.set(stream._view.slice(0, length), start);
		}
		//endregion
		
		return true;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Check that two "Stream" objects has equal content
	 * @param {ByteStream} stream Stream to compare with
	 * @returns {boolean}
	 */
	isEqual(stream)
	{
		//region Check length of both buffers
		// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(this._buffer.byteLength != stream._buffer.byteLength)
			return false;
		//endregion
		
		//region Compare each byte of both buffers
		for(let i = 0; i < stream._buffer.byteLength; i++)
		{
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(this.view[i] != stream.view[i])
				return false;
		}
		//endregion
		
		return true;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Check that current "Stream" objects has equal content with input "Uint8Array"
	 * @param {Uint8Array} view View to compare with
	 * @returns {boolean}
	 */
	isEqualView(view)
	{
		//region Check length of both buffers
		// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(view.length != this.view.length)
			return false;
		//endregion
		
		//region Compare each byte of both buffers
		for(let i = 0; i < view.length; i++)
		{
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(this.view[i] != view[i])
				return false;
		}
		//endregion
		
		return true;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS
	/**
	 * Find any byte pattern in "Stream"
	 * @param {ByteStream} pattern Stream having pattern value
	 * @param {?number} [start] Start position to search from
	 * @param {?number} [length] Length of byte block to search at
	 * @param {boolean} [backward] Flag to search in backward order
	 * @returns {number}
	 */
	findPattern(pattern, start = null, length = null, backward = false)
	{
		//region Check input variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
			start = (backward) ? this.buffer.byteLength : 0;
		}
		
		if(start > this.buffer.byteLength)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = this.buffer.byteLength;
		}
		
		if(backward)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
			
			if(length > start)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
		}
		else
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
		}
		//endregion
		
		//region Initial variables
		const patternLength = pattern.buffer.byteLength;
		// noinspection NonBlockStatementBodyJS
		if(patternLength > length)
			return (-1);
		//endregion
		
		//region Make a "pre-read" array for pattern
		const patternArray = [];
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < patternLength; i++)
			patternArray.push(pattern.view[i]);
		//endregion
		
		//region Search for pattern
		for(let i = 0; i <= (length - patternLength); i++)
		{
			let equal = true;
			// noinspection ConditionalExpressionJS
			const equalStart = (backward) ? (start - patternLength - i) : (start + i);
			
			for(let j = 0; j < patternLength; j++)
			{
				// noinspection EqualityComparisonWithCoercionJS
				if(this.view[j + equalStart] != patternArray[j])
				{
					equal = false;
					// noinspection BreakStatementJS
					break;
				}
			}
			
			if(equal)
			{
				// noinspection ConditionalExpressionJS
				return (backward) ? (start - patternLength - i) : (start + patternLength + i); // Position after the pattern found
			}
		}
		//endregion
		
		return (-1);
	}
	//**********************************************************************************
	// noinspection OverlyComplexFunctionJS
	/**
	 * Find first position of any pattern from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
	 * @param {?number} [start] Start position to search from
	 * @param {?number} [length] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {{id: number, position: number}}
	 */
	findFirstIn(patterns, start = null, length = null, backward = false)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
			start = (backward) ? this.buffer.byteLength : 0;
		}
		
		if(start > this.buffer.byteLength)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = this.buffer.byteLength;
		}
		
		if(backward)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
			
			if(length > start)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
		}
		else
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
		}
		
		// noinspection ConditionalExpressionJS
		const result = {
			id: (-1),
			position: (backward) ? 0 : (start + length),
			length: 0
		};
		//endregion
		
		for(let i = 0; i < patterns.length; i++)
		{
			const position = this.findPattern(patterns[i], start, length, backward);
			// noinspection EqualityComparisonWithCoercionJS
			if(position != (-1))
			{
				let valid = false;
				const patternLength = patterns[i].length;

				if(backward)
				{
					// noinspection NonBlockStatementBodyJS
					if((position - patternLength) >= (result.position - result.length))
						valid = true;
				}
				else
				{
					// noinspection NonBlockStatementBodyJS
					if((position - patternLength) <= (result.position - result.length))
						valid = true;
				}
				
				if(valid)
				{
					result.position = position;
					result.id = i;
					result.length = patternLength;
				}
			}
		}
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Find all positions of any pattern from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
	 * @param {?number} [start] Start position to search from
	 * @param {?number} [length] Length of byte block to search at
	 * @returns {Array}
	 */
	findAllIn(patterns, start = 0, length = (this.buffer.byteLength - start))
	{
		//region Initial variables
		const result = [];
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection NonBlockStatementBodyJS
		if(start > (this.buffer.byteLength - 1))
			return result;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(length == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}

		if(length > (this.buffer.byteLength - start))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		let patternFound = {
			id: (-1),
			position: start
		};
		//endregion
		
		//region Find all accurences of patterns
		do
		{
			const position = patternFound.position;
			
			patternFound = this.findFirstIn(patterns, patternFound.position, length);
			
			// noinspection EqualityComparisonWithCoercionJS
			if(patternFound.id == (-1))
			{
				// noinspection BreakStatementJS
				break;
			}
			
			// noinspection AssignmentToFunctionParameterJS
			length -= (patternFound.position - position);
			
			result.push({
				id: patternFound.id,
				position: patternFound.position
			});
		} while(true); // eslint-disable-line
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS
	/**
	 * Find all positions of a pattern
	 * @param {ByteStream} pattern Stream having pattern value
	 * @param {?number} [start] Start position to search from
	 * @param {?number} [length] Length of byte block to search at
	 * @returns {Array|number} Array with all pattern positions or (-1) if failed
	 */
	findAllPatternIn(pattern, start = 0, length = (this.buffer.byteLength - start))
	{
		//region Check input variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		if(start > this.buffer.byteLength)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = this.buffer.byteLength;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(length == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		if(length > (this.buffer.byteLength - start))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		//endregion
		
		//region Initial variables
		const result = [];
		
		const patternLength = pattern.buffer.byteLength;
		// noinspection NonBlockStatementBodyJS
		if(patternLength > length)
			return (-1);
		//endregion
		
		//region Make a "pre-read" array for pattern
		const patternArray = Array.from(pattern.view);
		//endregion
		
		//region Search for pattern
		for(let i = 0; i <= (length - patternLength); i++)
		{
			let equal = true;
			const equalStart = start + i;
			
			for(let j = 0; j < patternLength; j++)
			{
				// noinspection EqualityComparisonWithCoercionJS
				if(this.view[j + equalStart] != patternArray[j])
				{
					equal = false;
					// noinspection BreakStatementJS
					break;
				}
			}
			
			if(equal)
			{
				result.push(start + patternLength + i); // Position after the pattern found
				i += (patternLength - 1); // On next step of "for" we will have "i++"
			}
		}
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection OverlyComplexFunctionJS, FunctionTooLongJS
	/**
	 * Find first position of data, not included in patterns from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
	 * @param {?number} [start] Start position to search from
	 * @param {?number} [length] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {{left: {id: number, position: *}, right: {id: number, position: number}, value: ByteStream}}
	 */
	findFirstNotIn(patterns, start = null, length = null, backward = false)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
			start = (backward) ? this.buffer.byteLength : 0;
		}
		
		if(start > this.buffer.byteLength)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = this.buffer.byteLength;
		}
		
		if(backward)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
			
			if(length > start)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
		}
		else
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
		}
		
		const result = {
			left: {
				id: (-1),
				position: start
			},
			right: {
				id: (-1),
				position: 0
			},
			value: new ByteStream()
		};
		
		let currentLength = length;
		//endregion
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		while(currentLength > 0)
		{
			//region Search for nearest "pattern"
			// noinspection ConditionalExpressionJS
			result.right = this.findFirstIn(patterns,
				(backward) ? (start - length + currentLength) : (start + length - currentLength),
				currentLength,
				backward);
			//endregion
			
			//region No pattern at all
			// noinspection EqualityComparisonWithCoercionJS
			if(result.right.id == (-1))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = currentLength;
				
				if(backward)
				{
					// noinspection AssignmentToFunctionParameterJS
					start -= length;
				}
				else
				{
					// noinspection AssignmentToFunctionParameterJS
					start = result.left.position;
				}
				
				result.value = new ByteStream();
				
				result.value._buffer = this._buffer.slice(start, start + length);
				result.value._view = new Uint8Array(result.value._buffer);
				
				// noinspection BreakStatementJS
				break;
			}
			//endregion
			
			//region Check distance between two patterns
			// noinspection ConditionalExpressionJS, EqualityComparisonWithCoercionJS
			if(result.right.position != ((backward) ? (result.left.position - patterns[result.right.id].buffer.byteLength) : (result.left.position + patterns[result.right.id].buffer.byteLength)))
			{
				if(backward)
				{
					// noinspection AssignmentToFunctionParameterJS
					start = result.right.position + patterns[result.right.id].buffer.byteLength;
					// noinspection AssignmentToFunctionParameterJS
					length = result.left.position - result.right.position - patterns[result.right.id].buffer.byteLength;
				}
				else
				{
					// noinspection AssignmentToFunctionParameterJS
					start = result.left.position;
					// noinspection AssignmentToFunctionParameterJS
					length = result.right.position - result.left.position - patterns[result.right.id].buffer.byteLength;
				}
				
				result.value = new ByteStream();
				
				result.value._buffer = this._buffer.slice(start, start + length);
				result.value._view = new Uint8Array(result.value._buffer);
				
				// noinspection BreakStatementJS
				break;
			}
			//endregion
			
			//region Store information about previous pattern
			result.left = result.right;
			//endregion
			
			//region Change current length
			currentLength -= patterns[result.right.id]._buffer.byteLength;
			//endregion
		}
		
		//region Swap "patterns" in case of backward order
		if(backward)
		{
			const temp = result.right;
			result.right = result.left;
			result.left = temp;
		}
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Find all positions of data, not included in patterns from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
	 * @param {?number} [start] Start position to search from
	 * @param {?number} [length] Length of byte block to search at
	 * @returns {Array}
	 */
	findAllNotIn(patterns, start = null, length = null)
	{
		//region Initial variables
		const result = [];
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection NonBlockStatementBodyJS
		if(start > (this.buffer.byteLength - 1))
			return result;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(length == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		if(length > (this.buffer.byteLength - start))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		let patternFound = {
			left: {
				id: (-1),
				position: start
			},
			right: {
				id: (-1),
				position: start
			},
			value: new ByteStream()
		};
		//endregion
		
		//region Find all accurences of patterns
		// noinspection EqualityComparisonWithCoercionJS
		do
		{
			const position = patternFound.right.position;
			
			patternFound = this.findFirstNotIn(patterns, patternFound.right.position, length);
			
			// noinspection AssignmentToFunctionParameterJS
			length -= (patternFound.right.position - position);
			
			result.push({
				left: {
					id: patternFound.left.id,
					position: patternFound.left.position
				},
				right: {
					id: patternFound.right.id,
					position: patternFound.right.position
				},
				value: patternFound.value
			});
		} while(patternFound.right.id != (-1));
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS
	/**
	 * Find position of a sequence of any patterns from input array
	 * @param {Array.<ByteStream>} patterns Array of pattern to look for
	 * @param {?number} [start] Start position to search from
	 * @param {?number} [length] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {*}
	 */
	findFirstSequence(patterns, start = null, length = null, backward = false)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
			start = (backward) ? this.buffer.byteLength : 0;
		}
		
		if(start > this.buffer.byteLength)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = this.buffer.byteLength;
		}
		
		if(backward)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
			
			if(length > start)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
		}
		else
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
		}
		//endregion
		
		//region Find first byte from sequence
		const firstIn = this.skipNotPatterns(patterns, start, length, backward);
		// noinspection EqualityComparisonWithCoercionJS
		if(firstIn == (-1))
		{
			return {
				position: (-1),
				value: new ByteStream()
			};
		}
		//endregion
		
		//region Find first byte not in sequence
		// noinspection ConditionalExpressionJS
		const firstNotIn = this.skipPatterns(patterns,
			firstIn,
			length - ((backward) ? (start - firstIn) : (firstIn - start)),
			backward);
		//endregion
		
		//region Make output value
		if(backward)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = firstNotIn;
			// noinspection AssignmentToFunctionParameterJS
			length = (firstIn - firstNotIn);
		}
		else
		{
			// noinspection AssignmentToFunctionParameterJS
			start = firstIn;
			// noinspection AssignmentToFunctionParameterJS
			length = (firstNotIn - firstIn);
		}
		
		const value = new ByteStream();
		
		value._buffer = this._buffer.slice(start, start + length);
		value._view = new Uint8Array(value._buffer);
		//endregion
		
		return {
			position: firstNotIn,
			value
		};
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Find all positions of a sequence of any patterns from input array
	 * @param {Array.<ByteStream>} patterns Array of patterns to search for
	 * @param {?number} [start] Start position to search from
	 * @param {?number} [length] Length of byte block to search at
	 * @returns {Array}
	 */
	findAllSequences(patterns, start = null, length = null)
	{
		//region Initial variables
		const result = [];
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection NonBlockStatementBodyJS
		if(start > (this.buffer.byteLength - 1))
			return result;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(length == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		if(length > (this.buffer.byteLength - start))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		let patternFound = {
			position: start,
			value: new ByteStream()
		};
		//endregion
		
		//region Find all accurences of patterns
		// noinspection EqualityComparisonWithCoercionJS
		do
		{
			const position = patternFound.position;
			
			patternFound = this.findFirstSequence(patterns, patternFound.position, length);
			
			// noinspection EqualityComparisonWithCoercionJS
			if(patternFound.position != (-1))
			{
				// noinspection AssignmentToFunctionParameterJS
				length -= (patternFound.position - position);
				
				result.push({
					position: patternFound.position,
					value: patternFound.value
				});
			}
			
		} while(patternFound.position != (-1));
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS
	/**
	 * Find all paired patterns in the stream
	 * @param {ByteStream} leftPattern Left pattern to search for
	 * @param {ByteStream} rightPattern Right pattern to search for
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @returns {Array}
	 */
	findPairedPatterns(leftPattern, rightPattern, start = null, length = null)
	{
		//region Initial variables
		const result = [];
		
		// noinspection NonBlockStatementBodyJS
		if(leftPattern.isEqual(rightPattern))
			return result;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection NonBlockStatementBodyJS
		if(start > (this.buffer.byteLength - 1))
			return result;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(length == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		if(length > (this.buffer.byteLength - start))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		let currentPositionLeft = 0;
		//endregion
		
		//region Find all "left patterns" as sorted array
		const leftPatterns = this.findAllPatternIn(leftPattern, start, length);
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(leftPatterns.length == 0)
			return result;
		//endregion
		
		//region Find all "right patterns" as sorted array
		const rightPatterns = this.findAllPatternIn(rightPattern, start, length);
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(rightPatterns.length == 0)
			return result;
		//endregion
		
		//region Combine patterns
		while(currentPositionLeft < leftPatterns.length)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS
			if(rightPatterns.length == 0)
			{
				// noinspection BreakStatementJS
				break;
			}
			
			// noinspection EqualityComparisonWithCoercionJS
			if(leftPatterns[0] == rightPatterns[0])
			{
				// Possible situation when one pattern is a part of another
				// For example "stream" and "endstream"
				// In case when we have only "endstream" in fact "stream" will be also found at the same position
				// (position of the pattern is an index AFTER the pattern)
				
				result.push({
					left: leftPatterns[0],
					right: rightPatterns[0]
				});
				
				leftPatterns.splice(0, 1);
				rightPatterns.splice(0, 1);
				
				// noinspection ContinueStatementJS
				continue;
			}
			
			if(leftPatterns[currentPositionLeft] > rightPatterns[0])
			{
				// noinspection BreakStatementJS
				break;
			}
			
			while(leftPatterns[currentPositionLeft] < rightPatterns[0])
			{
				currentPositionLeft++;
				
				if(currentPositionLeft >= leftPatterns.length)
				{
					// noinspection BreakStatementJS
					break;
				}
			}
			
			result.push({
				left: leftPatterns[currentPositionLeft - 1],
				right: rightPatterns[0]
			});
			
			leftPatterns.splice(currentPositionLeft - 1, 1);
			rightPatterns.splice(0, 1);
			
			currentPositionLeft = 0;
		}
		//endregion
		
		//region Sort result
		result.sort((a, b) => (a.left - b.left));
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS
	/**
	 * Find all paired patterns in the stream
	 * @param {Array.<ByteStream>} inputLeftPatterns Array of left patterns to search for
	 * @param {Array.<ByteStream>} inputRightPatterns Array of right patterns to search for
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @returns {Array}
	 */
	findPairedArrays(inputLeftPatterns, inputRightPatterns, start = null, length = null)
	{
		//region Initial variables
		const result = [];
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection NonBlockStatementBodyJS
		if(start > (this.buffer.byteLength - 1))
			return result;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(length == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		if(length > (this.buffer.byteLength - start))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		let currentPositionLeft = 0;
		//endregion
		
		//region Find all "left patterns" as sorted array
		const leftPatterns = this.findAllIn(inputLeftPatterns, start, length);
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(leftPatterns.length == 0)
			return result;
		//endregion
		
		//region Find all "right patterns" as sorted array
		const rightPatterns = this.findAllIn(inputRightPatterns, start, length);
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(rightPatterns.length == 0)
			return result;
		//endregion
		
		//region Combine patterns
		while(currentPositionLeft < leftPatterns.length)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS
			if(rightPatterns.length == 0)
			{
				// noinspection BreakStatementJS
				break;
			}
			
			// noinspection EqualityComparisonWithCoercionJS
			if(leftPatterns[0].position == rightPatterns[0].position)
			{
				// Possible situation when one pattern is a part of another
				// For example "stream" and "endstream"
				// In case when we have only "endstream" in fact "stream" will be also found at the same position
				// (position of the pattern is an index AFTER the pattern)
				
				result.push({
					left: leftPatterns[0],
					right: rightPatterns[0]
				});
				
				leftPatterns.splice(0, 1);
				rightPatterns.splice(0, 1);
				
				// noinspection ContinueStatementJS
				continue;
			}
			
			if(leftPatterns[currentPositionLeft].position > rightPatterns[0].position)
			{
				// noinspection BreakStatementJS
				break;
			}
			
			while(leftPatterns[currentPositionLeft].position < rightPatterns[0].position)
			{
				currentPositionLeft++;
				
				if(currentPositionLeft >= leftPatterns.length)
				{
					// noinspection BreakStatementJS
					break;
				}
			}
			
			result.push({
				left: leftPatterns[currentPositionLeft - 1],
				right: rightPatterns[0]
			});
			
			leftPatterns.splice(currentPositionLeft - 1, 1);
			rightPatterns.splice(0, 1);
			
			currentPositionLeft = 0;
		}
		//endregion
		
		//region Sort result
		result.sort((a, b) => (a.left.position - b.left.position));
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS, FunctionTooLongJS
	/**
	 * Replace one patter with other
	 * @param {ByteStream} searchPattern The pattern to search for
	 * @param {ByteStream} replacePattern The pattern to replace initial pattern
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @param {Array|null} [findAllResult=null] Pre-calculated results of "findAllIn"
	 * @returns {*}
	 */
	replacePattern(searchPattern, replacePattern, start = null, length = null, findAllResult = null)
	{
		//region Initial variables
		let result;
		
		let i;
		const output = {
			status: (-1),
			searchPatternPositions: [],
			replacePatternPositions: []
		};
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection NonBlockStatementBodyJS
		if(start > (this.buffer.byteLength - 1))
			return false;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(length == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		
		if(length > (this.buffer.byteLength - start))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.buffer.byteLength - start;
		}
		//endregion
		
		//region Find a pattern to search for
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if(findAllResult == null)
		{
			result = this.findAllIn([searchPattern], start, length);
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(result.length == 0)
				return output;
		}
		else
			result = findAllResult;
		
		// noinspection NestedFunctionCallJS
		output.searchPatternPositions.push(...Array.from(result, element => element.position));
		//endregion
		
		//region Variables for new buffer initialization
		const patternDifference = searchPattern.buffer.byteLength - replacePattern.buffer.byteLength;
		
		const changedBuffer = new ArrayBuffer(this.view.length - (result.length * patternDifference));
		const changedView = new Uint8Array(changedBuffer);
		//endregion
		
		//region Copy data from 0 to start
		// noinspection NestedFunctionCallJS
		changedView.set(new Uint8Array(this.buffer, 0, start));
		//endregion
		
		//region Replace pattern
		for(i = 0; i < result.length; i++)
		{
			//region Initial variables
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS
			const currentPosition = (i == 0) ? start : result[i - 1].position;
			//endregion
			
			//region Copy bytes other then search pattern
			// noinspection NestedFunctionCallJS
			changedView.set(new Uint8Array(this.buffer, currentPosition, result[i].position - searchPattern.buffer.byteLength - currentPosition), currentPosition - i * patternDifference);
			//endregion
			
			//region Put replace pattern in a new buffer
			changedView.set(replacePattern.view, result[i].position - searchPattern.buffer.byteLength - i * patternDifference);
			
			output.replacePatternPositions.push(result[i].position - searchPattern.buffer.byteLength - i * patternDifference);
			//endregion
		}
		//endregion
		
		//region Copy data from the end of old buffer
		i--;
		// noinspection NestedFunctionCallJS
		changedView.set(new Uint8Array(this.buffer, result[i].position, this.buffer.byteLength - result[i].position), result[i].position - searchPattern.buffer.byteLength + replacePattern.buffer.byteLength - i * patternDifference);
		//endregion
		
		//region Re-initialize existing buffer
		this.buffer = changedBuffer;
		this.view = new Uint8Array(this.buffer);
		//endregion
		
		output.status = 1;
		
		return output;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS
	/**
	 * Skip any pattern from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {*}
	 */
	skipPatterns(patterns, start = null, length = null, backward = false)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
			start = (backward) ? this.buffer.byteLength : 0;
		}
		
		if(start > this.buffer.byteLength)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = this.buffer.byteLength;
		}
		
		if(backward)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
			
			if(length > start)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
		}
		else
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
		}
		
		let result = start;
		//endregion
		
		//region Search for pattern
		for(let k = 0; k < patterns.length; k++)
		{
			const patternLength = patterns[k].buffer.byteLength;
			// noinspection ConditionalExpressionJS
			const equalStart = (backward) ? (result - patternLength) : (result);
			let equal = true;
			
			for(let j = 0; j < patternLength; j++)
			{
				// noinspection EqualityComparisonWithCoercionJS
				if(this.view[j + equalStart] != patterns[k].view[j])
				{
					equal = false;
					// noinspection BreakStatementJS
					break;
				}
			}
			
			if(equal)
			{
				k = (-1);
				
				if(backward)
				{
					result -= patternLength;
					// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
					if(result <= 0)
						return result;
				}
				else
				{
					result += patternLength;
					// noinspection NonBlockStatementBodyJS
					if(result >= (start + length))
						return result;
				}
			}
		}
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionTooLongJS
	/**
	 * Skip any pattern not from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should not be ommited
	 * @param start
	 * @param length
	 * @param backward
	 * @returns {number}
	 */
	skipNotPatterns(patterns, start = null, length = null, backward = false)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS, ConditionalExpressionJS
			start = (backward) ? this.buffer.byteLength : 0;
		}
		
		if(start > this.buffer.byteLength)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = this.buffer.byteLength;
		}
		
		if(backward)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
			
			if(length > start)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = start;
			}
		}
		else
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
			if(length == null)
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
			
			if(length > (this.buffer.byteLength - start))
			{
				// noinspection AssignmentToFunctionParameterJS
				length = this.buffer.byteLength - start;
			}
		}
		
		let result = (-1);
		//endregion
		
		//region Search for pattern
		for(let i = 0; i < length; i++)
		{
			for(let k = 0; k < patterns.length; k++)
			{
				const patternLength = patterns[k].buffer.byteLength;
				// noinspection ConditionalExpressionJS
				const equalStart = (backward) ? (start - i - patternLength) : (start + i);
				let equal = true;
				
				for(let j = 0; j < patternLength; j++)
				{
					// noinspection EqualityComparisonWithCoercionJS
					if(this.view[j + equalStart] != patterns[k].view[j])
					{
						equal = false;
						// noinspection BreakStatementJS
						break;
					}
				}
				
				if(equal)
				{
					// noinspection ConditionalExpressionJS
					result = (backward) ? (start - i) : (start + i); // Exact position of pattern found
					// noinspection BreakStatementJS
					break;
				}
			}
			
			// noinspection EqualityComparisonWithCoercionJS
			if(result != (-1))
			{
				// noinspection BreakStatementJS
				break;
			}
		}
		//endregion
		
		return result;
	}
	//**********************************************************************************
}
//**************************************************************************************
class SeqStream 
{
	//**********************************************************************************
	/**
	 * Constructor for "SeqStream" class
	 * @param {{[stream]: ByteStream, [length]: number, [backward]: boolean, [start]: number, [appendBlock]: number}} parameters
	 */
	constructor(parameters = {})
	{
		/**
		 * Major stream
		 * @type {ByteStream}
		 */
		this.stream = new ByteStream();
		/**
		 * Length of the major stream
		 * @type {number}
		 */
		this._length = 0;
		/**
		 * Flag to search in backward direction
		 * @type {boolean}
		 */
		this.backward = false;
		/**
		 * Start position to search
		 * @type {number}
		 */
		this._start = 0;
		/**
		 * Length of a block when append information to major stream
		 * @type {number}
		 */
		this.appendBlock = 0;
		
		this.prevLength = 0;
		this.prevStart = 0;
		
		for(const key of Object.keys(parameters))
		{
			switch(key)
			{
				case "stream":
					this.stream = parameters.stream;
					break;
				case "backward":
					this.backward = parameters.backward;
					// noinspection JSUnusedGlobalSymbols
					this._start = this.stream.buffer.byteLength;
					break;
				case "length":
					// noinspection JSUnusedGlobalSymbols
					this._length = parameters.length;
					break;
				case "start":
					// noinspection JSUnusedGlobalSymbols
					this._start = parameters.start;
					break;
				case "appendBlock":
					this.appendBlock = parameters.appendBlock;
					break;
				case "view":
					this.stream = new ByteStream({ view: parameters.view});
					break;
				case "buffer":
					this.stream = new ByteStream({ buffer: parameters.buffer});
					break;
				case "string":
					this.stream = new ByteStream({ string: parameters.string});
					break;
				case "hexstring":
					this.stream = new ByteStream({ hexstring: parameters.hexstring});
					break;
				default:
			}
		}
	}
	//**********************************************************************************
	/**
	 * Setter for "stream" property
	 * @param {ByteStream} value
	 */
	set stream(value)
	{
		this._stream = value;
		
		this.prevLength = this._length;
		// noinspection JSUnusedGlobalSymbols
		this._length = value._buffer.byteLength;
		
		this.prevStart = this._start;
		// noinspection JSUnusedGlobalSymbols
		this._start = 0;
	}
	//**********************************************************************************
	/**
	 * Getter for "stream" property
	 * @returns {ByteStream}
	 */
	get stream()
	{
		return this._stream;
	}
	//**********************************************************************************
	/**
	 * Setter for "length" property
	 * @param {number} value
	 */
	set length(value)
	{
		this.prevLength = this._length;
		// noinspection JSUnusedGlobalSymbols
		this._length = value;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Getter for "length" property
	 * @returns {number}
	 */
	get length()
	{
		// noinspection NonBlockStatementBodyJS
		if(this.appendBlock)
			return this.start;
		
		return this._length;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Setter for "start" property
	 * @param {number} value
	 */
	set start(value)
	{
		// noinspection NonBlockStatementBodyJS
		if(value > this.stream.buffer.byteLength)
			return;
		
		//region Initialization of "prev" internal variables
		this.prevStart = this._start;
		this.prevLength = this._length;
		//endregion
		
		// noinspection JSUnusedGlobalSymbols, ConditionalExpressionJS
		this._length -= ((this.backward) ? (this._start - value) : (value - this._start));
		// noinspection JSUnusedGlobalSymbols
		this._start = value;
	}
	//**********************************************************************************
	/**
	 * Getter for "start" property
	 * @returns {number}
	 */
	get start()
	{
		return this._start;
	}
	//**********************************************************************************
	/**
	 * Return ArrayBuffer with having value of existing SeqStream length
	 * @return {ArrayBuffer}
	 */
	get buffer()
	{
		return this._stream._buffer.slice(0, this._length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Reset current position of the "SeqStream"
	 */
	resetPosition()
	{
		// noinspection JSUnusedGlobalSymbols
		this._start = this.prevStart;
		// noinspection JSUnusedGlobalSymbols
		this._length = this.prevLength;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Find any byte pattern in "ByteStream"
	 * @param {ByteStream} pattern Stream having pattern value
	 * @param {?number} [gap] Maximum gap between start position and position of nearest object
	 * @returns {number}
	 */
	findPattern(pattern, gap = null)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((gap == null) || (gap > this.length))
		{
			// noinspection AssignmentToFunctionParameterJS
			gap = this.length;
		}
		//endregion
		
		//region Find pattern
		const result = this.stream.findPattern(pattern, this.start, this.length, this.backward);
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(result == (-1))
			return result;
		
		if(this.backward)
		{
			// noinspection NonBlockStatementBodyJS
			if(result < (this.start - pattern.buffer.byteLength - gap))
				return (-1);
		}
		else
		{
			// noinspection NonBlockStatementBodyJS
			if(result > (this.start + pattern.buffer.byteLength + gap))
				return (-1);
		}
		//endregion
		
		//region Create new values
		this.start = result;
		//endregion ;
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Find first position of any pattern from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
	 * @param {?number} [gap] Maximum gap between start position and position of nearest object
	 * @returns {{id: number, position: number}}
	 */
	findFirstIn(patterns, gap = null)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((gap == null) || (gap > this.length))
		{
			// noinspection AssignmentToFunctionParameterJS
			gap = this.length;
		}
		//endregion
		
		//region Search for patterns
		const result = this.stream.findFirstIn(patterns, this.start, this.length, this.backward);
		// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(result.id == (-1))
			return result;
		
		if(this.backward)
		{
			if(result.position < (this.start - patterns[result.id].buffer.byteLength - gap))
			{
				// noinspection ConditionalExpressionJS
				return {
					id: (-1),
					position: (this.backward) ? 0 : (this.start + this.length)
				};
			}
		}
		else
		{
			if(result.position > (this.start + patterns[result.id].buffer.byteLength + gap))
			{
				// noinspection ConditionalExpressionJS
				return {
					id: (-1),
					position: (this.backward) ? 0 : (this.start + this.length)
				};
			}
		}
		//endregion
		
		//region Create new values
		this.start = result.position;
		//endregion ;
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find all positions of any pattern from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
	 * @returns {Array}
	 */
	findAllIn(patterns)
	{
		// In case of "backward order" the start position is at the end on stream.
		// In case of "normal order" the start position is at the begging of the stream.
		// But in fact for search for all patterns we need to have start position in "normal order".
		// noinspection ConditionalExpressionJS
		const start = (this.backward) ? (this.start - this.length) : this.start;
		
		return this.stream.findAllIn(patterns, start, this.length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS
	/**
	 * Find first position of data, not included in patterns from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
	 * @param {?number} gap Maximum gap between start position and position of nearest object
	 * @returns {*}
	 */
	findFirstNotIn(patterns, gap = null)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((gap == null) || (gap > this._length))
		{
			// noinspection AssignmentToFunctionParameterJS
			gap = this._length;
		}
		//endregion
		
		//region Search for patterns
		const result = this._stream.findFirstNotIn(patterns, this._start, this._length, this.backward);
		// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if((result.left.id == (-1)) && (result.right.id == (-1)))
			return result;
		
		if(this.backward)
		{
			// noinspection EqualityComparisonWithCoercionJS
			if(result.right.id != (-1))
			{
				if(result.right.position < (this._start - patterns[result.right.id]._buffer.byteLength - gap))
				{
					return {
						left: {
							id: (-1),
							position: this._start
						},
						right: {
							id: (-1),
							position: 0
						},
						value: new ByteStream()
					};
				}
			}
		}
		else
		{
			// noinspection EqualityComparisonWithCoercionJS
			if(result.left.id != (-1))
			{
				if(result.left.position > (this._start + patterns[result.left.id]._buffer.byteLength + gap))
				{
					return {
						left: {
							id: (-1),
							position: this._start
						},
						right: {
							id: (-1),
							position: 0
						},
						value: new ByteStream()
					};
				}
			}
		}
		//endregion
		
		//region Create new values
		if(this.backward)
		{
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(result.left.id == (-1))
				this.start = 0;
			else
				this.start = result.left.position;
		}
		else
		{
			// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
			if(result.right.id == (-1))
				this.start = (this._start + this._length);
			else
				this.start = result.right.position;
		}
		//endregion ;
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find all positions of data, not included in patterns from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
	 * @returns {Array}
	 */
	findAllNotIn(patterns)
	{
		// In case of "backward order" the start position is at the end on stream.
		// In case of "normal order" the start position is at the begging of the stream.
		// But in fact for search for all patterns we need to have start position in "normal order".
		// noinspection ConditionalExpressionJS
		const start = (this.backward) ? (this._start - this._length) : this._start;
		
		return this._stream.findAllNotIn(patterns, start, this._length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Find position of a sequence of any patterns from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
	 * @param {?number} [length] Length to search sequence for
	 * @param {?number} [gap] Maximum gap between start position and position of nearest object
	 * @returns {*}
	 */
	findFirstSequence(patterns, length = null, gap = null)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((length == null) || (length > this._length))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this._length;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((gap == null) || (gap > length))
		{
			// noinspection AssignmentToFunctionParameterJS
			gap = length;
		}
		//endregion
		
		//region Search for sequence
		const result = this._stream.findFirstSequence(patterns, this._start, length, this.backward);
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(result.value.buffer.byteLength == 0)
			return result;
		
		if(this.backward)
		{
			if(result.position < (this._start - result.value._buffer.byteLength - gap))
			{
				return {
					position: (-1),
					value: new ByteStream()
				};
			}
		}
		else
		{
			if(result.position > (this._start + result.value._buffer.byteLength + gap))
			{
				return {
					position: (-1),
					value: new ByteStream()
				};
			}
		}
		//endregion
		
		//region Create new values
		this.start = result.position;
		//endregion ;
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find position of a sequence of any patterns from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be found
	 * @returns {Array}
	 */
	findAllSequences(patterns)
	{
		// In case of "backward order" the start position is at the end on stream.
		// In case of "normal order" the start position is at the begging of the stream.
		// But in fact for search for all patterns we need to have start position in "normal order".
		// noinspection ConditionalExpressionJS
		const start = (this.backward) ? (this.start - this.length) : this.start;
		
		return this.stream.findAllSequences(patterns, start, this.length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Find all paired patterns in the stream
	 * @param {ByteStream} leftPattern Left pattern to search for
	 * @param {ByteStream} rightPattern Right pattern to search for
	 * @param {?number} [gap] Maximum gap between start position and position of nearest object
	 * @returns {Array}
	 */
	findPairedPatterns(leftPattern, rightPattern, gap = null)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((gap == null) || (gap > this.length))
		{
			// noinspection AssignmentToFunctionParameterJS
			gap = this.length;
		}
		//endregion
		
		// In case of "backward order" the start position is at the end on stream.
		// In case of "normal order" the start position is at the begging of the stream.
		// But in fact for search for all patterns we need to have start position in "normal order".
		// noinspection ConditionalExpressionJS
		const start = (this.backward) ? (this.start - this.length) : this.start;
		
		//region Search for patterns
		const result = this.stream.findPairedPatterns(leftPattern, rightPattern, start, this.length);
		if(result.length)
		{
			if(this.backward)
			{
				// noinspection NonBlockStatementBodyJS
				if(result[0].right < (this.start - rightPattern.buffer.byteLength - gap))
					return [];
			}
			else
			{
				// noinspection NonBlockStatementBodyJS
				if(result[0].left > (this.start + leftPattern.buffer.byteLength + gap))
					return [];
			}
		}
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Find all paired patterns in the stream
	 * @param {Array.<ByteStream>} leftPatterns Array of left patterns to search for
	 * @param {Array.<ByteStream>} rightPatterns Array of right patterns to search for
	 * @param {?number} [gap] Maximum gap between start position and position of nearest object
	 * @returns {Array}
	 */
	findPairedArrays(leftPatterns, rightPatterns, gap = null)
	{
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((gap == null) || (gap > this.length))
		{
			// noinspection AssignmentToFunctionParameterJS
			gap = this.length;
		}
		//endregion
		
		// In case of "backward order" the start position is at the end on stream.
		// In case of "normal order" the start position is at the begging of the stream.
		// But in fact for search for all patterns we need to have start position in "normal order".
		// noinspection ConditionalExpressionJS
		const start = (this.backward) ? (this.start - this.length) : this.start;
		
		//region Search for patterns
		const result = this.stream.findPairedArrays(leftPatterns, rightPatterns, start, this.length);
		if(result.length)
		{
			if(this.backward)
			{
				// noinspection NonBlockStatementBodyJS
				if(result[0].right.position < (this.start - rightPatterns[result[0].right.id].buffer.byteLength - gap))
					return [];
			}
			else
			{
				// noinspection NonBlockStatementBodyJS
				if(result[0].left.position > (this.start + leftPatterns[result[0].left.id].buffer.byteLength + gap))
					return [];
			}
		}
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Replace one patter with other
	 * @param {ByteStream} searchPattern The pattern to search for
	 * @param {ByteStream} replacePattern The pattern to replace initial pattern
	 * @returns {*}
	 */
	replacePattern(searchPattern, replacePattern)
	{
		// In case of "backward order" the start position is at the end on stream.
		// In case of "normal order" the start position is at the begging of the stream.
		// But in fact for search for all patterns we need to have start position in "normal order".
		// noinspection ConditionalExpressionJS
		const start = (this.backward) ? (this.start - this.length) : this.start;
		
		return this.stream.replacePattern(searchPattern, replacePattern, start, this.length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Skip of any pattern from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
	 * @returns {*}
	 */
	skipPatterns(patterns)
	{
		const result = this.stream.skipPatterns(patterns, this.start, this.length, this.backward);
		
		//region Create new values
		this.start = result;
		//endregion ;
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Skip of any pattern from input array
	 * @param {Array.<ByteStream>} patterns Array with patterns which should be ommited
	 * @returns {number}
	 */
	skipNotPatterns(patterns)
	{
		const result = this.stream.skipNotPatterns(patterns, this.start, this.length, this.backward);
		// noinspection NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
		if(result == (-1))
			return (-1);
		
		//region Create new values
		this.start = result;
		//endregion ;
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Append a new "Stream" content to the current "Stream"
	 * @param {ByteStream} stream A new "stream" to append to current "stream"
	 */
	append(stream)
	{
		if((this._start + stream._buffer.byteLength) > this._stream._buffer.byteLength)
		{
			if(stream._buffer.byteLength > this.appendBlock)
			{
				// noinspection MagicNumberJS
				this.appendBlock = (stream._buffer.byteLength + 1000);
			}
			
			this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
		}
		
		this._stream._view.set(stream._view, this._start);
		
		this._length += (stream._buffer.byteLength * 2);
		this.start = (this._start + stream._buffer.byteLength);
		this.prevLength -= (stream._buffer.byteLength * 2);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Append a "view" content to the current "Stream"
	 * @param {Uint8Array} view A new "view" to append to current "stream"
	 */
	appendView(view)
	{
		if((this._start + view.length) > this._stream._buffer.byteLength)
		{
			if(view.length > this.appendBlock)
			{
				// noinspection MagicNumberJS
				this.appendBlock = (view.length + 1000);
			}
			
			this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
		}
		
		this._stream._view.set(view, this._start);
		
		this._length += (view.length * 2);
		this.start = (this._start + view.length);
		this.prevLength -= (view.length * 2);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Append a new char to the current "Stream"
	 * @param {number} char A new char to append to current "stream"
	 */
	appendChar(char)
	{
		if((this._start + 1) > this._stream._buffer.byteLength)
		{
			// noinspection ConstantOnLefSideOfComparisonJS
			if(1 > this.appendBlock)
			{
				// noinspection MagicNumberJS
				this.appendBlock = 1000;
			}
			
			this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
		}
		
		this._stream._view[this._start] = char;
		
		this._length += 2;
		this.start = (this._start + 1);
		this.prevLength -= 2;
	}
	//**********************************************************************************
	// noinspection FunctionNamingConventionJS
	/**
	 * Append a new number to the current "Stream"
	 * @param {number} number A new unsigned 16-bit integer to append to current "stream"
	 */
	appendUint16(number)
	{
		if((this._start + 2) > this._stream._buffer.byteLength)
		{
			// noinspection ConstantOnLefSideOfComparisonJS
			if(2 > this.appendBlock)
			{
				// noinspection MagicNumberJS
				this.appendBlock = 1000;
			}
			
			this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
		}
		
		const value = new Uint16Array([number]);
		const view = new Uint8Array(value.buffer);
		
		this._stream._view[this._start] = view[1];
		this._stream._view[this._start + 1] = view[0];
		
		this._length += 4;
		this.start = (this._start + 2);
		this.prevLength -= 4;
	}
	//**********************************************************************************
	// noinspection FunctionNamingConventionJS
	/**
	 * Append a new number to the current "Stream"
	 * @param {number} number A new unsigned 24-bit integer to append to current "stream"
	 */
	appendUint24(number)
	{
		if((this._start + 3) > this._stream._buffer.byteLength)
		{
			// noinspection ConstantOnLefSideOfComparisonJS
			if(3 > this.appendBlock)
			{
				// noinspection MagicNumberJS
				this.appendBlock = 1000;
			}
			
			this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
		}
		
		const value = new Uint32Array([number]);
		const view = new Uint8Array(value.buffer);
		
		this._stream._view[this._start] = view[2];
		this._stream._view[this._start + 1] = view[1];
		this._stream._view[this._start + 2] = view[0];
		
		this._length += 6;
		this.start = (this._start + 3);
		this.prevLength -= 6;
	}
	//**********************************************************************************
	// noinspection FunctionNamingConventionJS
	/**
	 * Append a new number to the current "Stream"
	 * @param {number} number A new unsigned 32-bit integer to append to current "stream"
	 */
	appendUint32(number)
	{
		if((this._start + 4) > this._stream._buffer.byteLength)
		{
			// noinspection ConstantOnLefSideOfComparisonJS
			if(4 > this.appendBlock)
			{
				// noinspection MagicNumberJS
				this.appendBlock = 1000;
			}
			
			this._stream.realloc(this._stream._buffer.byteLength + this.appendBlock);
		}
		
		const value = new Uint32Array([number]);
		const view = new Uint8Array(value.buffer);
		
		this._stream._view[this._start] = view[3];
		this._stream._view[this._start + 1] = view[2];
		this._stream._view[this._start + 2] = view[1];
		this._stream._view[this._start + 3] = view[0];
		
		this._length += 8;
		this.start = (this._start + 4);
		this.prevLength -= 8;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Get a block of data
	 * @param {number} size Size of the data block to get
	 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
	 * @returns {Array}
	 */
	getBlock(size, changeLength = true)
	{
		//region Check input parameters
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if(this._length <= 0)
			return [];
		
		if(this._length < size)
		{
			// noinspection AssignmentToFunctionParameterJS
			size = this._length;
		}
		//endregion
		
		//region Initial variables
		let result;
		//endregion
		
		//region Getting result depends on "backward" flag
		if(this.backward)
		{
			const buffer = this._stream._buffer.slice(this._length - size, this._length);
			const view = new Uint8Array(buffer);
			
			result = new Array(size);
			
			// noinspection NonBlockStatementBodyJS
			for(let i = 0; i < size; i++)
				result[size - 1 - i] = view[i];
		}
		else
		{
			const buffer = this._stream._buffer.slice(this._start, this._start + size);
			
			// noinspection NestedFunctionCallJS
			result = Array.from(new Uint8Array(buffer));
		}
		//endregion
		
		//region Change "length" value if needed
		if(changeLength)
		{
			// noinspection ConditionalExpressionJS
			this.start += ((this.backward) ? ((-1) * size) : size);
		}
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS
	/**
	 * Get 2-byte unsigned integer value
	 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
	 * @returns {number}
	 */
	getUint16(changeLength = true)
	{
		const block = this.getBlock(2, changeLength);
		
		//region Check posibility for convertion
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if(block.length < 2)
			return 0;
		//endregion
		
		//region Convert byte array to "Uint16Array" value
		const value = new Uint16Array(1);
		const view = new Uint8Array(value.buffer);
		
		view[0] = block[1];
		view[1] = block[0];
		//endregion
		
		return value[0];
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS
	/**
	 * Get 2-byte signed integer value
	 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
	 * @returns {number}
	 */
	getInt16(changeLength = true)
	{
		const block = this.getBlock(2, changeLength);

		//region Check posibility for convertion
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if(block.length < 2)
			return 0;
		//endregion

		//region Convert byte array to "Int16Array" value
		const value = new Int16Array(1);
		const view = new Uint8Array(value.buffer);

		view[0] = block[1];
		view[1] = block[0];
		//endregion

		return value[0];
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS
	/**
	 * Get 3-byte unsigned integer value
	 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
	 * @returns {number}
	 */
	getUint24(changeLength = true)
	{
		const block = this.getBlock(3, changeLength);
		
		//region Check posibility for convertion
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if(block.length < 3)
			return 0;
		//endregion
		
		//region Convert byte array to "Uint32Array" value
		const value = new Uint32Array(1);
		const view = new Uint8Array(value.buffer);
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		for(let i = 3; i >= 1; i--)
			view[3 - i] = block[i - 1];
		//endregion
		
		return value[0];
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS, FunctionNamingConventionJS
	/**
	 * Get 4-byte unsigned integer value
	 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
	 * @returns {number}
	 */
	getUint32(changeLength = true)
	{
		const block = this.getBlock(4, changeLength);
		
		//region Check posibility for convertion
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if(block.length < 4)
			return 0;
		//endregion
		
		//region Convert byte array to "Uint32Array" value
		const value = new Uint32Array(1);
		const view = new Uint8Array(value.buffer);
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		for(let i = 3; i >= 0; i--)
			view[3 - i] = block[i];
		//endregion
		
		return value[0];
	}
	//**********************************************************************************
	/**
	 * Get 4-byte signed integer value
	 * @param {boolean} [changeLength=true] Should we change "length" and "start" value after reading the data block
	 * @returns {number}
	 */
	getInt32(changeLength = true)
	{
		const block = this.getBlock(4, changeLength);

		//region Check posibility for convertion
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if(block.length < 4)
			return 0;
		//endregion

		//region Convert byte array to "Int32Array" value
		const value = new Int32Array(1);
		const view = new Uint8Array(value.buffer);

		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		for(let i = 3; i >= 0; i--)
			view[3 - i] = block[i];
		//endregion

		return value[0];
	}
	//**********************************************************************************
}
//**************************************************************************************
// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS, OverlyComplexFunctionJS, FunctionTooLongJS
/**
 * Get parsed values from "byte map"
 * @param {ByteStream} stream Stream to parse data from
 * @param {Object} map Object with information how to parse "byte map"
 * @param {number} elements Number of elements in parsing byte map
 * @param {?number} [start=null] Start position to parse from
 * @param {?number} [length=null] Length of byte block to parse from
 * @returns {*}
 */
function parseByteMap(stream, map, elements, start = null, length = null)
{
	/*
	 Map example:
	 
	 let map = [
	 {
	 type: "string",
	 name: "type",
	 minlength: 1,
	 maxlength: 1,
	 func: function(array)
	 {
	 let result = {
	 status: (-1),
	 length: 1
	 };
	 
	 switch(array[0])
	 {
	 case 0x6E: // "n"
	 result.value = "n";
	 break;
	 case 0x66: // "f"
	 result.value = "f";
	 break;
	 default:
	 return result;
	 }
	 
	 result.status = 1;
	 
	 return result;
	 }
	 },
	 {
	 type: "check",
	 minlength: 1,
	 maxlength: 2,
	 func: function(array)
	 {
	 let position = (-1);
	 
	 if(array[0] == 0x0A)
	 position = 1;
	 if(array[1] == 0x0A)
	 position = 2;
	 
	 return {
	 status: (position > 0) ? 1 : (-1),
	 length: position
	 };
	 }
	 }
	 ];
	 */
	
	//region Initial variables
	// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
	if(start === null)
	{
		// noinspection AssignmentToFunctionParameterJS
		start = 0;
	}
	
	// noinspection NonBlockStatementBodyJS
	if(start > (stream.buffer.byteLength - 1))
		return false;
	
	// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
	if(length === null)
	{
		// noinspection AssignmentToFunctionParameterJS
		length = stream.buffer.byteLength - start;
	}
	
	if(length > (stream.buffer.byteLength - start))
	{
		// noinspection AssignmentToFunctionParameterJS
		length = stream.buffer.byteLength - start;
	}
	
	let dataView;
	
	// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
	if((start == 0) && (length == stream.buffer.byteLength))
		dataView = stream.view;
	else
		dataView = new Uint8Array(stream.buffer, start, length);
	
	const resultArray = new Array(elements);
	let elementsCount = 0;
	
	let count = 0;
	const mapLength = map.length;
	//endregion
	
	//region Parse all byte, structure by structure
	while(count < length)
	{
		let structureLength = 0;
		
		resultArray[elementsCount] = {};
		
		for(let i = 0; i < mapLength; i++)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, JSUnresolvedVariable, EqualityComparisonWithCoercionJS
			if(map[i].maxlength == 0)
			{
				// noinspection NonBlockStatementBodyJS
				if("defaultValue" in map[i])
					(resultArray[elementsCount])[map[i].name] = map[i].defaultValue;
				
				// noinspection ContinueStatementJS
				continue;
			}
			
			// noinspection JSUnresolvedVariable
			const array = new Array(map[i].maxlength);
			
			// noinspection JSUnresolvedVariable
			for(let j = 0; j < map[i].maxlength; j++)
			{
				// noinspection IncrementDecrementResultUsedJS
				array[j] = dataView[count++];
			}
			
			// noinspection JSUnresolvedVariable
			const result = (map[i].func)(array);
			// noinspection EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
			if(result.status == (-1))
			{
				// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS, EqualityComparisonWithCoercionJS
				if(resultArray.length == 1)
					return [];

				return resultArray.slice(0, resultArray.length - 1);
			}
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
			if(map[i].type != "check")
				(resultArray[elementsCount])[map[i].name] = result.value;
			
			// noinspection JSUnresolvedVariable
			count -= (map[i].maxlength - result.length);
			structureLength += result.length;
		}
		
		// noinspection IncrementDecrementResultUsedJS
		(resultArray[elementsCount++]).structureLength = structureLength;
	}
	//endregion
	
	return resultArray;
}
//**************************************************************************************
//region "Bits-to-string" array
const bitsToStringArray = [
	"00000000", "00000001", "00000010",
	"00000011", "00000100", "00000101",
	"00000110", "00000111", "00001000",
	"00001001", "00001010", "00001011",
	"00001100", "00001101", "00001110",
	"00001111", "00010000", "00010001",
	"00010010", "00010011", "00010100",
	"00010101", "00010110", "00010111",
	"00011000", "00011001", "00011010",
	"00011011", "00011100", "00011101",
	"00011110", "00011111", "00100000",
	"00100001", "00100010", "00100011",
	"00100100", "00100101", "00100110",
	"00100111", "00101000", "00101001",
	"00101010", "00101011", "00101100",
	"00101101", "00101110", "00101111",
	"00110000", "00110001", "00110010",
	"00110011", "00110100", "00110101",
	"00110110", "00110111", "00111000",
	"00111001", "00111010", "00111011",
	"00111100", "00111101", "00111110",
	"00111111", "01000000", "01000001",
	"01000010", "01000011", "01000100",
	"01000101", "01000110", "01000111",
	"01001000", "01001001", "01001010",
	"01001011", "01001100", "01001101",
	"01001110", "01001111", "01010000",
	"01010001", "01010010", "01010011",
	"01010100", "01010101", "01010110",
	"01010111", "01011000", "01011001",
	"01011010", "01011011", "01011100",
	"01011101", "01011110", "01011111",
	"01100000", "01100001", "01100010",
	"01100011", "01100100", "01100101",
	"01100110", "01100111", "01101000",
	"01101001", "01101010", "01101011",
	"01101100", "01101101", "01101110",
	"01101111", "01110000", "01110001",
	"01110010", "01110011", "01110100",
	"01110101", "01110110", "01110111",
	"01111000", "01111001", "01111010",
	"01111011", "01111100", "01111101",
	"01111110", "01111111", "10000000",
	"10000001", "10000010", "10000011",
	"10000100", "10000101", "10000110",
	"10000111", "10001000", "10001001",
	"10001010", "10001011", "10001100",
	"10001101", "10001110", "10001111",
	"10010000", "10010001", "10010010",
	"10010011", "10010100", "10010101",
	"10010110", "10010111", "10011000",
	"10011001", "10011010", "10011011",
	"10011100", "10011101", "10011110",
	"10011111", "10100000", "10100001",
	"10100010", "10100011", "10100100",
	"10100101", "10100110", "10100111",
	"10101000", "10101001", "10101010",
	"10101011", "10101100", "10101101",
	"10101110", "10101111", "10110000",
	"10110001", "10110010", "10110011",
	"10110100", "10110101", "10110110",
	"10110111", "10111000", "10111001",
	"10111010", "10111011", "10111100",
	"10111101", "10111110", "10111111",
	"11000000", "11000001", "11000010",
	"11000011", "11000100", "11000101",
	"11000110", "11000111", "11001000",
	"11001001", "11001010", "11001011",
	"11001100", "11001101", "11001110",
	"11001111", "11010000", "11010001",
	"11010010", "11010011", "11010100",
	"11010101", "11010110", "11010111",
	"11011000", "11011001", "11011010",
	"11011011", "11011100", "11011101",
	"11011110", "11011111", "11100000",
	"11100001", "11100010", "11100011",
	"11100100", "11100101", "11100110",
	"11100111", "11101000", "11101001",
	"11101010", "11101011", "11101100",
	"11101101", "11101110", "11101111",
	"11110000", "11110001", "11110010",
	"11110011", "11110100", "11110101",
	"11110110", "11110111", "11111000",
	"11111001", "11111010", "11111011",
	"11111100", "11111101", "11111110",
	"11111111"
];
//endregion
//**************************************************************************************
class BitStream
{
	//**********************************************************************************
	/**
	 * Constructor for "BitStream" class
	 * @param {{[byteStream]: ByteStream, [view]: Uint8Array, [buffer]: ArrayBuffer, [string]: string, [bitsCount]: number}} parameters
	 */
	constructor(parameters = {})
	{
		this.buffer = new ArrayBuffer(0);
		this.view = new Uint8Array(this.buffer);
		
		this.bitsCount = 0; // Number of bits stored in current "BitStream"
		
		for(const key of Object.keys(parameters))
		{
			switch(key)
			{
				case "byteStream":
					this.fromByteStream(parameters.byteStream);
					break;
				case "view":
					this.fromUint8Array(parameters.view);
					break;
				case "buffer":
					this.fromArrayBuffer(parameters.buffer);
					break;
				case "string":
					this.fromString(parameters.string);
					break;
				case "uint32":
					this.fromUint32(parameters.uint32);
					break;
				case "bitsCount":
					this.bitsCount = parameters.bitsCount;
					break;
				default:
			}
		}
	}
	//**********************************************************************************
	/**
	 * Clear existing stream
	 */
	clear()
	{
		this.buffer = new ArrayBuffer(0);
		this.view = new Uint8Array(this.buffer);
		
		this.bitsCount = 0;
	}
	//**********************************************************************************
	/**
	 * Initialize "BitStream" by data from existing "ByteStream"
	 * @param {ByteStream} stream
	 */
	fromByteStream(stream)
	{
		this.buffer = stream.buffer.slice(0);
		this.view = new Uint8Array(this.buffer);
		
		this.bitsCount = this.view.length << 3;
	}
	//**********************************************************************************
	/**
	 * Initialize "BitStream" object from existing "ArrayBuffer"
	 * @param {ArrayBuffer} array The ArrayBuffer to copy from
	 */
	fromArrayBuffer(array)
	{
		this.buffer = array.slice(0);
		this.view = new Uint8Array(this.buffer);
		
		this.bitsCount = this.view.length << 3;
	}
	//**********************************************************************************
	// noinspection FunctionNamingConventionJS
	/**
	 * Initialize "BitStream" object from existing "Uint8Array"
	 * @param {Uint8Array} array The Uint8Array to copy from
	 */
	fromUint8Array(array)
	{
		this.buffer = new ArrayBuffer(array.length);
		this.view = new Uint8Array(this.buffer);
		
		this.view.set(array);
		
		this.bitsCount = this.view.length << 3;
	}
	//**********************************************************************************
	/**
	 * Initialize "BitStream" object from existing bit string
	 * @param {string} string The string to initialize from
	 */
	fromString(string)
	{
		//region Initial variables
		const stringLength = string.length;
		
		// noinspection ConditionalExpressionJS
		this.buffer = new ArrayBuffer((stringLength >> 3) + ((stringLength % 8) ? 1 : 0));
		this.view = new Uint8Array(this.buffer);
		
		this.bitsCount = ((stringLength >> 3) + 1) << 3; // In order to handle correct shifting
		
		let byteIndex = 0;
		//endregion
		
		//region Convert from "bit string" to bytes
		for(let i = 0; i < stringLength; i++)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
			if(string[i] == "1")
				this.view[byteIndex] |= 1 << (7 - (i % 8));
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
			if(i && (((i + 1) % 8) == 0))
				byteIndex++;
		}
		//endregion
		
		//region Shift "BitStream" into correct position
		// noinspection NonBlockStatementBodyJS
		if(stringLength % 8)
			this.shiftRight(8 - (stringLength % 8));
		//endregion
		
		//region Change "bitsCount"
		this.bitsCount = stringLength;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Initialize "BitStream" object from existing uint32 number
	 * @param {Number} number The string to initialize from
	 */
	fromUint32(uint32)
	{
		this.buffer = new ArrayBuffer(4);
		this.view = new Uint8Array(this.buffer);

		const value = new Uint32Array([uint32]);
		const view = new Uint8Array(value.buffer);
		
		for(let i = 3; i >= 0; i--)
			this.view[i] = view[3 - i];

		this.bitsCount = 32;
	}
	//**********************************************************************************
	/**
	 * Represent "BitStream" object content as a string
	 * @param {?number} [start=null] Start number to convert to string from
	 * @param {?number} [length=null] Length of BitStream to convert to string
	 * @returns {string}
	 */
	toString(start = null, length = null)
	{
		//region Check input parameters
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((start >= this.view.length) || (start < 0))
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(length == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.view.length - start;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if((length >= this.view.length) || (length < 0))
		{
			// noinspection AssignmentToFunctionParameterJS
			length = this.view.length - start;
		}
		//endregion
		
		//region Initial variables
		const result = [];
		//endregion
		
		//region Convert from bytes to "bit string"
		// noinspection NonBlockStatementBodyJS
		for(let i = start; i < (start + length); i++)
			result.push(bitsToStringArray[this.view[i]]);
		//endregion
		
		// noinspection ChainedFunctionCallJS
		return result.join("").slice((this.view.length << 3) - this.bitsCount);
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Shift entire "BitStream" value right to number of bits
	 * @param {number} shift Number of bits to shift value
	 * @param {boolean} [needShrink=true] Need to shrink result or not
	 */
	shiftRight(shift, needShrink = true)
	{
		//region Check parameters
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
		if(this.view.length == 0)
			return;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if((shift < 0) || (shift > 8))
			throw new Error("The \"shift\" parameter must be in range 0-8");
		
		// noinspection NonBlockStatementBodyJS
		if(shift > this.bitsCount)
			throw new Error("The \"shift\" parameter can not be bigger than \"this.bitsCount\"");
		//endregion
		
		//region Initial variables
		// noinspection MagicNumberJS
		const shiftMask = 0xFF >> (8 - shift);
		this.view[this.view.length - 1] >>= shift;
		//endregion
		
		//region Shift value
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		for(let i = (this.view.length - 2); i >= 0; i--)
		{
			// noinspection NonShortCircuitBooleanExpressionJS
			this.view[i + 1] |= (this.view[i] & shiftMask) << (8 - shift);
			this.view[i] >>= shift;
		}
		//endregion
		
		//region Decrease number of bits stored into value
		this.bitsCount -= shift;
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
		if(this.bitsCount == 0)
			this.clear();
		//endregion
		
		//region Change stream size if needed
		// noinspection NonBlockStatementBodyJS
		if(needShrink)
			this.shrink();
		//endregion
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Shift entire "BitStream" value left to number of bits
	 * @param {number} shift Number of bits to shift value
	 */
	shiftLeft(shift)
	{
		/*
		 NOTE: We do not really shift value because of internal structure of "BitStream":
		 all bytes inside "BitStream" are aligned to right position. So, even if we will
		 really shift value to left after that we will need again shift it right to the
		 same number of bits. Thus all that we do here is hiding of left bits and descresing
		 the "bitsCount" number.
		 */
		
		//region Check parameters
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
		if(this.view.length == 0)
			return;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if((shift < 0) || (shift > 8))
			throw new Error("The \"shift\" parameter must be in range 0-8");
		
		// noinspection NonBlockStatementBodyJS
		if(shift > this.bitsCount)
			throw new Error("The \"shift\" parameter can not be bigger than \"this.bitsCount\"");
		//endregion
		
		//region Remove shifted bits
		// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
		const bitsOffset = this.bitsCount & 0x07;
		if(bitsOffset > shift)
		{
			// noinspection MagicNumberJS
			this.view[0] &= 0xFF >> (bitsOffset + shift);
		}
		else
		{
			//region Change size of buffer
			const buffer = new ArrayBuffer(this.buffer.byteLength - 1);
			const view = new Uint8Array(buffer);
			
			// noinspection NestedFunctionCallJS
			view.set(new Uint8Array(this.buffer, 1, this.buffer.byteLength - 1));
			//endregion
			
			//region Mask item with index 0
			// noinspection MagicNumberJS
			view[0] &= 0xFF >> (shift - bitsOffset);
			//endregion
			
			//region Store final array into current stream
			this.buffer = buffer.slice(0);
			this.view = new Uint8Array(this.buffer);
			//endregion
		}
		//endregion
		
		//region Decrease number of bits stored into value
		this.bitsCount -= shift;
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
		if(this.bitsCount == 0)
			this.clear();
		//endregion
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS, FunctionTooLongJS
	/**
	 * Return slice of existing "BitStream"
	 * @param {?number} [start=null] Start position of the slice (in bits)
	 * @param {?number} [end=null] End position of the slice (in bits)
	 * @returns {BitStream}
	 */
	slice(start = null, end = null)
	{
		//region Make ability to pass non-value bits
		let valueShift = 0;
		// noinspection NonBlockStatementBodyJS
		if(this.bitsCount % 8)
			valueShift = (8 - (this.bitsCount % 8));
		
		// noinspection AssignmentToFunctionParameterJS
		start += valueShift;
		// noinspection AssignmentToFunctionParameterJS
		end += valueShift;
		//endregion
		
		//region Initial variables
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(start == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			start = 0;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if((start < 0) || (start > ((this.view.length << 3) - 1)))
			return new BitStream(); //("Wrong start position: " + start);
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(end == null)
		{
			// noinspection AssignmentToFunctionParameterJS
			end = (this.view.length << 3) - 1;
		}
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if((end < 0) || (end > ((this.view.length << 3) - 1)))
			return new BitStream(); //("Wrong end position: " + end);
		
		// noinspection NonBlockStatementBodyJS
		if((end - start + 1) > this.bitsCount)
			return new BitStream(); //("Maximum length is " + this.bitsCount);
		
		const startIndex = start >> 3;
		// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
		const startOffset = start & 0x07;
		
		const endIndex = end >> 3;
		// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
		const endOffset = end & 0x07;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS
		const bitsLength = ((endIndex - startIndex) == 0) ? 1 : (endIndex - startIndex + 1);
		
		const result = new BitStream();
		//endregion
		
		//region Store "primary bytes"
		result.buffer = new ArrayBuffer(bitsLength);
		result.view = new Uint8Array(result.buffer);
		result.bitsCount = bitsLength << 3;
		
		// noinspection NestedFunctionCallJS
		result.view.set(new Uint8Array(this.buffer, startIndex, bitsLength));
		//endregion
		
		//region Change "start byte"
		// noinspection MagicNumberJS
		result.view[0] &= (0xFF >> startOffset);
		//endregion
		
		//region Change "end byte"
		// noinspection MagicNumberJS
		result.view[bitsLength] &= (0xFF << (7 - endOffset));
		//endregion
		
		//region Shift result array to right
		// noinspection NonBlockStatementBodyJS
		if(7 - endOffset)
			result.shiftRight(7 - endOffset, false);
		//endregion
		
		//region Set final number of bits
		result.bitsCount = (end - start + 1);
		//endregion
		
		//region Cut unnecessary bytes from result
		result.shrink();
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	/**
	 * Return copy of existing "BitStream"
	 * @param {?number} [start=null] Start position of the copy (in bits)
	 * @param {?number} [length=null] Length of the copy (in bits)
	 * @returns {BitStream}
	 */
	copy(start = null, length = null)
	{
		//region Check input parameters
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if((start < 0) || (start > ((this.view.length << 3) - 1)))
			return new BitStream(); //("Wrong start position: " + start);
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS
		if(length === null)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = (this.view.length << 3) - start - 1;
		}
		
		// noinspection NonBlockStatementBodyJS
		if(length > this.bitsCount)
			return new BitStream(); //("Maximum length is " + this.bitsCount);
		//endregion
		
		return this.slice(start, start + length - 1);
	}
	//**********************************************************************************
	/**
	 * Shrink unnecessary bytes in current stream accordingly to "bitsCount" value
	 */
	shrink()
	{
		// noinspection ConditionalExpressionJS
		const currentLength = (this.bitsCount >> 3) + ((this.bitsCount % 8) ? 1 : 0);
		if(currentLength < this.buffer.byteLength)
		{
			//region Change size of buffer
			const buffer = new ArrayBuffer(currentLength);
			const view = new Uint8Array(buffer);
			
			// noinspection NestedFunctionCallJS
			view.set(new Uint8Array(this.buffer, this.buffer.byteLength - currentLength, currentLength));
			//endregion
			
			//region Store final array into current stream
			this.buffer = buffer.slice(0);
			this.view = new Uint8Array(this.buffer);
			//endregion
		}
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Reverse bits order in each byte in the stream
	 * Got it from here: http://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith32Bits
	 */
	reverseBytes()
	{
		//region Reverse bits order in each byte in the stream
		for(let i = 0; i < this.view.length; i++)
		{
			// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
			this.view[i] = ((this.view[i] * 0x0802 & 0x22110) | (this.view[i] * 0x8020 & 0x88440)) * 0x10101 >> 16;
		}
		//endregion
		
		//region Shift "most significant" byte
		if(this.bitsCount % 8)
		{
			// noinspection ConditionalExpressionJS
			const currentLength = (this.bitsCount >> 3) + ((this.bitsCount % 8) ? 1 : 0);
			// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
			this.view[this.view.length - currentLength] >>= (8 - (this.bitsCount & 0x07));
		}
		//endregion
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Reverse all bits in entire "BitStream"
	 */
	reverseValue()
	{
		const initialValue = this.toString();
		const initialValueLength = initialValue.length;
		
		const reversedValue = new Array(initialValueLength);
		
		// noinspection NonBlockStatementBodyJS
		for(let i = 0; i < initialValueLength; i++)
			reversedValue[initialValueLength - 1 - i] = initialValue[i];
		
		// noinspection NestedFunctionCallJS
		this.fromString(reversedValue.join(""));
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Trying to represent entire "BitStream" as an unsigned integer.
	 * @return {number}
	 */
	getNumberValue()
	{
		//region Initial variables
		const byteLength = (this.buffer.byteLength - 1);
		//endregion
		
		//region Check posibility for convertion
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		if(byteLength > 3)
			return (-1);
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
		if(byteLength == (-1))
			return 0;
		//endregion
		
		//region Convert byte array to "Uint32Array" value
		const value = new Uint32Array(1);
		const view = new Uint8Array(value.buffer);
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, NonBlockStatementBodyJS
		for(let i = byteLength; i >= 0; i--)
			view[byteLength - i] = this.view[i];
		//endregion
		
		return value[0];
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find any bit pattern in "BitStream"
	 * @param {BitStream} pattern Stream having pattern value
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {number}
	 */
	findPattern(pattern, start = null, length = null, backward = false)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		const stringPattern = new ByteStream({
			string: pattern.toString()
		});
		//endregion
		
		return stringStream.findPattern(stringPattern, start, length, backward);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find first position of any pattern from input array
	 * @param {Array.<BitStream>} patterns Array with patterns which should be found
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {{id: number, position: number}}
	 */
	findFirstIn(patterns, start = null, length = null, backward = false)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		
		const stringPatterns = new Array(patterns.length);
		
		for(let i = 0; i < patterns.length; i++)
		{
			stringPatterns[i] = new ByteStream({
				string: patterns[i].toString()
			});
		}
		//endregion
		
		return stringStream.findFirstIn(stringPatterns, start, length, backward);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find all positions of any pattern from input array
	 * @param {Array.<BitStream>} patterns Array with patterns which should be found
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @returns {Array}
	 */
	findAllIn(patterns, start = null, length = null)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		
		const stringPatterns = new Array(patterns.length);
		
		for(let i = 0; i < patterns.length; i++)
		{
			stringPatterns[i] = new ByteStream({
				string: patterns[i].toString()
			});
		}
		//endregion
		
		return stringStream.findAllIn(stringPatterns, start, length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find all positions of a pattern
	 * @param {BitStream} pattern Stream having pattern value
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @returns {Array|number}
	 */
	findAllPatternIn(pattern, start = null, length = null)
	{
		//region Convert "BitStream" values to "ByteStream" 
		const stringStream = new ByteStream({
			string: this.toString()
		});
		const stringPattern = new ByteStream({
			string: pattern.toString()
		});
		//endregion 
		
		return stringStream.findAllPatternIn(stringPattern, start, length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find first position of data, not included in patterns from input array
	 * @param {Array.<BitStream>} patterns Array with patterns which should be found
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {{left: {id: number, position: *}, right: {id: number, position: number}, value: ByteStream}}
	 */
	findFirstNotIn(patterns, start = null, length = null, backward = false)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		
		const stringPatterns = new Array(patterns.length);
		
		for(let i = 0; i < patterns.length; i++)
		{
			stringPatterns[i] = new ByteStream({
				string: patterns[i].toString()
			});
		}
		//endregion
		
		return stringStream.findFirstNotIn(stringPatterns, start, length, backward);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find all positions of data, not included in patterns from input array
	 * @param {Array.<BitStream>} patterns Array with patterns which should be found
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @returns {Array}
	 */
	findAllNotIn(patterns, start = null, length = null)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		
		const stringPatterns = new Array(patterns.length);
		
		for(let i = 0; i < patterns.length; i++)
		{
			stringPatterns[i] = new ByteStream({
				string: patterns[i].toString()
			});
		}
		//endregion
		
		return stringStream.findAllNotIn(stringPatterns, start, length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find position of a sequence of any patterns from input array
	 * @param {Array.<BitStream>} patterns Array with patterns which should be found
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {{position, value}|*}
	 */
	findFirstSequence(patterns, start = null, length = null, backward = false)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		
		const stringPatterns = new Array(patterns.length);
		
		for(let i = 0; i < patterns.length; i++)
		{
			stringPatterns[i] = new ByteStream({
				string: patterns[i].toString()
			});
		}
		//endregion
		
		return stringStream.findFirstSequence(stringPatterns, start, length, backward);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find position of a sequence of any patterns from input array
	 * @param {Array.<BitStream>} patterns Array with patterns which should be found
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @returns {Array}
	 */
	findAllSequences(patterns, start, length)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		
		const stringPatterns = new Array(patterns.length);
		
		for(let i = 0; i < patterns.length; i++)
		{
			stringPatterns[i] = new ByteStream({
				string: patterns[i].toString()
			});
		}
		//endregion
		
		return stringStream.findAllSequences(stringPatterns, start, length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Find all paired patterns in the stream
	 * @param {BitStream} leftPattern Left pattern to search for
	 * @param {BitStream} rightPattern Right pattern to search for
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @returns {Array}
	 */
	findPairedPatterns(leftPattern, rightPattern, start = null, length = null)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		const stringLeftPattern = new ByteStream({
			string: leftPattern.toString()
		});
		const stringRightPattern = new ByteStream({
			string: rightPattern.toString()
		});
		//endregion
		
		return stringStream.findPairedPatterns(stringLeftPattern, stringRightPattern, start, length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleLoopsJS
	/**
	 * Find all paired patterns in the stream
	 * @param {Array.<BitStream>} inputLeftPatterns Array of left patterns to search for
	 * @param {Array.<BitStream>} inputRightPatterns Array of right patterns to search for
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @returns {Array}
	 */
	findPairedArrays(inputLeftPatterns, inputRightPatterns, start = null, length = null)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		
		const stringLeftPatterns = new Array(inputLeftPatterns.length);
		
		for(let i = 0; i < inputLeftPatterns.length; i++)
		{
			stringLeftPatterns[i] = new ByteStream({
				string: inputLeftPatterns[i].toString()
			});
		}
		
		const stringRightPatterns = new Array(inputRightPatterns.length);
		
		for(let i = 0; i < inputRightPatterns.length; i++)
		{
			stringRightPatterns[i] = new ByteStream({
				string: inputRightPatterns[i].toString()
			});
		}
		//endregion
		
		return stringStream.findPairedArrays(stringLeftPatterns, stringRightPatterns, start, length);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleReturnPointsJS
	/**
	 * Replace one pattern with other
	 * @param {BitStream} searchPattern The pattern to search for
	 * @param {BitStream} replacePattern The pattern to replace initial pattern
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @returns {boolean}
	 */
	replacePattern(searchPattern, replacePattern, start = null, length = null)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		const stringSearchPattern = new ByteStream({
			string: searchPattern.toString()
		});
		const stringReplacePattern = new ByteStream({
			string: replacePattern.toString()
		});
		//endregion
		
		//region Re-initialize existing data
		if(stringStream.findPairedPatterns(stringSearchPattern, stringReplacePattern, start, length))
		{
			// noinspection NestedFunctionCallJS
			this.fromString(stringStream.toString());
			return true;
		}
		//endregion
		
		return false;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Skip any pattern from input array
	 * @param {Array.<BitStream>} patterns Array with patterns which should be ommited
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {*}
	 */
	skipPatterns(patterns, start, length, backward)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		
		const stringPatterns = new Array(patterns.length);
		
		for(let i = 0; i < patterns.length; i++)
		{
			stringPatterns[i] = new ByteStream({
				string: patterns[i].toString()
			});
		}
		//endregion
		
		return stringStream.skipPatterns(stringPatterns, start, length, backward);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Skip any pattern not from input array
	 * @param {Array.<BitStream>} patterns Array with patterns which should be ommited
	 * @param {?number} [start=null] Start position to search from
	 * @param {?number} [length=null] Length of byte block to search at
	 * @param {boolean} [backward=false] Flag to search in backward order
	 * @returns {number}
	 */
	skipNotPatterns(patterns, start, length, backward)
	{
		//region Convert "BitStream" values to "ByteStream"
		const stringStream = new ByteStream({
			string: this.toString()
		});
		
		const stringPatterns = new Array(patterns.length);
		
		for(let i = 0; i < patterns.length; i++)
		{
			stringPatterns[i] = new ByteStream({
				string: patterns[i].toString()
			});
		}
		//endregion
		
		return stringStream.skipNotPatterns(stringPatterns, start, length, backward);
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Append a new "BitStream" content to the current "BitStream"
	 * @param {BitStream} stream A new "stream" to append to current "stream"
	 */
	append(stream)
	{
		//region Initialize current stream with new data
		// noinspection NestedFunctionCallJS
		this.fromString([
			this.toString(),
			stream.toString()
		].join(""));
		//endregion
	}
	//**********************************************************************************
}
//**************************************************************************************
class SeqBitStream
{
	//**********************************************************************************
	constructor(parameters = {})
	{
		//region Internal variables
		this.stream = new BitStream();
		
		this._start = 0;
		this._length = this.stream.bitsCount;
		
		this.backward = false;
		
		this.appendBlock = 0;
		//endregion
		
		for(const key of Object.keys(parameters))
		{
			switch(key)
			{
				case "stream":
				case "start":
				case "length":
				case "backward":
				case "appendBlock":
					this[key] = parameters[key];
					break;
				default:
			}
		}
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	set start(value)
	{
		// noinspection NonBlockStatementBodyJS
		if(value > this.stream.bitsCount)
			return;
		
		// noinspection ConditionalExpressionJS
		this._length -= ((this.backward) ? (this._start - value) : (value - this._start));
		this._start = value;
		
		//region Initialization of "prev" internal variables
		// noinspection JSUnusedGlobalSymbols
		this.prevStart = this._start;
		// noinspection JSUnusedGlobalSymbols
		this.prevLength = this._length;
		//endregion
	}
	//**********************************************************************************
	get start()
	{
		return this._start;
	}
	//**********************************************************************************
	// noinspection FunctionWithMultipleReturnPointsJS
	set length(value)
	{
		// noinspection NonBlockStatementBodyJS
		if(value > this.stream.bitsCount)
			return;
		
		// noinspection JSUnusedGlobalSymbols
		this.prevLength = this._length;
		this._length = value;
	}
	//**********************************************************************************
	get length()
	{
		return this._length;
	}
	//**********************************************************************************
	set stream(value)
	{
		this._stream = value;
		
		// noinspection JSUnusedGlobalSymbols
		this.prevLength = this._length;
		this._length = value.bitsCount;
		
		// noinspection JSUnusedGlobalSymbols
		this.prevStart = this._start;
		// noinspection ConditionalExpressionJS
		this._start = (this.backward) ? this.length : 0;
	}
	//**********************************************************************************
	get stream()
	{
		return this._stream;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols
	/**
	 * Get next "length" bits from the stream
	 * @param {number} length Number of bits to read
	 * @returns {*}
	 */
	getBits(length)
	{
		//region Check input parameters 
		if((this.start + length) > this.stream.bitsCount)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = (this.stream.bitsCount - this.start);
		}
		//endregion 
		
		//region Initial variables 
		let result;
		//endregion 
		
		//region Copy necessary length of bits
		if(this.backward)
		{
			result = this.stream.copy(this.start - length, length);
			this.start -= result.bitsCount;
		}
		else
		{
			result = this.stream.copy(this.start, length);
			this.start += result.bitsCount;
		}
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection FunctionTooLongJS
	/**
	 * Get string representation for the next "length" bits from the stream
	 * @param {number} length Number of bits to read
	 * @returns {string}
	 */
	getBitsString(length)
	{
		//region Check input parameters
		if((this.start + length) > this.stream.bitsCount)
		{
			// noinspection AssignmentToFunctionParameterJS
			length = (this.stream.bitsCount - this.start);
		}
		//endregion
		
		//region Initial variables
		let result = [];
		
		let start;
		
		// noinspection NonBlockStatementBodyJS
		if(this.backward)
			start = this.start - length;
		else
			start = this.start;
		
		let end = this.start + length - 1;
		
		//region Make ability to pass non-value bits
		let valueShift = 0;
		// noinspection NonBlockStatementBodyJS
		if(this.stream.bitsCount % 8)
			valueShift = (8 - (this.stream.bitsCount % 8));
		
		start += valueShift;
		end += valueShift;
		//endregion
		
		const startIndex = start >> 3;
		// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
		const startOffset = start & 0x07;
		
		const endIndex = end >> 3;
		// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS
		const endOffset = end & 0x07;
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, ConditionalExpressionJS, EqualityComparisonWithCoercionJS
		const bitsLengthIndex = startIndex + (((endIndex - startIndex) == 0) ? 1 : (endIndex - startIndex + 1));
		//endregion
		
		//region Get string representation of bits
		for(let i = startIndex; i < bitsLengthIndex; i++)
		{
			let value = bitsToStringArray[this.stream.view[i]];
			
			// noinspection EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
			if(i == startIndex)
				value = value.slice(startOffset);
			
			// noinspection EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
			if(i == (bitsLengthIndex - 1))
				value = value.slice(0, endOffset - 7 + value.length);
			
			result.push(value);
		}
		
		result = result.join("");
		//endregion
		
		//region Change internal values
		// noinspection NonBlockStatementBodyJS
		if(this.backward)
			this.start -= result.length;
		else
			this.start += result.length;
		//endregion
		
		return result;
	}
	//**********************************************************************************
	// noinspection JSUnusedGlobalSymbols, FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS
	/**
	 * Get number value representation of the next "length" bits from the stream, preliminary reversed
	 * @param {number} length Number of bits to read
	 * @returns {*}
	 */
	getBitsReversedValue(length)
	{
		//region Initial variables 
		const initialValue = this.getBitsString(length);
		const initialValueLength = initialValue.length;
		
		let byteIndex;
		
		const initialOffset = 8 - (initialValueLength % 8);
		
		const reversedValue = new Array(initialValueLength);
		
		const value = new Uint32Array(1);
		const valueView = new Uint8Array(value.buffer, 0, 4);
		
		let i;

		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, MagicNumberJS, NonBlockStatementBodyJS
		if(initialValueLength > 32)
			return (-1);
		
		// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, MagicNumberJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
		if(length == 32)
			byteIndex = 3;
		else
			byteIndex = ((initialValueLength - 1) >> 3);
		//endregion
		
		//region Reverse value 
		// noinspection NonBlockStatementBodyJS
		for(i = 0; i < initialValueLength; i++)
			reversedValue[initialValueLength - 1 - i] = initialValue[i];
		//endregion 
		
		//region Convert byte array to "Uint32Array" value 
		for(i = initialOffset; i < (initialOffset + initialValueLength); i++)
		{
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS
			if(reversedValue[i - initialOffset] == "1")
			{
				// noinspection MagicNumberJS
				valueView[byteIndex] |= 0x01 << (7 - (i % 8));
			}
			
			// noinspection ConstantOnRightSideOfComparisonJS, ConstantOnLeftSideOfComparisonJS, EqualityComparisonWithCoercionJS, NonBlockStatementBodyJS
			if(i && (((i + 1) % 8) == 0))
				byteIndex--;
		}
		//endregion 
		
		return value[0];
	}
	//**********************************************************************************
	/**
	 * Represent remaining bits in "BitStream" as a string
	 * @return {string}
	 */
	toString()
	{
		const streamToDisplay = this.stream.copy(this.start, this.length);
		return streamToDisplay.toString();
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars.runtime.js":
/*!****************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars.runtime.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = __webpack_require__(/*! ./handlebars/base */ "./node_modules/handlebars/dist/cjs/handlebars/base.js");

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = __webpack_require__(/*! ./handlebars/safe-string */ "./node_modules/handlebars/dist/cjs/handlebars/safe-string.js");

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = __webpack_require__(/*! ./handlebars/exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = __webpack_require__(/*! ./handlebars/utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = __webpack_require__(/*! ./handlebars/runtime */ "./node_modules/handlebars/dist/cjs/handlebars/runtime.js");

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = __webpack_require__(/*! ./handlebars/no-conflict */ "./node_modules/handlebars/dist/cjs/handlebars/no-conflict.js");

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9oYW5kbGViYXJzLnJ1bnRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OEJBQXNCLG1CQUFtQjs7SUFBN0IsSUFBSTs7Ozs7b0NBSU8sMEJBQTBCOzs7O21DQUMzQix3QkFBd0I7Ozs7K0JBQ3ZCLG9CQUFvQjs7SUFBL0IsS0FBSzs7aUNBQ1Esc0JBQXNCOztJQUFuQyxPQUFPOztvQ0FFSSwwQkFBMEI7Ozs7O0FBR2pELFNBQVMsTUFBTSxHQUFHO0FBQ2hCLE1BQUksRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7O0FBRTFDLE9BQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZCLElBQUUsQ0FBQyxVQUFVLG9DQUFhLENBQUM7QUFDM0IsSUFBRSxDQUFDLFNBQVMsbUNBQVksQ0FBQztBQUN6QixJQUFFLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNqQixJQUFFLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDOztBQUU3QyxJQUFFLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQztBQUNoQixJQUFFLENBQUMsUUFBUSxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQzNCLFdBQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDbkMsQ0FBQzs7QUFFRixTQUFPLEVBQUUsQ0FBQztDQUNYOztBQUVELElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRSxDQUFDO0FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOztBQUVyQixrQ0FBVyxJQUFJLENBQUMsQ0FBQzs7QUFFakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQzs7cUJBRVIsSUFBSSIsImZpbGUiOiJoYW5kbGViYXJzLnJ1bnRpbWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vaGFuZGxlYmFycy9iYXNlJztcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcbmltcG9ydCBTYWZlU3RyaW5nIGZyb20gJy4vaGFuZGxlYmFycy9zYWZlLXN0cmluZyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vaGFuZGxlYmFycy9leGNlcHRpb24nO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi9oYW5kbGViYXJzL3V0aWxzJztcbmltcG9ydCAqIGFzIHJ1bnRpbWUgZnJvbSAnLi9oYW5kbGViYXJzL3J1bnRpbWUnO1xuXG5pbXBvcnQgbm9Db25mbGljdCBmcm9tICcuL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QnO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IFNhZmVTdHJpbmc7XG4gIGhiLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgaGIuVXRpbHMgPSBVdGlscztcbiAgaGIuZXNjYXBlRXhwcmVzc2lvbiA9IFV0aWxzLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgaGIuVk0gPSBydW50aW1lO1xuICBoYi50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XG4gIH07XG5cbiAgcmV0dXJuIGhiO1xufVxuXG5sZXQgaW5zdCA9IGNyZWF0ZSgpO1xuaW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cbm5vQ29uZmxpY3QoaW5zdCk7XG5cbmluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3Q7XG4iXX0=


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/base.js":
/*!*************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/base.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = __webpack_require__(/*! ./utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

var _exception = __webpack_require__(/*! ./exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");

var _exception2 = _interopRequireDefault(_exception);

var _helpers = __webpack_require__(/*! ./helpers */ "./node_modules/handlebars/dist/cjs/handlebars/helpers.js");

var _decorators = __webpack_require__(/*! ./decorators */ "./node_modules/handlebars/dist/cjs/handlebars/decorators.js");

var _logger = __webpack_require__(/*! ./logger */ "./node_modules/handlebars/dist/cjs/handlebars/logger.js");

var _logger2 = _interopRequireDefault(_logger);

var _internalProtoAccess = __webpack_require__(/*! ./internal/proto-access */ "./node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js");

var VERSION = '4.7.7';
exports.VERSION = VERSION;
var COMPILER_REVISION = 8;
exports.COMPILER_REVISION = COMPILER_REVISION;
var LAST_COMPATIBLE_COMPILER_REVISION = 7;

exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0 <4.3.0',
  8: '>= 4.3.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  },
  /**
   * Reset the memory of illegal property accesses that have already been logged.
   * @deprecated should only be used in handlebars test-cases
   */
  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
    _internalProtoAccess.resetLoggedProperties();
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2Jhc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cUJBQThDLFNBQVM7O3lCQUNqQyxhQUFhOzs7O3VCQUNJLFdBQVc7OzBCQUNSLGNBQWM7O3NCQUNyQyxVQUFVOzs7O21DQUNTLHlCQUF5Qjs7QUFFeEQsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDOztBQUN4QixJQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQzs7QUFDNUIsSUFBTSxpQ0FBaUMsR0FBRyxDQUFDLENBQUM7OztBQUU1QyxJQUFNLGdCQUFnQixHQUFHO0FBQzlCLEdBQUMsRUFBRSxhQUFhO0FBQ2hCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxVQUFVO0FBQ2IsR0FBQyxFQUFFLGtCQUFrQjtBQUNyQixHQUFDLEVBQUUsaUJBQWlCO0FBQ3BCLEdBQUMsRUFBRSxpQkFBaUI7QUFDcEIsR0FBQyxFQUFFLFVBQVU7Q0FDZCxDQUFDOzs7QUFFRixJQUFNLFVBQVUsR0FBRyxpQkFBaUIsQ0FBQzs7QUFFOUIsU0FBUyxxQkFBcUIsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRTtBQUNuRSxNQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7QUFDN0IsTUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLElBQUksRUFBRSxDQUFDO0FBQy9CLE1BQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxJQUFJLEVBQUUsQ0FBQzs7QUFFbkMsa0NBQXVCLElBQUksQ0FBQyxDQUFDO0FBQzdCLHdDQUEwQixJQUFJLENBQUMsQ0FBQztDQUNqQzs7QUFFRCxxQkFBcUIsQ0FBQyxTQUFTLEdBQUc7QUFDaEMsYUFBVyxFQUFFLHFCQUFxQjs7QUFFbEMsUUFBTSxxQkFBUTtBQUNkLEtBQUcsRUFBRSxvQkFBTyxHQUFHOztBQUVmLGdCQUFjLEVBQUUsd0JBQVMsSUFBSSxFQUFFLEVBQUUsRUFBRTtBQUNqQyxRQUFJLGdCQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDdEMsVUFBSSxFQUFFLEVBQUU7QUFDTixjQUFNLDJCQUFjLHlDQUF5QyxDQUFDLENBQUM7T0FDaEU7QUFDRCxvQkFBTyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzVCLE1BQU07QUFDTCxVQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUN6QjtHQUNGO0FBQ0Qsa0JBQWdCLEVBQUUsMEJBQVMsSUFBSSxFQUFFO0FBQy9CLFdBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUMzQjs7QUFFRCxpQkFBZSxFQUFFLHlCQUFTLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDdkMsUUFBSSxnQkFBUyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3RDLG9CQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDN0IsTUFBTTtBQUNMLFVBQUksT0FBTyxPQUFPLEtBQUssV0FBVyxFQUFFO0FBQ2xDLGNBQU0seUVBQ3dDLElBQUksb0JBQ2pELENBQUM7T0FDSDtBQUNELFVBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDO0tBQy9CO0dBQ0Y7QUFDRCxtQkFBaUIsRUFBRSwyQkFBUyxJQUFJLEVBQUU7QUFDaEMsV0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQzVCOztBQUVELG1CQUFpQixFQUFFLDJCQUFTLElBQUksRUFBRSxFQUFFLEVBQUU7QUFDcEMsUUFBSSxnQkFBUyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3RDLFVBQUksRUFBRSxFQUFFO0FBQ04sY0FBTSwyQkFBYyw0Q0FBNEMsQ0FBQyxDQUFDO09BQ25FO0FBQ0Qsb0JBQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztLQUMvQixNQUFNO0FBQ0wsVUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDNUI7R0FDRjtBQUNELHFCQUFtQixFQUFFLDZCQUFTLElBQUksRUFBRTtBQUNsQyxXQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDOUI7Ozs7O0FBS0QsNkJBQTJCLEVBQUEsdUNBQUc7QUFDNUIsZ0RBQXVCLENBQUM7R0FDekI7Q0FDRixDQUFDOztBQUVLLElBQUksR0FBRyxHQUFHLG9CQUFPLEdBQUcsQ0FBQzs7O1FBRW5CLFdBQVc7UUFBRSxNQUFNIiwiZmlsZSI6ImJhc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVGcmFtZSwgZXh0ZW5kLCB0b1N0cmluZyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2V4Y2VwdGlvbic7XG5pbXBvcnQgeyByZWdpc3RlckRlZmF1bHRIZWxwZXJzIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnMgfSBmcm9tICcuL2RlY29yYXRvcnMnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyByZXNldExvZ2dlZFByb3BlcnRpZXMgfSBmcm9tICcuL2ludGVybmFsL3Byb3RvLWFjY2Vzcyc7XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuNy43JztcbmV4cG9ydCBjb25zdCBDT01QSUxFUl9SRVZJU0lPTiA9IDg7XG5leHBvcnQgY29uc3QgTEFTVF9DT01QQVRJQkxFX0NPTVBJTEVSX1JFVklTSU9OID0gNztcblxuZXhwb3J0IGNvbnN0IFJFVklTSU9OX0NIQU5HRVMgPSB7XG4gIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XG4gIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgMzogJz09IDEuMC4wLXJjLjQnLFxuICA0OiAnPT0gMS54LngnLFxuICA1OiAnPT0gMi4wLjAtYWxwaGEueCcsXG4gIDY6ICc+PSAyLjAuMC1iZXRhLjEnLFxuICA3OiAnPj0gNC4wLjAgPDQuMy4wJyxcbiAgODogJz49IDQuMy4wJ1xufTtcblxuY29uc3Qgb2JqZWN0VHlwZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG5leHBvcnQgZnVuY3Rpb24gSGFuZGxlYmFyc0Vudmlyb25tZW50KGhlbHBlcnMsIHBhcnRpYWxzLCBkZWNvcmF0b3JzKSB7XG4gIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XG4gIHRoaXMucGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcbiAgdGhpcy5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycyB8fCB7fTtcblxuICByZWdpc3RlckRlZmF1bHRIZWxwZXJzKHRoaXMpO1xuICByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKHRoaXMpO1xufVxuXG5IYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlYmFyc0Vudmlyb25tZW50LFxuXG4gIGxvZ2dlcjogbG9nZ2VyLFxuICBsb2c6IGxvZ2dlci5sb2csXG5cbiAgcmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGhlbHBlcnMnKTtcbiAgICAgIH1cbiAgICAgIGV4dGVuZCh0aGlzLmhlbHBlcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5oZWxwZXJzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSwgcGFydGlhbCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBleHRlbmQodGhpcy5wYXJ0aWFscywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydGlhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcbiAgICAgICAgICBgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIHBhcnRpYWwgY2FsbGVkIFwiJHtuYW1lfVwiIGFzIHVuZGVmaW5lZGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5wYXJ0aWFsc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgZGVjb3JhdG9ycycpO1xuICAgICAgfVxuICAgICAgZXh0ZW5kKHRoaXMuZGVjb3JhdG9ycywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjb3JhdG9yc1tuYW1lXSA9IGZuO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmRlY29yYXRvcnNbbmFtZV07XG4gIH0sXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgbWVtb3J5IG9mIGlsbGVnYWwgcHJvcGVydHkgYWNjZXNzZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBsb2dnZWQuXG4gICAqIEBkZXByZWNhdGVkIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gaGFuZGxlYmFycyB0ZXN0LWNhc2VzXG4gICAqL1xuICByZXNldExvZ2dlZFByb3BlcnR5QWNjZXNzZXMoKSB7XG4gICAgcmVzZXRMb2dnZWRQcm9wZXJ0aWVzKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBsZXQgbG9nID0gbG9nZ2VyLmxvZztcblxuZXhwb3J0IHsgY3JlYXRlRnJhbWUsIGxvZ2dlciB9O1xuIl19


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/decorators.js":
/*!*******************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/decorators.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = __webpack_require__(/*! ./decorators/inline */ "./node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js");

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Z0NBQTJCLHFCQUFxQjs7OztBQUV6QyxTQUFTLHlCQUF5QixDQUFDLFFBQVEsRUFBRTtBQUNsRCxnQ0FBZSxRQUFRLENBQUMsQ0FBQztDQUMxQiIsImZpbGUiOiJkZWNvcmF0b3JzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlZ2lzdGVySW5saW5lIGZyb20gJy4vZGVjb3JhdG9ycy9pbmxpbmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyhpbnN0YW5jZSkge1xuICByZWdpc3RlcklubGluZShpbnN0YW5jZSk7XG59XG4iXX0=


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js":
/*!**************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMvaW5saW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQXVCLFVBQVU7O3FCQUVsQixVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLFVBQVMsRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFO0FBQzNFLFFBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNiLFFBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFO0FBQ25CLFdBQUssQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLFNBQUcsR0FBRyxVQUFTLE9BQU8sRUFBRSxPQUFPLEVBQUU7O0FBRS9CLFlBQUksUUFBUSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUM7QUFDbEMsaUJBQVMsQ0FBQyxRQUFRLEdBQUcsY0FBTyxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMxRCxZQUFJLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQy9CLGlCQUFTLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUM5QixlQUFPLEdBQUcsQ0FBQztPQUNaLENBQUM7S0FDSDs7QUFFRCxTQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUU3QyxXQUFPLEdBQUcsQ0FBQztHQUNaLENBQUMsQ0FBQztDQUNKIiwiZmlsZSI6ImlubGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJEZWNvcmF0b3IoJ2lubGluZScsIGZ1bmN0aW9uKGZuLCBwcm9wcywgY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IHJldCA9IGZuO1xuICAgIGlmICghcHJvcHMucGFydGlhbHMpIHtcbiAgICAgIHByb3BzLnBhcnRpYWxzID0ge307XG4gICAgICByZXQgPSBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJ0aWFscyBzdGFjayBmcmFtZSBwcmlvciB0byBleGVjLlxuICAgICAgICBsZXQgb3JpZ2luYWwgPSBjb250YWluZXIucGFydGlhbHM7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGV4dGVuZCh7fSwgb3JpZ2luYWwsIHByb3BzLnBhcnRpYWxzKTtcbiAgICAgICAgbGV0IHJldCA9IGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcmlnaW5hbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcHJvcHMucGFydGlhbHNbb3B0aW9ucy5hcmdzWzBdXSA9IG9wdGlvbnMuZm47XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiJdfQ==


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/exception.js":
/*!******************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/exception.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      endLineNumber = undefined,
      column = undefined,
      endColumn = undefined;

  if (loc) {
    line = loc.start.line;
    endLineNumber = loc.end.line;
    column = loc.start.column;
    endColumn = loc.end.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;
      this.endLineNumber = endLineNumber;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
        Object.defineProperty(this, 'endColumn', {
          value: endColumn,
          enumerable: true
        });
      } else {
        this.column = column;
        this.endColumn = endColumn;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2V4Y2VwdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxJQUFNLFVBQVUsR0FBRyxDQUNqQixhQUFhLEVBQ2IsVUFBVSxFQUNWLFlBQVksRUFDWixlQUFlLEVBQ2YsU0FBUyxFQUNULE1BQU0sRUFDTixRQUFRLEVBQ1IsT0FBTyxDQUNSLENBQUM7O0FBRUYsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUNoQyxNQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUc7TUFDeEIsSUFBSSxZQUFBO01BQ0osYUFBYSxZQUFBO01BQ2IsTUFBTSxZQUFBO01BQ04sU0FBUyxZQUFBLENBQUM7O0FBRVosTUFBSSxHQUFHLEVBQUU7QUFDUCxRQUFJLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7QUFDdEIsaUJBQWEsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUM3QixVQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDMUIsYUFBUyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDOztBQUUzQixXQUFPLElBQUksS0FBSyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDO0dBQ3hDOztBQUVELE1BQUksR0FBRyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7OztBQUcxRCxPQUFLLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsRUFBRTtBQUNoRCxRQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0dBQzlDOzs7QUFHRCxNQUFJLEtBQUssQ0FBQyxpQkFBaUIsRUFBRTtBQUMzQixTQUFLLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQzFDOztBQUVELE1BQUk7QUFDRixRQUFJLEdBQUcsRUFBRTtBQUNQLFVBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3ZCLFVBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDOzs7O0FBSW5DLFVBQUksTUFBTSxDQUFDLGNBQWMsRUFBRTtBQUN6QixjQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUU7QUFDcEMsZUFBSyxFQUFFLE1BQU07QUFDYixvQkFBVSxFQUFFLElBQUk7U0FDakIsQ0FBQyxDQUFDO0FBQ0gsY0FBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBVyxFQUFFO0FBQ3ZDLGVBQUssRUFBRSxTQUFTO0FBQ2hCLG9CQUFVLEVBQUUsSUFBSTtTQUNqQixDQUFDLENBQUM7T0FDSixNQUFNO0FBQ0wsWUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDckIsWUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7T0FDNUI7S0FDRjtHQUNGLENBQUMsT0FBTyxHQUFHLEVBQUU7O0dBRWI7Q0FDRjs7QUFFRCxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7O3FCQUVuQixTQUFTIiwiZmlsZSI6ImV4Y2VwdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGVycm9yUHJvcHMgPSBbXG4gICdkZXNjcmlwdGlvbicsXG4gICdmaWxlTmFtZScsXG4gICdsaW5lTnVtYmVyJyxcbiAgJ2VuZExpbmVOdW1iZXInLFxuICAnbWVzc2FnZScsXG4gICduYW1lJyxcbiAgJ251bWJlcicsXG4gICdzdGFjaydcbl07XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIGxldCBsb2MgPSBub2RlICYmIG5vZGUubG9jLFxuICAgIGxpbmUsXG4gICAgZW5kTGluZU51bWJlcixcbiAgICBjb2x1bW4sXG4gICAgZW5kQ29sdW1uO1xuXG4gIGlmIChsb2MpIHtcbiAgICBsaW5lID0gbG9jLnN0YXJ0LmxpbmU7XG4gICAgZW5kTGluZU51bWJlciA9IGxvYy5lbmQubGluZTtcbiAgICBjb2x1bW4gPSBsb2Muc3RhcnQuY29sdW1uO1xuICAgIGVuZENvbHVtbiA9IGxvYy5lbmQuY29sdW1uO1xuXG4gICAgbWVzc2FnZSArPSAnIC0gJyArIGxpbmUgKyAnOicgKyBjb2x1bW47XG4gIH1cblxuICBsZXQgdG1wID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgLy8gVW5mb3J0dW5hdGVseSBlcnJvcnMgYXJlIG5vdCBlbnVtZXJhYmxlIGluIENocm9tZSAoYXQgbGVhc3QpLCBzbyBgZm9yIHByb3AgaW4gdG1wYCBkb2Vzbid0IHdvcmsuXG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGVycm9yUHJvcHMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXNbZXJyb3JQcm9wc1tpZHhdXSA9IHRtcFtlcnJvclByb3BzW2lkeF1dO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXhjZXB0aW9uKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGxvYykge1xuICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcbiAgICAgIHRoaXMuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XG5cbiAgICAgIC8vIFdvcmsgYXJvdW5kIGlzc3VlIHVuZGVyIHNhZmFyaSB3aGVyZSB3ZSBjYW4ndCBkaXJlY3RseSBzZXQgdGhlIGNvbHVtbiB2YWx1ZVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2x1bW4nLCB7XG4gICAgICAgICAgdmFsdWU6IGNvbHVtbixcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VuZENvbHVtbicsIHtcbiAgICAgICAgICB2YWx1ZTogZW5kQ29sdW1uLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSBlbmRDb2x1bW47XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChub3ApIHtcbiAgICAvKiBJZ25vcmUgaWYgdGhlIGJyb3dzZXIgaXMgdmVyeSBwYXJ0aWN1bGFyICovXG4gIH1cbn1cblxuRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBFeGNlcHRpb247XG4iXX0=


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers.js":
/*!****************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
exports.moveHelperToHooks = moveHelperToHooks;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = __webpack_require__(/*! ./helpers/block-helper-missing */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js");

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = __webpack_require__(/*! ./helpers/each */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/each.js");

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = __webpack_require__(/*! ./helpers/helper-missing */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js");

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = __webpack_require__(/*! ./helpers/if */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/if.js");

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = __webpack_require__(/*! ./helpers/log */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/log.js");

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = __webpack_require__(/*! ./helpers/lookup */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js");

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = __webpack_require__(/*! ./helpers/with */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/with.js");

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}

function moveHelperToHooks(instance, helperName, keepHelper) {
  if (instance.helpers[helperName]) {
    instance.hooks[helperName] = instance.helpers[helperName];
    if (!keepHelper) {
      delete instance.helpers[helperName];
    }
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3lDQUF1QyxnQ0FBZ0M7Ozs7MkJBQzlDLGdCQUFnQjs7OztvQ0FDUCwwQkFBMEI7Ozs7eUJBQ3JDLGNBQWM7Ozs7MEJBQ2IsZUFBZTs7Ozs2QkFDWixrQkFBa0I7Ozs7MkJBQ3BCLGdCQUFnQjs7OztBQUVsQyxTQUFTLHNCQUFzQixDQUFDLFFBQVEsRUFBRTtBQUMvQyx5Q0FBMkIsUUFBUSxDQUFDLENBQUM7QUFDckMsMkJBQWEsUUFBUSxDQUFDLENBQUM7QUFDdkIsb0NBQXNCLFFBQVEsQ0FBQyxDQUFDO0FBQ2hDLHlCQUFXLFFBQVEsQ0FBQyxDQUFDO0FBQ3JCLDBCQUFZLFFBQVEsQ0FBQyxDQUFDO0FBQ3RCLDZCQUFlLFFBQVEsQ0FBQyxDQUFDO0FBQ3pCLDJCQUFhLFFBQVEsQ0FBQyxDQUFDO0NBQ3hCOztBQUVNLFNBQVMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUU7QUFDbEUsTUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFO0FBQ2hDLFlBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUMxRCxRQUFJLENBQUMsVUFBVSxFQUFFO0FBQ2YsYUFBTyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQ3JDO0dBQ0Y7Q0FDRiIsImZpbGUiOiJoZWxwZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9ibG9jay1oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJFYWNoIGZyb20gJy4vaGVscGVycy9lYWNoJztcbmltcG9ydCByZWdpc3RlckhlbHBlck1pc3NpbmcgZnJvbSAnLi9oZWxwZXJzL2hlbHBlci1taXNzaW5nJztcbmltcG9ydCByZWdpc3RlcklmIGZyb20gJy4vaGVscGVycy9pZic7XG5pbXBvcnQgcmVnaXN0ZXJMb2cgZnJvbSAnLi9oZWxwZXJzL2xvZyc7XG5pbXBvcnQgcmVnaXN0ZXJMb29rdXAgZnJvbSAnLi9oZWxwZXJzL2xvb2t1cCc7XG5pbXBvcnQgcmVnaXN0ZXJXaXRoIGZyb20gJy4vaGVscGVycy93aXRoJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMoaW5zdGFuY2UpIHtcbiAgcmVnaXN0ZXJCbG9ja0hlbHBlck1pc3NpbmcoaW5zdGFuY2UpO1xuICByZWdpc3RlckVhY2goaW5zdGFuY2UpO1xuICByZWdpc3RlckhlbHBlck1pc3NpbmcoaW5zdGFuY2UpO1xuICByZWdpc3RlcklmKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb2coaW5zdGFuY2UpO1xuICByZWdpc3Rlckxvb2t1cChpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyV2l0aChpbnN0YW5jZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlSGVscGVyVG9Ib29rcyhpbnN0YW5jZSwgaGVscGVyTmFtZSwga2VlcEhlbHBlcikge1xuICBpZiAoaW5zdGFuY2UuaGVscGVyc1toZWxwZXJOYW1lXSkge1xuICAgIGluc3RhbmNlLmhvb2tzW2hlbHBlck5hbWVdID0gaW5zdGFuY2UuaGVscGVyc1toZWxwZXJOYW1lXTtcbiAgICBpZiAoIWtlZXBIZWxwZXIpIHtcbiAgICAgIGRlbGV0ZSBpbnN0YW5jZS5oZWxwZXJzW2hlbHBlck5hbWVdO1xuICAgIH1cbiAgfVxufVxuIl19


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztxQkFBd0QsVUFBVTs7cUJBRW5ELFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQW9CLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3ZFLFFBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPO1FBQzNCLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVsQixRQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7QUFDcEIsYUFBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakIsTUFBTSxJQUFJLE9BQU8sS0FBSyxLQUFLLElBQUksT0FBTyxJQUFJLElBQUksRUFBRTtBQUMvQyxhQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN0QixNQUFNLElBQUksZUFBUSxPQUFPLENBQUMsRUFBRTtBQUMzQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ3RCLFlBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGlCQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzlCOztBQUVELGVBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQ2hELE1BQU07QUFDTCxlQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUN0QjtLQUNGLE1BQU07QUFDTCxVQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixZQUFJLElBQUksR0FBRyxtQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDckMsWUFBSSxDQUFDLFdBQVcsR0FBRyx5QkFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQ3hCLE9BQU8sQ0FBQyxJQUFJLENBQ2IsQ0FBQztBQUNGLGVBQU8sR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQztPQUMxQjs7QUFFRCxhQUFPLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDN0I7R0FDRixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJibG9jay1oZWxwZXItbWlzc2luZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcGVuZENvbnRleHRQYXRoLCBjcmVhdGVGcmFtZSwgaXNBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgIGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmIChjb250ZXh0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZm4odGhpcyk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgICBvcHRpb25zLmlkcyA9IFtvcHRpb25zLm5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnMuZWFjaChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGxldCBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKFxuICAgICAgICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCxcbiAgICAgICAgICBvcHRpb25zLm5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgb3B0aW9ucyA9IHsgZGF0YTogZGF0YSB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cbiJdfQ==


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/each.js":
/*!*********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/each.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else if (global.Symbol && context[global.Symbol.iterator]) {
        var newContext = [];
        var iterator = context[global.Symbol.iterator]();
        for (var it = iterator.next(); !it.done; it = iterator.next()) {
          newContext.push(it.value);
        }
        context = newContext;
        for (var j = context.length; i < j; i++) {
          execIteration(i, i, i === context.length - 1);
        }
      } else {
        (function () {
          var priorKey = undefined;

          Object.keys(context).forEach(function (key) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          });
          if (priorKey !== undefined) {
            execIteration(priorKey, i - 1, true);
          }
        })();
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvZWFjaC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O3FCQU1PLFVBQVU7O3lCQUNLLGNBQWM7Ozs7cUJBRXJCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN6RCxRQUFJLENBQUMsT0FBTyxFQUFFO0FBQ1osWUFBTSwyQkFBYyw2QkFBNkIsQ0FBQyxDQUFDO0tBQ3BEOztBQUVELFFBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxFQUFFO1FBQ2pCLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTztRQUN6QixDQUFDLEdBQUcsQ0FBQztRQUNMLEdBQUcsR0FBRyxFQUFFO1FBQ1IsSUFBSSxZQUFBO1FBQ0osV0FBVyxZQUFBLENBQUM7O0FBRWQsUUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDL0IsaUJBQVcsR0FDVCx5QkFBa0IsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztLQUNyRTs7QUFFRCxRQUFJLGtCQUFXLE9BQU8sQ0FBQyxFQUFFO0FBQ3ZCLGFBQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzlCOztBQUVELFFBQUksT0FBTyxDQUFDLElBQUksRUFBRTtBQUNoQixVQUFJLEdBQUcsbUJBQVksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2xDOztBQUVELGFBQVMsYUFBYSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFO0FBQ3pDLFVBQUksSUFBSSxFQUFFO0FBQ1IsWUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUM7QUFDakIsWUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDbkIsWUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLEtBQUssQ0FBQyxDQUFDO0FBQ3pCLFlBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzs7QUFFbkIsWUFBSSxXQUFXLEVBQUU7QUFDZixjQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsR0FBRyxLQUFLLENBQUM7U0FDeEM7T0FDRjs7QUFFRCxTQUFHLEdBQ0QsR0FBRyxHQUNILEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDakIsWUFBSSxFQUFFLElBQUk7QUFDVixtQkFBVyxFQUFFLG1CQUNYLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUN2QixDQUFDLFdBQVcsR0FBRyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQzVCO09BQ0YsQ0FBQyxDQUFDO0tBQ047O0FBRUQsUUFBSSxPQUFPLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO0FBQzFDLFVBQUksZUFBUSxPQUFPLENBQUMsRUFBRTtBQUNwQixhQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN2QyxjQUFJLENBQUMsSUFBSSxPQUFPLEVBQUU7QUFDaEIseUJBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQy9DO1NBQ0Y7T0FDRixNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtBQUMzRCxZQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDdEIsWUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztBQUNuRCxhQUFLLElBQUksRUFBRSxHQUFHLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxHQUFHLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRTtBQUM3RCxvQkFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0I7QUFDRCxlQUFPLEdBQUcsVUFBVSxDQUFDO0FBQ3JCLGFBQUssSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3ZDLHVCQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztTQUMvQztPQUNGLE1BQU07O0FBQ0wsY0FBSSxRQUFRLFlBQUEsQ0FBQzs7QUFFYixnQkFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxHQUFHLEVBQUk7Ozs7QUFJbEMsZ0JBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQiwyQkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDaEM7QUFDRCxvQkFBUSxHQUFHLEdBQUcsQ0FBQztBQUNmLGFBQUMsRUFBRSxDQUFDO1dBQ0wsQ0FBQyxDQUFDO0FBQ0gsY0FBSSxRQUFRLEtBQUssU0FBUyxFQUFFO0FBQzFCLHlCQUFhLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7V0FDdEM7O09BQ0Y7S0FDRjs7QUFFRCxRQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDWCxTQUFHLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3JCOztBQUVELFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0oiLCJmaWxlIjoiZWFjaC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGFwcGVuZENvbnRleHRQYXRoLFxuICBibG9ja1BhcmFtcyxcbiAgY3JlYXRlRnJhbWUsXG4gIGlzQXJyYXksXG4gIGlzRnVuY3Rpb25cbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm4sXG4gICAgICBpbnZlcnNlID0gb3B0aW9ucy5pbnZlcnNlLFxuICAgICAgaSA9IDAsXG4gICAgICByZXQgPSAnJyxcbiAgICAgIGRhdGEsXG4gICAgICBjb250ZXh0UGF0aDtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgIGNvbnRleHRQYXRoID1cbiAgICAgICAgYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSkgKyAnLic7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY0l0ZXJhdGlvbihmaWVsZCwgaW5kZXgsIGxhc3QpIHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEua2V5ID0gZmllbGQ7XG4gICAgICAgIGRhdGEuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZGF0YS5maXJzdCA9IGluZGV4ID09PSAwO1xuICAgICAgICBkYXRhLmxhc3QgPSAhIWxhc3Q7XG5cbiAgICAgICAgaWYgKGNvbnRleHRQYXRoKSB7XG4gICAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGNvbnRleHRQYXRoICsgZmllbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0ID1cbiAgICAgICAgcmV0ICtcbiAgICAgICAgZm4oY29udGV4dFtmaWVsZF0sIHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhcbiAgICAgICAgICAgIFtjb250ZXh0W2ZpZWxkXSwgZmllbGRdLFxuICAgICAgICAgICAgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdXG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBjb250ZXh0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgIGlmIChpIGluIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24oaSwgaSwgaSA9PT0gY29udGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsLlN5bWJvbCAmJiBjb250ZXh0W2dsb2JhbC5TeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBjb250ZXh0W2dsb2JhbC5TeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGZvciAobGV0IGl0ID0gaXRlcmF0b3IubmV4dCgpOyAhaXQuZG9uZTsgaXQgPSBpdGVyYXRvci5uZXh0KCkpIHtcbiAgICAgICAgICBuZXdDb250ZXh0LnB1c2goaXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQgPSBuZXdDb250ZXh0O1xuICAgICAgICBmb3IgKGxldCBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcmlvcktleTtcblxuICAgICAgICBPYmplY3Qua2V5cyhjb250ZXh0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgLy8gV2UncmUgcnVubmluZyB0aGUgaXRlcmF0aW9ucyBvbmUgc3RlcCBvdXQgb2Ygc3luYyBzbyB3ZSBjYW4gZGV0ZWN0XG4gICAgICAgICAgLy8gdGhlIGxhc3QgaXRlcmF0aW9uIHdpdGhvdXQgaGF2ZSB0byBzY2FuIHRoZSBvYmplY3QgdHdpY2UgYW5kIGNyZWF0ZVxuICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJpb3JLZXkgPSBrZXk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiJdfQ==

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaGVscGVyLW1pc3NpbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozt5QkFBc0IsY0FBYzs7OztxQkFFckIsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQUUsaUNBQWdDO0FBQ3ZFLFFBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7O0FBRTFCLGFBQU8sU0FBUyxDQUFDO0tBQ2xCLE1BQU07O0FBRUwsWUFBTSwyQkFDSixtQkFBbUIsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUNqRSxDQUFDO0tBQ0g7R0FDRixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJoZWxwZXItbWlzc2luZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbigvKiBbYXJncywgXW9wdGlvbnMgKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXG4gICAgICAgICdNaXNzaW5nIGhlbHBlcjogXCInICsgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXS5uYW1lICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuIl19


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/if.js":
/*!*******************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/if.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (arguments.length != 2) {
      throw new _exception2['default']('#if requires exactly one argument');
    }
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    if (arguments.length != 2) {
      throw new _exception2['default']('#unless requires exactly one argument');
    }
    return instance.helpers['if'].call(this, conditional, {
      fn: options.inverse,
      inverse: options.fn,
      hash: options.hash
    });
  });
};

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaWYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztxQkFBb0MsVUFBVTs7eUJBQ3hCLGNBQWM7Ozs7cUJBRXJCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVMsV0FBVyxFQUFFLE9BQU8sRUFBRTtBQUMzRCxRQUFJLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO0FBQ3pCLFlBQU0sMkJBQWMsbUNBQW1DLENBQUMsQ0FBQztLQUMxRDtBQUNELFFBQUksa0JBQVcsV0FBVyxDQUFDLEVBQUU7QUFDM0IsaUJBQVcsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3RDOzs7OztBQUtELFFBQUksQUFBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxJQUFLLGVBQVEsV0FBVyxDQUFDLEVBQUU7QUFDdkUsYUFBTyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzlCLE1BQU07QUFDTCxhQUFPLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDekI7R0FDRixDQUFDLENBQUM7O0FBRUgsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxXQUFXLEVBQUUsT0FBTyxFQUFFO0FBQy9ELFFBQUksU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7QUFDekIsWUFBTSwyQkFBYyx1Q0FBdUMsQ0FBQyxDQUFDO0tBQzlEO0FBQ0QsV0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxFQUFFO0FBQ3BELFFBQUUsRUFBRSxPQUFPLENBQUMsT0FBTztBQUNuQixhQUFPLEVBQUUsT0FBTyxDQUFDLEVBQUU7QUFDbkIsVUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJO0tBQ25CLENBQUMsQ0FBQztHQUNKLENBQUMsQ0FBQztDQUNKIiwiZmlsZSI6ImlmLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNFbXB0eSwgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2lmJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCcjaWYgcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7XG4gICAgICBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxuICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgaXNFbXB0eS4gRWZmZWN0aXZlbHkgdGhpcyBkZXRlcm1pbmVzIGlmIDAgaXMgaGFuZGxlZCBieSB0aGUgcG9zaXRpdmUgcGF0aCBvciBuZWdhdGl2ZS5cbiAgICBpZiAoKCFvcHRpb25zLmhhc2guaW5jbHVkZVplcm8gJiYgIWNvbmRpdGlvbmFsKSB8fCBpc0VtcHR5KGNvbmRpdGlvbmFsKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcigndW5sZXNzJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCcjdW5sZXNzIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzWydpZiddLmNhbGwodGhpcywgY29uZGl0aW9uYWwsIHtcbiAgICAgIGZuOiBvcHRpb25zLmludmVyc2UsXG4gICAgICBpbnZlcnNlOiBvcHRpb25zLmZuLFxuICAgICAgaGFzaDogb3B0aW9ucy5oYXNoXG4gICAgfSk7XG4gIH0pO1xufVxuIl19


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/log.js":
/*!********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/log.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9nLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQWUsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsa0NBQWlDO0FBQzlELFFBQUksSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDO1FBQ3BCLE9BQU8sR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM1QyxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDN0MsVUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN6Qjs7QUFFRCxRQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDZCxRQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksRUFBRTtBQUM5QixXQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDNUIsTUFBTSxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO0FBQ3JELFdBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUM1QjtBQUNELFFBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7O0FBRWhCLFlBQVEsQ0FBQyxHQUFHLE1BQUEsQ0FBWixRQUFRLEVBQVEsSUFBSSxDQUFDLENBQUM7R0FDdkIsQ0FBQyxDQUFDO0NBQ0oiLCJmaWxlIjoibG9nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uKC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi8pIHtcbiAgICBsZXQgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgbGV2ZWwgPSAxO1xuICAgIGlmIChvcHRpb25zLmhhc2gubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmhhc2gubGV2ZWw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhLmxldmVsICE9IG51bGwpIHtcbiAgICAgIGxldmVsID0gb3B0aW9ucy5kYXRhLmxldmVsO1xuICAgIH1cbiAgICBhcmdzWzBdID0gbGV2ZWw7XG5cbiAgICBpbnN0YW5jZS5sb2coLi4uYXJncyk7XG4gIH0pO1xufVxuIl19


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js":
/*!***********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field, options) {
    if (!obj) {
      // Note for 5.0: Change to "obj == null" in 5.0
      return obj;
    }
    return options.lookupProperty(obj, field);
  });
};

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9va3VwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQWUsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxHQUFHLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRTtBQUM5RCxRQUFJLENBQUMsR0FBRyxFQUFFOztBQUVSLGFBQU8sR0FBRyxDQUFDO0tBQ1o7QUFDRCxXQUFPLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO0dBQzNDLENBQUMsQ0FBQztDQUNKIiwiZmlsZSI6Imxvb2t1cC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb29rdXAnLCBmdW5jdGlvbihvYmosIGZpZWxkLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIC8vIE5vdGUgZm9yIDUuMDogQ2hhbmdlIHRvIFwib2JqID09IG51bGxcIiBpbiA1LjBcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmxvb2t1cFByb3BlcnR5KG9iaiwgZmllbGQpO1xuICB9KTtcbn1cbiJdfQ==


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/with.js":
/*!*********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/with.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (arguments.length != 2) {
      throw new _exception2['default']('#with requires exactly one argument');
    }
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvd2l0aC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O3FCQU1PLFVBQVU7O3lCQUNLLGNBQWM7Ozs7cUJBRXJCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN6RCxRQUFJLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO0FBQ3pCLFlBQU0sMkJBQWMscUNBQXFDLENBQUMsQ0FBQztLQUM1RDtBQUNELFFBQUksa0JBQVcsT0FBTyxDQUFDLEVBQUU7QUFDdkIsYUFBTyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDOUI7O0FBRUQsUUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQzs7QUFFcEIsUUFBSSxDQUFDLGVBQVEsT0FBTyxDQUFDLEVBQUU7QUFDckIsVUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztBQUN4QixVQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixZQUFJLEdBQUcsbUJBQVksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLFlBQUksQ0FBQyxXQUFXLEdBQUcseUJBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUN4QixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUNmLENBQUM7T0FDSDs7QUFFRCxhQUFPLEVBQUUsQ0FBQyxPQUFPLEVBQUU7QUFDakIsWUFBSSxFQUFFLElBQUk7QUFDVixtQkFBVyxFQUFFLG1CQUFZLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO09BQ2hFLENBQUMsQ0FBQztLQUNKLE1BQU07QUFDTCxhQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDOUI7R0FDRixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJ3aXRoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgYXBwZW5kQ29udGV4dFBhdGgsXG4gIGJsb2NrUGFyYW1zLFxuICBjcmVhdGVGcmFtZSxcbiAgaXNFbXB0eSxcbiAgaXNGdW5jdGlvblxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL2V4Y2VwdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJyN3aXRoIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoIWlzRW1wdHkoY29udGV4dCkpIHtcbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKFxuICAgICAgICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCxcbiAgICAgICAgICBvcHRpb25zLmlkc1swXVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogYmxvY2tQYXJhbXMoW2NvbnRleHRdLCBbZGF0YSAmJiBkYXRhLmNvbnRleHRQYXRoXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG4iXX0=


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.createNewLookupObject = createNewLookupObject;

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

/**
 * Create a new object with "null"-prototype to avoid truthy results on prototype properties.
 * The resulting object can be used with "object[property]" to check if a property exists
 * @param {...object} sources a varargs parameter of source objects that will be merged
 * @returns {object}
 */

function createNewLookupObject() {
  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  return _utils.extend.apply(undefined, [Object.create(null)].concat(sources));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2ludGVybmFsL2NyZWF0ZS1uZXctbG9va3VwLW9iamVjdC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztxQkFBdUIsVUFBVTs7Ozs7Ozs7O0FBUTFCLFNBQVMscUJBQXFCLEdBQWE7b0NBQVQsT0FBTztBQUFQLFdBQU87OztBQUM5QyxTQUFPLGdDQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQUssT0FBTyxFQUFDLENBQUM7Q0FDaEQiLCJmaWxlIjoiY3JlYXRlLW5ldy1sb29rdXAtb2JqZWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCBcIm51bGxcIi1wcm90b3R5cGUgdG8gYXZvaWQgdHJ1dGh5IHJlc3VsdHMgb24gcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKiBUaGUgcmVzdWx0aW5nIG9iamVjdCBjYW4gYmUgdXNlZCB3aXRoIFwib2JqZWN0W3Byb3BlcnR5XVwiIHRvIGNoZWNrIGlmIGEgcHJvcGVydHkgZXhpc3RzXG4gKiBAcGFyYW0gey4uLm9iamVjdH0gc291cmNlcyBhIHZhcmFyZ3MgcGFyYW1ldGVyIG9mIHNvdXJjZSBvYmplY3RzIHRoYXQgd2lsbCBiZSBtZXJnZWRcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOZXdMb29rdXBPYmplY3QoLi4uc291cmNlcykge1xuICByZXR1cm4gZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIC4uLnNvdXJjZXMpO1xufVxuIl19


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js":
/*!******************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.createProtoAccessControl = createProtoAccessControl;
exports.resultIsAllowed = resultIsAllowed;
exports.resetLoggedProperties = resetLoggedProperties;
// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _createNewLookupObject = __webpack_require__(/*! ./create-new-lookup-object */ "./node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js");

var _logger = __webpack_require__(/*! ../logger */ "./node_modules/handlebars/dist/cjs/handlebars/logger.js");

var logger = _interopRequireWildcard(_logger);

var loggedProperties = Object.create(null);

function createProtoAccessControl(runtimeOptions) {
  var defaultMethodWhiteList = Object.create(null);
  defaultMethodWhiteList['constructor'] = false;
  defaultMethodWhiteList['__defineGetter__'] = false;
  defaultMethodWhiteList['__defineSetter__'] = false;
  defaultMethodWhiteList['__lookupGetter__'] = false;

  var defaultPropertyWhiteList = Object.create(null);
  // eslint-disable-next-line no-proto
  defaultPropertyWhiteList['__proto__'] = false;

  return {
    properties: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
      defaultValue: runtimeOptions.allowProtoPropertiesByDefault
    },
    methods: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
      defaultValue: runtimeOptions.allowProtoMethodsByDefault
    }
  };
}

function resultIsAllowed(result, protoAccessControl, propertyName) {
  if (typeof result === 'function') {
    return checkWhiteList(protoAccessControl.methods, propertyName);
  } else {
    return checkWhiteList(protoAccessControl.properties, propertyName);
  }
}

function checkWhiteList(protoAccessControlForType, propertyName) {
  if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
    return protoAccessControlForType.whitelist[propertyName] === true;
  }
  if (protoAccessControlForType.defaultValue !== undefined) {
    return protoAccessControlForType.defaultValue;
  }
  logUnexpecedPropertyAccessOnce(propertyName);
  return false;
}

function logUnexpecedPropertyAccessOnce(propertyName) {
  if (loggedProperties[propertyName] !== true) {
    loggedProperties[propertyName] = true;
    logger.log('error', 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\n' + 'You can add a runtime option to disable the check or this warning:\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
  }
}

function resetLoggedProperties() {
  Object.keys(loggedProperties).forEach(function (propertyName) {
    delete loggedProperties[propertyName];
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2ludGVybmFsL3Byb3RvLWFjY2Vzcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O3FDQUFzQyw0QkFBNEI7O3NCQUMxQyxXQUFXOztJQUF2QixNQUFNOztBQUVsQixJQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRXRDLFNBQVMsd0JBQXdCLENBQUMsY0FBYyxFQUFFO0FBQ3ZELE1BQUksc0JBQXNCLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqRCx3QkFBc0IsQ0FBQyxhQUFhLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDOUMsd0JBQXNCLENBQUMsa0JBQWtCLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDbkQsd0JBQXNCLENBQUMsa0JBQWtCLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDbkQsd0JBQXNCLENBQUMsa0JBQWtCLENBQUMsR0FBRyxLQUFLLENBQUM7O0FBRW5ELE1BQUksd0JBQXdCLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFbkQsMEJBQXdCLENBQUMsV0FBVyxDQUFDLEdBQUcsS0FBSyxDQUFDOztBQUU5QyxTQUFPO0FBQ0wsY0FBVSxFQUFFO0FBQ1YsZUFBUyxFQUFFLDZDQUNULHdCQUF3QixFQUN4QixjQUFjLENBQUMsc0JBQXNCLENBQ3RDO0FBQ0Qsa0JBQVksRUFBRSxjQUFjLENBQUMsNkJBQTZCO0tBQzNEO0FBQ0QsV0FBTyxFQUFFO0FBQ1AsZUFBUyxFQUFFLDZDQUNULHNCQUFzQixFQUN0QixjQUFjLENBQUMsbUJBQW1CLENBQ25DO0FBQ0Qsa0JBQVksRUFBRSxjQUFjLENBQUMsMEJBQTBCO0tBQ3hEO0dBQ0YsQ0FBQztDQUNIOztBQUVNLFNBQVMsZUFBZSxDQUFDLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxZQUFZLEVBQUU7QUFDeEUsTUFBSSxPQUFPLE1BQU0sS0FBSyxVQUFVLEVBQUU7QUFDaEMsV0FBTyxjQUFjLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO0dBQ2pFLE1BQU07QUFDTCxXQUFPLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUM7R0FDcEU7Q0FDRjs7QUFFRCxTQUFTLGNBQWMsQ0FBQyx5QkFBeUIsRUFBRSxZQUFZLEVBQUU7QUFDL0QsTUFBSSx5QkFBeUIsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLEtBQUssU0FBUyxFQUFFO0FBQ25FLFdBQU8seUJBQXlCLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxLQUFLLElBQUksQ0FBQztHQUNuRTtBQUNELE1BQUkseUJBQXlCLENBQUMsWUFBWSxLQUFLLFNBQVMsRUFBRTtBQUN4RCxXQUFPLHlCQUF5QixDQUFDLFlBQVksQ0FBQztHQUMvQztBQUNELGdDQUE4QixDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQzdDLFNBQU8sS0FBSyxDQUFDO0NBQ2Q7O0FBRUQsU0FBUyw4QkFBOEIsQ0FBQyxZQUFZLEVBQUU7QUFDcEQsTUFBSSxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsS0FBSyxJQUFJLEVBQUU7QUFDM0Msb0JBQWdCLENBQUMsWUFBWSxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ3RDLFVBQU0sQ0FBQyxHQUFHLENBQ1IsT0FBTyxFQUNQLGlFQUErRCxZQUFZLG9JQUNILG9IQUMyQyxDQUNwSCxDQUFDO0dBQ0g7Q0FDRjs7QUFFTSxTQUFTLHFCQUFxQixHQUFHO0FBQ3RDLFFBQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxZQUFZLEVBQUk7QUFDcEQsV0FBTyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztHQUN2QyxDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJwcm90by1hY2Nlc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVOZXdMb29rdXBPYmplY3QgfSBmcm9tICcuL2NyZWF0ZS1uZXctbG9va3VwLW9iamVjdCc7XG5pbXBvcnQgKiBhcyBsb2dnZXIgZnJvbSAnLi4vbG9nZ2VyJztcblxuY29uc3QgbG9nZ2VkUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm90b0FjY2Vzc0NvbnRyb2wocnVudGltZU9wdGlvbnMpIHtcbiAgbGV0IGRlZmF1bHRNZXRob2RXaGl0ZUxpc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBkZWZhdWx0TWV0aG9kV2hpdGVMaXN0Wydjb25zdHJ1Y3RvciddID0gZmFsc2U7XG4gIGRlZmF1bHRNZXRob2RXaGl0ZUxpc3RbJ19fZGVmaW5lR2V0dGVyX18nXSA9IGZhbHNlO1xuICBkZWZhdWx0TWV0aG9kV2hpdGVMaXN0WydfX2RlZmluZVNldHRlcl9fJ10gPSBmYWxzZTtcbiAgZGVmYXVsdE1ldGhvZFdoaXRlTGlzdFsnX19sb29rdXBHZXR0ZXJfXyddID0gZmFsc2U7XG5cbiAgbGV0IGRlZmF1bHRQcm9wZXJ0eVdoaXRlTGlzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b1xuICBkZWZhdWx0UHJvcGVydHlXaGl0ZUxpc3RbJ19fcHJvdG9fXyddID0gZmFsc2U7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICB3aGl0ZWxpc3Q6IGNyZWF0ZU5ld0xvb2t1cE9iamVjdChcbiAgICAgICAgZGVmYXVsdFByb3BlcnR5V2hpdGVMaXN0LFxuICAgICAgICBydW50aW1lT3B0aW9ucy5hbGxvd2VkUHJvdG9Qcm9wZXJ0aWVzXG4gICAgICApLFxuICAgICAgZGVmYXVsdFZhbHVlOiBydW50aW1lT3B0aW9ucy5hbGxvd1Byb3RvUHJvcGVydGllc0J5RGVmYXVsdFxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgd2hpdGVsaXN0OiBjcmVhdGVOZXdMb29rdXBPYmplY3QoXG4gICAgICAgIGRlZmF1bHRNZXRob2RXaGl0ZUxpc3QsXG4gICAgICAgIHJ1bnRpbWVPcHRpb25zLmFsbG93ZWRQcm90b01ldGhvZHNcbiAgICAgICksXG4gICAgICBkZWZhdWx0VmFsdWU6IHJ1bnRpbWVPcHRpb25zLmFsbG93UHJvdG9NZXRob2RzQnlEZWZhdWx0XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdWx0SXNBbGxvd2VkKHJlc3VsdCwgcHJvdG9BY2Nlc3NDb250cm9sLCBwcm9wZXJ0eU5hbWUpIHtcbiAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY2hlY2tXaGl0ZUxpc3QocHJvdG9BY2Nlc3NDb250cm9sLm1ldGhvZHMsIHByb3BlcnR5TmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNoZWNrV2hpdGVMaXN0KHByb3RvQWNjZXNzQ29udHJvbC5wcm9wZXJ0aWVzLCBwcm9wZXJ0eU5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrV2hpdGVMaXN0KHByb3RvQWNjZXNzQ29udHJvbEZvclR5cGUsIHByb3BlcnR5TmFtZSkge1xuICBpZiAocHJvdG9BY2Nlc3NDb250cm9sRm9yVHlwZS53aGl0ZWxpc3RbcHJvcGVydHlOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHByb3RvQWNjZXNzQ29udHJvbEZvclR5cGUud2hpdGVsaXN0W3Byb3BlcnR5TmFtZV0gPT09IHRydWU7XG4gIH1cbiAgaWYgKHByb3RvQWNjZXNzQ29udHJvbEZvclR5cGUuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvdG9BY2Nlc3NDb250cm9sRm9yVHlwZS5kZWZhdWx0VmFsdWU7XG4gIH1cbiAgbG9nVW5leHBlY2VkUHJvcGVydHlBY2Nlc3NPbmNlKHByb3BlcnR5TmFtZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbG9nVW5leHBlY2VkUHJvcGVydHlBY2Nlc3NPbmNlKHByb3BlcnR5TmFtZSkge1xuICBpZiAobG9nZ2VkUHJvcGVydGllc1twcm9wZXJ0eU5hbWVdICE9PSB0cnVlKSB7XG4gICAgbG9nZ2VkUHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gdHJ1ZTtcbiAgICBsb2dnZXIubG9nKFxuICAgICAgJ2Vycm9yJyxcbiAgICAgIGBIYW5kbGViYXJzOiBBY2Nlc3MgaGFzIGJlZW4gZGVuaWVkIHRvIHJlc29sdmUgdGhlIHByb3BlcnR5IFwiJHtwcm9wZXJ0eU5hbWV9XCIgYmVjYXVzZSBpdCBpcyBub3QgYW4gXCJvd24gcHJvcGVydHlcIiBvZiBpdHMgcGFyZW50LlxcbmAgK1xuICAgICAgICBgWW91IGNhbiBhZGQgYSBydW50aW1lIG9wdGlvbiB0byBkaXNhYmxlIHRoZSBjaGVjayBvciB0aGlzIHdhcm5pbmc6XFxuYCArXG4gICAgICAgIGBTZWUgaHR0cHM6Ly9oYW5kbGViYXJzanMuY29tL2FwaS1yZWZlcmVuY2UvcnVudGltZS1vcHRpb25zLmh0bWwjb3B0aW9ucy10by1jb250cm9sLXByb3RvdHlwZS1hY2Nlc3MgZm9yIGRldGFpbHNgXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRMb2dnZWRQcm9wZXJ0aWVzKCkge1xuICBPYmplY3Qua2V5cyhsb2dnZWRQcm9wZXJ0aWVzKS5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG4gICAgZGVsZXRlIGxvZ2dlZFByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgfSk7XG59XG4iXX0=


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.wrapHelper = wrapHelper;

function wrapHelper(helper, transformOptionsFn) {
  if (typeof helper !== 'function') {
    // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639
    // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.
    return helper;
  }
  var wrapper = function wrapper() /* dynamic arguments */{
    var options = arguments[arguments.length - 1];
    arguments[arguments.length - 1] = transformOptionsFn(options);
    return helper.apply(this, arguments);
  };
  return wrapper;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2ludGVybmFsL3dyYXBIZWxwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTLFVBQVUsQ0FBQyxNQUFNLEVBQUUsa0JBQWtCLEVBQUU7QUFDckQsTUFBSSxPQUFPLE1BQU0sS0FBSyxVQUFVLEVBQUU7OztBQUdoQyxXQUFPLE1BQU0sQ0FBQztHQUNmO0FBQ0QsTUFBSSxPQUFPLEdBQUcsU0FBVixPQUFPLDBCQUFxQztBQUM5QyxRQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNoRCxhQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM5RCxXQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQ3RDLENBQUM7QUFDRixTQUFPLE9BQU8sQ0FBQztDQUNoQiIsImZpbGUiOiJ3cmFwSGVscGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHdyYXBIZWxwZXIoaGVscGVyLCB0cmFuc2Zvcm1PcHRpb25zRm4pIHtcbiAgaWYgKHR5cGVvZiBoZWxwZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgYXBwYXJlbnRseSBpdCBkb2VzIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93eWNhdHMvaGFuZGxlYmFycy5qcy9pc3N1ZXMvMTYzOVxuICAgIC8vIFdlIHRyeSB0byBtYWtlIHRoZSB3cmFwcGVyIGxlYXN0LWludmFzaXZlIGJ5IG5vdCB3cmFwcGluZyBpdCwgaWYgdGhlIGhlbHBlciBpcyBub3QgYSBmdW5jdGlvbi5cbiAgICByZXR1cm4gaGVscGVyO1xuICB9XG4gIGxldCB3cmFwcGVyID0gZnVuY3Rpb24oLyogZHluYW1pYyBhcmd1bWVudHMgKi8pIHtcbiAgICBjb25zdCBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID0gdHJhbnNmb3JtT3B0aW9uc0ZuKG9wdGlvbnMpO1xuICAgIHJldHVybiBoZWxwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgcmV0dXJuIHdyYXBwZXI7XG59XG4iXX0=


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/logger.js":
/*!***************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/logger.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(/*! ./utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      // eslint-disable-next-line no-console
      if (!console[method]) {
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2xvZ2dlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O3FCQUF3QixTQUFTOztBQUVqQyxJQUFJLE1BQU0sR0FBRztBQUNYLFdBQVMsRUFBRSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQztBQUM3QyxPQUFLLEVBQUUsTUFBTTs7O0FBR2IsYUFBVyxFQUFFLHFCQUFTLEtBQUssRUFBRTtBQUMzQixRQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtBQUM3QixVQUFJLFFBQVEsR0FBRyxlQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDOUQsVUFBSSxRQUFRLElBQUksQ0FBQyxFQUFFO0FBQ2pCLGFBQUssR0FBRyxRQUFRLENBQUM7T0FDbEIsTUFBTTtBQUNMLGFBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzdCO0tBQ0Y7O0FBRUQsV0FBTyxLQUFLLENBQUM7R0FDZDs7O0FBR0QsS0FBRyxFQUFFLGFBQVMsS0FBSyxFQUFjO0FBQy9CLFNBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVsQyxRQUNFLE9BQU8sT0FBTyxLQUFLLFdBQVcsSUFDOUIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxFQUN6QztBQUNBLFVBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRXJDLFVBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDcEIsY0FBTSxHQUFHLEtBQUssQ0FBQztPQUNoQjs7d0NBWG1CLE9BQU87QUFBUCxlQUFPOzs7QUFZM0IsYUFBTyxDQUFDLE1BQU0sT0FBQyxDQUFmLE9BQU8sRUFBWSxPQUFPLENBQUMsQ0FBQztLQUM3QjtHQUNGO0NBQ0YsQ0FBQzs7cUJBRWEsTUFBTSIsImZpbGUiOiJsb2dnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmRleE9mIH0gZnJvbSAnLi91dGlscyc7XG5cbmxldCBsb2dnZXIgPSB7XG4gIG1ldGhvZE1hcDogWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSxcbiAgbGV2ZWw6ICdpbmZvJyxcblxuICAvLyBNYXBzIGEgZ2l2ZW4gbGV2ZWwgdmFsdWUgdG8gdGhlIGBtZXRob2RNYXBgIGluZGV4ZXMgYWJvdmUuXG4gIGxvb2t1cExldmVsOiBmdW5jdGlvbihsZXZlbCkge1xuICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbGV2ZWxNYXAgPSBpbmRleE9mKGxvZ2dlci5tZXRob2RNYXAsIGxldmVsLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKGxldmVsTWFwID49IDApIHtcbiAgICAgICAgbGV2ZWwgPSBsZXZlbE1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH0sXG5cbiAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGhvc3QgZW52aXJvbm1lbnRcbiAgbG9nOiBmdW5jdGlvbihsZXZlbCwgLi4ubWVzc2FnZSkge1xuICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgbG9nZ2VyLmxvb2t1cExldmVsKGxvZ2dlci5sZXZlbCkgPD0gbGV2ZWxcbiAgICApIHtcbiAgICAgIGxldCBtZXRob2QgPSBsb2dnZXIubWV0aG9kTWFwW2xldmVsXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBpZiAoIWNvbnNvbGVbbWV0aG9kXSkge1xuICAgICAgICBtZXRob2QgPSAnbG9nJztcbiAgICAgIH1cbiAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5tZXNzYWdlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBsb2dnZXI7XG4iXX0=


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/no-conflict.js":
/*!********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/no-conflict.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL25vLWNvbmZsaWN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQWUsVUFBUyxVQUFVLEVBQUU7O0FBRWxDLE1BQUksSUFBSSxHQUFHLE9BQU8sTUFBTSxLQUFLLFdBQVcsR0FBRyxNQUFNLEdBQUcsTUFBTTtNQUN4RCxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQzs7QUFFaEMsWUFBVSxDQUFDLFVBQVUsR0FBRyxZQUFXO0FBQ2pDLFFBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLEVBQUU7QUFDbEMsVUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUM7S0FDL0I7QUFDRCxXQUFPLFVBQVUsQ0FBQztHQUNuQixDQUFDO0NBQ0giLCJmaWxlIjoibm8tY29uZmxpY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihIYW5kbGViYXJzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGxldCByb290ID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3csXG4gICAgJEhhbmRsZWJhcnMgPSByb290LkhhbmRsZWJhcnM7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIEhhbmRsZWJhcnMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChyb290LkhhbmRsZWJhcnMgPT09IEhhbmRsZWJhcnMpIHtcbiAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xuICAgIH1cbiAgICByZXR1cm4gSGFuZGxlYmFycztcbiAgfTtcbn1cbiJdfQ==

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/runtime.js":
/*!****************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/runtime.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = __webpack_require__(/*! ./utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

var Utils = _interopRequireWildcard(_utils);

var _exception = __webpack_require__(/*! ./exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");

var _exception2 = _interopRequireDefault(_exception);

var _base = __webpack_require__(/*! ./base */ "./node_modules/handlebars/dist/cjs/handlebars/base.js");

var _helpers = __webpack_require__(/*! ./helpers */ "./node_modules/handlebars/dist/cjs/handlebars/helpers.js");

var _internalWrapHelper = __webpack_require__(/*! ./internal/wrapHelper */ "./node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js");

var _internalProtoAccess = __webpack_require__(/*! ./internal/proto-access */ "./node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js");

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
    return;
  }

  if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
    var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
        compilerVersions = _base.REVISION_CHANGES[compilerRevision];
    throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
  } else {
    // Use the embedded version info since the runtime doesn't know about this revision yet
    throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as pseudo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)
  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }
    partial = env.VM.resolvePartial.call(this, partial, context, options);

    var extendedOptions = Utils.extend({}, options, {
      hooks: this.hooks,
      protoAccessControl: this.protoAccessControl
    });

    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, extendedOptions);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name, loc) {
      if (!obj || !(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj, {
          loc: loc
        });
      }
      return container.lookupProperty(obj, name);
    },
    lookupProperty: function lookupProperty(parent, propertyName) {
      var result = parent[propertyName];
      if (result == null) {
        return result;
      }
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return result;
      }

      if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
        return result;
      }
      return undefined;
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        var result = depths[i] && container.lookupProperty(depths[i], name);
        if (result != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    mergeIfNeeded: function mergeIfNeeded(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }

    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }

  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
      wrapHelpersToPassLookupProperty(mergedHelpers, container);
      container.helpers = mergedHelpers;

      if (templateSpec.usePartial) {
        // Use mergeIfNeeded here to prevent compiling global partials multiple times
        container.partials = container.mergeIfNeeded(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = Utils.extend({}, env.decorators, options.decorators);
      }

      container.hooks = {};
      container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);

      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
      _helpers.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);
      _helpers.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
    } else {
      container.protoAccessControl = options.protoAccessControl; // internal option
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
      container.hooks = options.hooks;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

/**
 * This is currently part of the official API, therefore implementation details should not be changed.
 */

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}

function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
  Object.keys(mergedHelpers).forEach(function (helperName) {
    var helper = mergedHelpers[helperName];
    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
  });
}

function passLookupPropertyOption(helper, container) {
  var lookupProperty = container.lookupProperty;
  return _internalWrapHelper.wrapHelper(helper, function (options) {
    return Utils.extend({ lookupProperty: lookupProperty }, options);
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL3J1bnRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBQXVCLFNBQVM7O0lBQXBCLEtBQUs7O3lCQUNLLGFBQWE7Ozs7b0JBTTVCLFFBQVE7O3VCQUNtQixXQUFXOztrQ0FDbEIsdUJBQXVCOzttQ0FJM0MseUJBQXlCOztBQUV6QixTQUFTLGFBQWEsQ0FBQyxZQUFZLEVBQUU7QUFDMUMsTUFBTSxnQkFBZ0IsR0FBRyxBQUFDLFlBQVksSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUssQ0FBQztNQUM3RCxlQUFlLDBCQUFvQixDQUFDOztBQUV0QyxNQUNFLGdCQUFnQiwyQ0FBcUMsSUFDckQsZ0JBQWdCLDJCQUFxQixFQUNyQztBQUNBLFdBQU87R0FDUjs7QUFFRCxNQUFJLGdCQUFnQiwwQ0FBb0MsRUFBRTtBQUN4RCxRQUFNLGVBQWUsR0FBRyx1QkFBaUIsZUFBZSxDQUFDO1FBQ3ZELGdCQUFnQixHQUFHLHVCQUFpQixnQkFBZ0IsQ0FBQyxDQUFDO0FBQ3hELFVBQU0sMkJBQ0oseUZBQXlGLEdBQ3ZGLHFEQUFxRCxHQUNyRCxlQUFlLEdBQ2YsbURBQW1ELEdBQ25ELGdCQUFnQixHQUNoQixJQUFJLENBQ1AsQ0FBQztHQUNILE1BQU07O0FBRUwsVUFBTSwyQkFDSix3RkFBd0YsR0FDdEYsaURBQWlELEdBQ2pELFlBQVksQ0FBQyxDQUFDLENBQUMsR0FDZixJQUFJLENBQ1AsQ0FBQztHQUNIO0NBQ0Y7O0FBRU0sU0FBUyxRQUFRLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRTs7QUFFMUMsTUFBSSxDQUFDLEdBQUcsRUFBRTtBQUNSLFVBQU0sMkJBQWMsbUNBQW1DLENBQUMsQ0FBQztHQUMxRDtBQUNELE1BQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFO0FBQ3ZDLFVBQU0sMkJBQWMsMkJBQTJCLEdBQUcsT0FBTyxZQUFZLENBQUMsQ0FBQztHQUN4RTs7QUFFRCxjQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDOzs7O0FBSWxELEtBQUcsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7O0FBRzVDLE1BQU0sb0NBQW9DLEdBQ3hDLFlBQVksQ0FBQyxRQUFRLElBQUksWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRTFELFdBQVMsb0JBQW9CLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDdkQsUUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFO0FBQ2hCLGFBQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xELFVBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGVBQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO09BQ3ZCO0tBQ0Y7QUFDRCxXQUFPLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDOztBQUV0RSxRQUFJLGVBQWUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUU7QUFDOUMsV0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO0FBQ2pCLHdCQUFrQixFQUFFLElBQUksQ0FBQyxrQkFBa0I7S0FDNUMsQ0FBQyxDQUFDOztBQUVILFFBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDcEMsSUFBSSxFQUNKLE9BQU8sRUFDUCxPQUFPLEVBQ1AsZUFBZSxDQUNoQixDQUFDOztBQUVGLFFBQUksTUFBTSxJQUFJLElBQUksSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO0FBQ2pDLGFBQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQzFDLE9BQU8sRUFDUCxZQUFZLENBQUMsZUFBZSxFQUM1QixHQUFHLENBQ0osQ0FBQztBQUNGLFlBQU0sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsZUFBZSxDQUFDLENBQUM7S0FDbkU7QUFDRCxRQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7QUFDbEIsVUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0FBQ2xCLFlBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDL0IsYUFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM1QyxjQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzVCLGtCQUFNO1dBQ1A7O0FBRUQsZUFBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RDO0FBQ0QsY0FBTSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDM0I7QUFDRCxhQUFPLE1BQU0sQ0FBQztLQUNmLE1BQU07QUFDTCxZQUFNLDJCQUNKLGNBQWMsR0FDWixPQUFPLENBQUMsSUFBSSxHQUNaLDBEQUEwRCxDQUM3RCxDQUFDO0tBQ0g7R0FDRjs7O0FBR0QsTUFBSSxTQUFTLEdBQUc7QUFDZCxVQUFNLEVBQUUsZ0JBQVMsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUU7QUFDL0IsVUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksSUFBSSxHQUFHLENBQUEsQUFBQyxFQUFFO0FBQzFCLGNBQU0sMkJBQWMsR0FBRyxHQUFHLElBQUksR0FBRyxtQkFBbUIsR0FBRyxHQUFHLEVBQUU7QUFDMUQsYUFBRyxFQUFFLEdBQUc7U0FDVCxDQUFDLENBQUM7T0FDSjtBQUNELGFBQU8sU0FBUyxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDNUM7QUFDRCxrQkFBYyxFQUFFLHdCQUFTLE1BQU0sRUFBRSxZQUFZLEVBQUU7QUFDN0MsVUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2xDLFVBQUksTUFBTSxJQUFJLElBQUksRUFBRTtBQUNsQixlQUFPLE1BQU0sQ0FBQztPQUNmO0FBQ0QsVUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxFQUFFO0FBQzlELGVBQU8sTUFBTSxDQUFDO09BQ2Y7O0FBRUQsVUFBSSxxQ0FBZ0IsTUFBTSxFQUFFLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxZQUFZLENBQUMsRUFBRTtBQUN2RSxlQUFPLE1BQU0sQ0FBQztPQUNmO0FBQ0QsYUFBTyxTQUFTLENBQUM7S0FDbEI7QUFDRCxVQUFNLEVBQUUsZ0JBQVMsTUFBTSxFQUFFLElBQUksRUFBRTtBQUM3QixVQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQzFCLFdBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUIsWUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3BFLFlBQUksTUFBTSxJQUFJLElBQUksRUFBRTtBQUNsQixpQkFBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEI7T0FDRjtLQUNGO0FBQ0QsVUFBTSxFQUFFLGdCQUFTLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDakMsYUFBTyxPQUFPLE9BQU8sS0FBSyxVQUFVLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUM7S0FDeEU7O0FBRUQsb0JBQWdCLEVBQUUsS0FBSyxDQUFDLGdCQUFnQjtBQUN4QyxpQkFBYSxFQUFFLG9CQUFvQjs7QUFFbkMsTUFBRSxFQUFFLFlBQVMsQ0FBQyxFQUFFO0FBQ2QsVUFBSSxHQUFHLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFCLFNBQUcsQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUN2QyxhQUFPLEdBQUcsQ0FBQztLQUNaOztBQUVELFlBQVEsRUFBRSxFQUFFO0FBQ1osV0FBTyxFQUFFLGlCQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRTtBQUNuRSxVQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztVQUNuQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQixVQUFJLElBQUksSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLG1CQUFtQixFQUFFO0FBQ3hELHNCQUFjLEdBQUcsV0FBVyxDQUMxQixJQUFJLEVBQ0osQ0FBQyxFQUNELEVBQUUsRUFDRixJQUFJLEVBQ0osbUJBQW1CLEVBQ25CLFdBQVcsRUFDWCxNQUFNLENBQ1AsQ0FBQztPQUNILE1BQU0sSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUMxQixzQkFBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7T0FDOUQ7QUFDRCxhQUFPLGNBQWMsQ0FBQztLQUN2Qjs7QUFFRCxRQUFJLEVBQUUsY0FBUyxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQzNCLGFBQU8sS0FBSyxJQUFJLEtBQUssRUFBRSxFQUFFO0FBQ3ZCLGFBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO09BQ3ZCO0FBQ0QsYUFBTyxLQUFLLENBQUM7S0FDZDtBQUNELGlCQUFhLEVBQUUsdUJBQVMsS0FBSyxFQUFFLE1BQU0sRUFBRTtBQUNyQyxVQUFJLEdBQUcsR0FBRyxLQUFLLElBQUksTUFBTSxDQUFDOztBQUUxQixVQUFJLEtBQUssSUFBSSxNQUFNLElBQUksS0FBSyxLQUFLLE1BQU0sRUFBRTtBQUN2QyxXQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO09BQ3ZDOztBQUVELGFBQU8sR0FBRyxDQUFDO0tBQ1o7O0FBRUQsZUFBVyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDOztBQUU1QixRQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQ2pCLGdCQUFZLEVBQUUsWUFBWSxDQUFDLFFBQVE7R0FDcEMsQ0FBQzs7QUFFRixXQUFTLEdBQUcsQ0FBQyxPQUFPLEVBQWdCO1FBQWQsT0FBTyx5REFBRyxFQUFFOztBQUNoQyxRQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDOztBQUV4QixPQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3BCLFFBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxJQUFJLFlBQVksQ0FBQyxPQUFPLEVBQUU7QUFDNUMsVUFBSSxHQUFHLFFBQVEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDaEM7QUFDRCxRQUFJLE1BQU0sWUFBQTtRQUNSLFdBQVcsR0FBRyxZQUFZLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUM7QUFDN0QsUUFBSSxZQUFZLENBQUMsU0FBUyxFQUFFO0FBQzFCLFVBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUNsQixjQUFNLEdBQ0osT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQ3hCLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FDaEMsT0FBTyxDQUFDLE1BQU0sQ0FBQztPQUN0QixNQUFNO0FBQ0wsY0FBTSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7T0FDcEI7S0FDRjs7QUFFRCxhQUFTLElBQUksQ0FBQyxPQUFPLGdCQUFnQjtBQUNuQyxhQUNFLEVBQUUsR0FDRixZQUFZLENBQUMsSUFBSSxDQUNmLFNBQVMsRUFDVCxPQUFPLEVBQ1AsU0FBUyxDQUFDLE9BQU8sRUFDakIsU0FBUyxDQUFDLFFBQVEsRUFDbEIsSUFBSSxFQUNKLFdBQVcsRUFDWCxNQUFNLENBQ1AsQ0FDRDtLQUNIOztBQUVELFFBQUksR0FBRyxpQkFBaUIsQ0FDdEIsWUFBWSxDQUFDLElBQUksRUFDakIsSUFBSSxFQUNKLFNBQVMsRUFDVCxPQUFPLENBQUMsTUFBTSxJQUFJLEVBQUUsRUFDcEIsSUFBSSxFQUNKLFdBQVcsQ0FDWixDQUFDO0FBQ0YsV0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0dBQy9COztBQUVELEtBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDOztBQUVqQixLQUFHLENBQUMsTUFBTSxHQUFHLFVBQVMsT0FBTyxFQUFFO0FBQzdCLFFBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO0FBQ3BCLFVBQUksYUFBYSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ25FLHFDQUErQixDQUFDLGFBQWEsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUMxRCxlQUFTLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQzs7QUFFbEMsVUFBSSxZQUFZLENBQUMsVUFBVSxFQUFFOztBQUUzQixpQkFBUyxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMsYUFBYSxDQUMxQyxPQUFPLENBQUMsUUFBUSxFQUNoQixHQUFHLENBQUMsUUFBUSxDQUNiLENBQUM7T0FDSDtBQUNELFVBQUksWUFBWSxDQUFDLFVBQVUsSUFBSSxZQUFZLENBQUMsYUFBYSxFQUFFO0FBQ3pELGlCQUFTLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQ2pDLEVBQUUsRUFDRixHQUFHLENBQUMsVUFBVSxFQUNkLE9BQU8sQ0FBQyxVQUFVLENBQ25CLENBQUM7T0FDSDs7QUFFRCxlQUFTLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNyQixlQUFTLENBQUMsa0JBQWtCLEdBQUcsOENBQXlCLE9BQU8sQ0FBQyxDQUFDOztBQUVqRSxVQUFJLG1CQUFtQixHQUNyQixPQUFPLENBQUMseUJBQXlCLElBQ2pDLG9DQUFvQyxDQUFDO0FBQ3ZDLGlDQUFrQixTQUFTLEVBQUUsZUFBZSxFQUFFLG1CQUFtQixDQUFDLENBQUM7QUFDbkUsaUNBQWtCLFNBQVMsRUFBRSxvQkFBb0IsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0tBQ3pFLE1BQU07QUFDTCxlQUFTLENBQUMsa0JBQWtCLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDO0FBQzFELGVBQVMsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUNwQyxlQUFTLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDdEMsZUFBUyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQzFDLGVBQVMsQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztLQUNqQztHQUNGLENBQUM7O0FBRUYsS0FBRyxDQUFDLE1BQU0sR0FBRyxVQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRTtBQUNsRCxRQUFJLFlBQVksQ0FBQyxjQUFjLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDL0MsWUFBTSwyQkFBYyx3QkFBd0IsQ0FBQyxDQUFDO0tBQy9DO0FBQ0QsUUFBSSxZQUFZLENBQUMsU0FBUyxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ3JDLFlBQU0sMkJBQWMseUJBQXlCLENBQUMsQ0FBQztLQUNoRDs7QUFFRCxXQUFPLFdBQVcsQ0FDaEIsU0FBUyxFQUNULENBQUMsRUFDRCxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQ2YsSUFBSSxFQUNKLENBQUMsRUFDRCxXQUFXLEVBQ1gsTUFBTSxDQUNQLENBQUM7R0FDSCxDQUFDO0FBQ0YsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFTSxTQUFTLFdBQVcsQ0FDekIsU0FBUyxFQUNULENBQUMsRUFDRCxFQUFFLEVBQ0YsSUFBSSxFQUNKLG1CQUFtQixFQUNuQixXQUFXLEVBQ1gsTUFBTSxFQUNOO0FBQ0EsV0FBUyxJQUFJLENBQUMsT0FBTyxFQUFnQjtRQUFkLE9BQU8seURBQUcsRUFBRTs7QUFDakMsUUFBSSxhQUFhLEdBQUcsTUFBTSxDQUFDO0FBQzNCLFFBQ0UsTUFBTSxJQUNOLE9BQU8sSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQ3BCLEVBQUUsT0FBTyxLQUFLLFNBQVMsQ0FBQyxXQUFXLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQSxBQUFDLEVBQzFEO0FBQ0EsbUJBQWEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUMxQzs7QUFFRCxXQUFPLEVBQUUsQ0FDUCxTQUFTLEVBQ1QsT0FBTyxFQUNQLFNBQVMsQ0FBQyxPQUFPLEVBQ2pCLFNBQVMsQ0FBQyxRQUFRLEVBQ2xCLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxFQUNwQixXQUFXLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUN4RCxhQUFhLENBQ2QsQ0FBQztHQUNIOztBQUVELE1BQUksR0FBRyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDOztBQUV6RSxNQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztBQUNqQixNQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUN4QyxNQUFJLENBQUMsV0FBVyxHQUFHLG1CQUFtQixJQUFJLENBQUMsQ0FBQztBQUM1QyxTQUFPLElBQUksQ0FBQztDQUNiOzs7Ozs7QUFLTSxTQUFTLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN4RCxNQUFJLENBQUMsT0FBTyxFQUFFO0FBQ1osUUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFFO0FBQ3JDLGFBQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ3pDLE1BQU07QUFDTCxhQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDMUM7R0FDRixNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTs7QUFFekMsV0FBTyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7QUFDdkIsV0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7R0FDckM7QUFDRCxTQUFPLE9BQU8sQ0FBQztDQUNoQjs7QUFFTSxTQUFTLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTs7QUFFdkQsTUFBTSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDMUUsU0FBTyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDdkIsTUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQ2YsV0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztHQUN2RTs7QUFFRCxNQUFJLFlBQVksWUFBQSxDQUFDO0FBQ2pCLE1BQUksT0FBTyxDQUFDLEVBQUUsSUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLElBQUksRUFBRTs7QUFDckMsYUFBTyxDQUFDLElBQUksR0FBRyxrQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRXpDLFVBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7QUFDcEIsa0JBQVksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLFNBQVMsbUJBQW1CLENBQ3pFLE9BQU8sRUFFUDtZQURBLE9BQU8seURBQUcsRUFBRTs7OztBQUlaLGVBQU8sQ0FBQyxJQUFJLEdBQUcsa0JBQVksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLGVBQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsbUJBQW1CLENBQUM7QUFDcEQsZUFBTyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQzdCLENBQUM7QUFDRixVQUFJLEVBQUUsQ0FBQyxRQUFRLEVBQUU7QUFDZixlQUFPLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3BFOztHQUNGOztBQUVELE1BQUksT0FBTyxLQUFLLFNBQVMsSUFBSSxZQUFZLEVBQUU7QUFDekMsV0FBTyxHQUFHLFlBQVksQ0FBQztHQUN4Qjs7QUFFRCxNQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUU7QUFDekIsVUFBTSwyQkFBYyxjQUFjLEdBQUcsT0FBTyxDQUFDLElBQUksR0FBRyxxQkFBcUIsQ0FBQyxDQUFDO0dBQzVFLE1BQU0sSUFBSSxPQUFPLFlBQVksUUFBUSxFQUFFO0FBQ3RDLFdBQU8sT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztHQUNsQztDQUNGOztBQUVNLFNBQVMsSUFBSSxHQUFHO0FBQ3JCLFNBQU8sRUFBRSxDQUFDO0NBQ1g7O0FBRUQsU0FBUyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUMvQixNQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsTUFBTSxJQUFJLElBQUksQ0FBQSxBQUFDLEVBQUU7QUFDOUIsUUFBSSxHQUFHLElBQUksR0FBRyxrQkFBWSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDckMsUUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7R0FDckI7QUFDRCxTQUFPLElBQUksQ0FBQztDQUNiOztBQUVELFNBQVMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUU7QUFDekUsTUFBSSxFQUFFLENBQUMsU0FBUyxFQUFFO0FBQ2hCLFFBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNmLFFBQUksR0FBRyxFQUFFLENBQUMsU0FBUyxDQUNqQixJQUFJLEVBQ0osS0FBSyxFQUNMLFNBQVMsRUFDVCxNQUFNLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUNuQixJQUFJLEVBQ0osV0FBVyxFQUNYLE1BQU0sQ0FDUCxDQUFDO0FBQ0YsU0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7R0FDM0I7QUFDRCxTQUFPLElBQUksQ0FBQztDQUNiOztBQUVELFNBQVMsK0JBQStCLENBQUMsYUFBYSxFQUFFLFNBQVMsRUFBRTtBQUNqRSxRQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFBLFVBQVUsRUFBSTtBQUMvQyxRQUFJLE1BQU0sR0FBRyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDdkMsaUJBQWEsQ0FBQyxVQUFVLENBQUMsR0FBRyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDekUsQ0FBQyxDQUFDO0NBQ0o7O0FBRUQsU0FBUyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFO0FBQ25ELE1BQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxjQUFjLENBQUM7QUFDaEQsU0FBTywrQkFBVyxNQUFNLEVBQUUsVUFBQSxPQUFPLEVBQUk7QUFDbkMsV0FBTyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsY0FBYyxFQUFkLGNBQWMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0dBQ2xELENBQUMsQ0FBQztDQUNKIiwiZmlsZSI6InJ1bnRpbWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHtcbiAgQ09NUElMRVJfUkVWSVNJT04sXG4gIGNyZWF0ZUZyYW1lLFxuICBMQVNUX0NPTVBBVElCTEVfQ09NUElMRVJfUkVWSVNJT04sXG4gIFJFVklTSU9OX0NIQU5HRVNcbn0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IG1vdmVIZWxwZXJUb0hvb2tzIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IHdyYXBIZWxwZXIgfSBmcm9tICcuL2ludGVybmFsL3dyYXBIZWxwZXInO1xuaW1wb3J0IHtcbiAgY3JlYXRlUHJvdG9BY2Nlc3NDb250cm9sLFxuICByZXN1bHRJc0FsbG93ZWRcbn0gZnJvbSAnLi9pbnRlcm5hbC9wcm90by1hY2Nlc3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXZpc2lvbihjb21waWxlckluZm8pIHtcbiAgY29uc3QgY29tcGlsZXJSZXZpc2lvbiA9IChjb21waWxlckluZm8gJiYgY29tcGlsZXJJbmZvWzBdKSB8fCAxLFxuICAgIGN1cnJlbnRSZXZpc2lvbiA9IENPTVBJTEVSX1JFVklTSU9OO1xuXG4gIGlmIChcbiAgICBjb21waWxlclJldmlzaW9uID49IExBU1RfQ09NUEFUSUJMRV9DT01QSUxFUl9SRVZJU0lPTiAmJlxuICAgIGNvbXBpbGVyUmV2aXNpb24gPD0gQ09NUElMRVJfUkVWSVNJT05cbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbXBpbGVyUmV2aXNpb24gPCBMQVNUX0NPTVBBVElCTEVfQ09NUElMRVJfUkVWSVNJT04pIHtcbiAgICBjb25zdCBydW50aW1lVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2N1cnJlbnRSZXZpc2lvbl0sXG4gICAgICBjb21waWxlclZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjb21waWxlclJldmlzaW9uXTtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFxuICAgICAgJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGFuIG9sZGVyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgK1xuICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArXG4gICAgICAgIHJ1bnRpbWVWZXJzaW9ucyArXG4gICAgICAgICcpIG9yIGRvd25ncmFkZSB5b3VyIHJ1bnRpbWUgdG8gYW4gb2xkZXIgdmVyc2lvbiAoJyArXG4gICAgICAgIGNvbXBpbGVyVmVyc2lvbnMgK1xuICAgICAgICAnKS4nXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBVc2UgdGhlIGVtYmVkZGVkIHZlcnNpb24gaW5mbyBzaW5jZSB0aGUgcnVudGltZSBkb2Vzbid0IGtub3cgYWJvdXQgdGhpcyByZXZpc2lvbiB5ZXRcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFxuICAgICAgJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICdQbGVhc2UgdXBkYXRlIHlvdXIgcnVudGltZSB0byBhIG5ld2VyIHZlcnNpb24gKCcgK1xuICAgICAgICBjb21waWxlckluZm9bMV0gK1xuICAgICAgICAnKS4nXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFlbnYpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGUnKTtcbiAgfVxuICBpZiAoIXRlbXBsYXRlU3BlYyB8fCAhdGVtcGxhdGVTcGVjLm1haW4pIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHRlbXBsYXRlIG9iamVjdDogJyArIHR5cGVvZiB0ZW1wbGF0ZVNwZWMpO1xuICB9XG5cbiAgdGVtcGxhdGVTcGVjLm1haW4uZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjLm1haW5fZDtcblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHNldWRvLXN1cHBvcnRlZCBBUElzLlxuICBlbnYuVk0uY2hlY2tSZXZpc2lvbih0ZW1wbGF0ZVNwZWMuY29tcGlsZXIpO1xuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBwcmVjb21waWxlZCB0ZW1wbGF0ZXMgd2l0aCBjb21waWxlci12ZXJzaW9uIDcgKDw0LjMuMClcbiAgY29uc3QgdGVtcGxhdGVXYXNQcmVjb21waWxlZFdpdGhDb21waWxlclY3ID1cbiAgICB0ZW1wbGF0ZVNwZWMuY29tcGlsZXIgJiYgdGVtcGxhdGVTcGVjLmNvbXBpbGVyWzBdID09PSA3O1xuXG4gIGZ1bmN0aW9uIGludm9rZVBhcnRpYWxXcmFwcGVyKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBvcHRpb25zLmhhc2gpO1xuICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIG9wdGlvbnMuaWRzWzBdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGFydGlhbCA9IGVudi5WTS5yZXNvbHZlUGFydGlhbC5jYWxsKHRoaXMsIHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpO1xuXG4gICAgbGV0IGV4dGVuZGVkT3B0aW9ucyA9IFV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgaG9va3M6IHRoaXMuaG9va3MsXG4gICAgICBwcm90b0FjY2Vzc0NvbnRyb2w6IHRoaXMucHJvdG9BY2Nlc3NDb250cm9sXG4gICAgfSk7XG5cbiAgICBsZXQgcmVzdWx0ID0gZW52LlZNLmludm9rZVBhcnRpYWwuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICBwYXJ0aWFsLFxuICAgICAgY29udGV4dCxcbiAgICAgIGV4dGVuZGVkT3B0aW9uc1xuICAgICk7XG5cbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgZW52LmNvbXBpbGUpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXSA9IGVudi5jb21waWxlKFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgICB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJPcHRpb25zLFxuICAgICAgICBlbnZcbiAgICAgICk7XG4gICAgICByZXN1bHQgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0oY29udGV4dCwgZXh0ZW5kZWRPcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmRlbnQpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gcmVzdWx0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxpbmVzW2ldICYmIGkgKyAxID09PSBsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lc1tpXSA9IG9wdGlvbnMuaW5kZW50ICsgbGluZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFxuICAgICAgICAnVGhlIHBhcnRpYWwgJyArXG4gICAgICAgICAgb3B0aW9ucy5uYW1lICtcbiAgICAgICAgICAnIGNvdWxkIG5vdCBiZSBjb21waWxlZCB3aGVuIHJ1bm5pbmcgaW4gcnVudGltZS1vbmx5IG1vZGUnXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIGxldCBjb250YWluZXIgPSB7XG4gICAgc3RyaWN0OiBmdW5jdGlvbihvYmosIG5hbWUsIGxvYykge1xuICAgICAgaWYgKCFvYmogfHwgIShuYW1lIGluIG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignXCInICsgbmFtZSArICdcIiBub3QgZGVmaW5lZCBpbiAnICsgb2JqLCB7XG4gICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyLmxvb2t1cFByb3BlcnR5KG9iaiwgbmFtZSk7XG4gICAgfSxcbiAgICBsb29rdXBQcm9wZXJ0eTogZnVuY3Rpb24ocGFyZW50LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJlbnRbcHJvcGVydHlOYW1lXTtcbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnQsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdElzQWxsb3dlZChyZXN1bHQsIGNvbnRhaW5lci5wcm90b0FjY2Vzc0NvbnRyb2wsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBsb29rdXA6IGZ1bmN0aW9uKGRlcHRocywgbmFtZSkge1xuICAgICAgY29uc3QgbGVuID0gZGVwdGhzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGRlcHRoc1tpXSAmJiBjb250YWluZXIubG9va3VwUHJvcGVydHkoZGVwdGhzW2ldLCBuYW1lKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGRlcHRoc1tpXVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGFtYmRhOiBmdW5jdGlvbihjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGN1cnJlbnQgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50LmNhbGwoY29udGV4dCkgOiBjdXJyZW50O1xuICAgIH0sXG5cbiAgICBlc2NhcGVFeHByZXNzaW9uOiBVdGlscy5lc2NhcGVFeHByZXNzaW9uLFxuICAgIGludm9rZVBhcnRpYWw6IGludm9rZVBhcnRpYWxXcmFwcGVyLFxuXG4gICAgZm46IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGxldCByZXQgPSB0ZW1wbGF0ZVNwZWNbaV07XG4gICAgICByZXQuZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjW2kgKyAnX2QnXTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHByb2dyYW1zOiBbXSxcbiAgICBwcm9ncmFtOiBmdW5jdGlvbihpLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgICBsZXQgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldLFxuICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XG4gICAgICBpZiAoZGF0YSB8fCBkZXB0aHMgfHwgYmxvY2tQYXJhbXMgfHwgZGVjbGFyZWRCbG9ja1BhcmFtcykge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHdyYXBQcm9ncmFtKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBmbixcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGRlY2xhcmVkQmxvY2tQYXJhbXMsXG4gICAgICAgICAgYmxvY2tQYXJhbXMsXG4gICAgICAgICAgZGVwdGhzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9ncmFtV3JhcHBlcikge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3JhbVdyYXBwZXI7XG4gICAgfSxcblxuICAgIGRhdGE6IGZ1bmN0aW9uKHZhbHVlLCBkZXB0aCkge1xuICAgICAgd2hpbGUgKHZhbHVlICYmIGRlcHRoLS0pIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5fcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgbWVyZ2VJZk5lZWRlZDogZnVuY3Rpb24ocGFyYW0sIGNvbW1vbikge1xuICAgICAgbGV0IG9iaiA9IHBhcmFtIHx8IGNvbW1vbjtcblxuICAgICAgaWYgKHBhcmFtICYmIGNvbW1vbiAmJiBwYXJhbSAhPT0gY29tbW9uKSB7XG4gICAgICAgIG9iaiA9IFV0aWxzLmV4dGVuZCh7fSwgY29tbW9uLCBwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICAvLyBBbiBlbXB0eSBvYmplY3QgdG8gdXNlIGFzIHJlcGxhY2VtZW50IGZvciBudWxsLWNvbnRleHRzXG4gICAgbnVsbENvbnRleHQ6IE9iamVjdC5zZWFsKHt9KSxcblxuICAgIG5vb3A6IGVudi5WTS5ub29wLFxuICAgIGNvbXBpbGVySW5mbzogdGVtcGxhdGVTcGVjLmNvbXBpbGVyXG4gIH07XG5cbiAgZnVuY3Rpb24gcmV0KGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gICAgcmV0Ll9zZXR1cChvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCAmJiB0ZW1wbGF0ZVNwZWMudXNlRGF0YSkge1xuICAgICAgZGF0YSA9IGluaXREYXRhKGNvbnRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBsZXQgZGVwdGhzLFxuICAgICAgYmxvY2tQYXJhbXMgPSB0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocykge1xuICAgICAgaWYgKG9wdGlvbnMuZGVwdGhzKSB7XG4gICAgICAgIGRlcHRocyA9XG4gICAgICAgICAgY29udGV4dCAhPSBvcHRpb25zLmRlcHRoc1swXVxuICAgICAgICAgICAgPyBbY29udGV4dF0uY29uY2F0KG9wdGlvbnMuZGVwdGhzKVxuICAgICAgICAgICAgOiBvcHRpb25zLmRlcHRocztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcHRocyA9IFtjb250ZXh0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWluKGNvbnRleHQgLyosIG9wdGlvbnMqLykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgJycgK1xuICAgICAgICB0ZW1wbGF0ZVNwZWMubWFpbihcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBjb250YWluZXIuaGVscGVycyxcbiAgICAgICAgICBjb250YWluZXIucGFydGlhbHMsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBibG9ja1BhcmFtcyxcbiAgICAgICAgICBkZXB0aHNcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBtYWluID0gZXhlY3V0ZURlY29yYXRvcnMoXG4gICAgICB0ZW1wbGF0ZVNwZWMubWFpbixcbiAgICAgIG1haW4sXG4gICAgICBjb250YWluZXIsXG4gICAgICBvcHRpb25zLmRlcHRocyB8fCBbXSxcbiAgICAgIGRhdGEsXG4gICAgICBibG9ja1BhcmFtc1xuICAgICk7XG4gICAgcmV0dXJuIG1haW4oY29udGV4dCwgb3B0aW9ucyk7XG4gIH1cblxuICByZXQuaXNUb3AgPSB0cnVlO1xuXG4gIHJldC5fc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGxldCBtZXJnZWRIZWxwZXJzID0gVXRpbHMuZXh0ZW5kKHt9LCBlbnYuaGVscGVycywgb3B0aW9ucy5oZWxwZXJzKTtcbiAgICAgIHdyYXBIZWxwZXJzVG9QYXNzTG9va3VwUHJvcGVydHkobWVyZ2VkSGVscGVycywgY29udGFpbmVyKTtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gbWVyZ2VkSGVscGVycztcblxuICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsKSB7XG4gICAgICAgIC8vIFVzZSBtZXJnZUlmTmVlZGVkIGhlcmUgdG8gcHJldmVudCBjb21waWxpbmcgZ2xvYmFsIHBhcnRpYWxzIG11bHRpcGxlIHRpbWVzXG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGNvbnRhaW5lci5tZXJnZUlmTmVlZGVkKFxuICAgICAgICAgIG9wdGlvbnMucGFydGlhbHMsXG4gICAgICAgICAgZW52LnBhcnRpYWxzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwgfHwgdGVtcGxhdGVTcGVjLnVzZURlY29yYXRvcnMpIHtcbiAgICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBVdGlscy5leHRlbmQoXG4gICAgICAgICAge30sXG4gICAgICAgICAgZW52LmRlY29yYXRvcnMsXG4gICAgICAgICAgb3B0aW9ucy5kZWNvcmF0b3JzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRhaW5lci5ob29rcyA9IHt9O1xuICAgICAgY29udGFpbmVyLnByb3RvQWNjZXNzQ29udHJvbCA9IGNyZWF0ZVByb3RvQWNjZXNzQ29udHJvbChvcHRpb25zKTtcblxuICAgICAgbGV0IGtlZXBIZWxwZXJJbkhlbHBlcnMgPVxuICAgICAgICBvcHRpb25zLmFsbG93Q2FsbHNUb0hlbHBlck1pc3NpbmcgfHxcbiAgICAgICAgdGVtcGxhdGVXYXNQcmVjb21waWxlZFdpdGhDb21waWxlclY3O1xuICAgICAgbW92ZUhlbHBlclRvSG9va3MoY29udGFpbmVyLCAnaGVscGVyTWlzc2luZycsIGtlZXBIZWxwZXJJbkhlbHBlcnMpO1xuICAgICAgbW92ZUhlbHBlclRvSG9va3MoY29udGFpbmVyLCAnYmxvY2tIZWxwZXJNaXNzaW5nJywga2VlcEhlbHBlckluSGVscGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5wcm90b0FjY2Vzc0NvbnRyb2wgPSBvcHRpb25zLnByb3RvQWNjZXNzQ29udHJvbDsgLy8gaW50ZXJuYWwgb3B0aW9uXG4gICAgICBjb250YWluZXIuaGVscGVycyA9IG9wdGlvbnMuaGVscGVycztcbiAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IG9wdGlvbnMucGFydGlhbHM7XG4gICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IG9wdGlvbnMuZGVjb3JhdG9ycztcbiAgICAgIGNvbnRhaW5lci5ob29rcyA9IG9wdGlvbnMuaG9va3M7XG4gICAgfVxuICB9O1xuXG4gIHJldC5fY2hpbGQgPSBmdW5jdGlvbihpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyAmJiAhYmxvY2tQYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBibG9jayBwYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMgJiYgIWRlcHRocykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignbXVzdCBwYXNzIHBhcmVudCBkZXB0aHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcFByb2dyYW0oXG4gICAgICBjb250YWluZXIsXG4gICAgICBpLFxuICAgICAgdGVtcGxhdGVTcGVjW2ldLFxuICAgICAgZGF0YSxcbiAgICAgIDAsXG4gICAgICBibG9ja1BhcmFtcyxcbiAgICAgIGRlcHRoc1xuICAgICk7XG4gIH07XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwUHJvZ3JhbShcbiAgY29udGFpbmVyLFxuICBpLFxuICBmbixcbiAgZGF0YSxcbiAgZGVjbGFyZWRCbG9ja1BhcmFtcyxcbiAgYmxvY2tQYXJhbXMsXG4gIGRlcHRoc1xuKSB7XG4gIGZ1bmN0aW9uIHByb2coY29udGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGN1cnJlbnREZXB0aHMgPSBkZXB0aHM7XG4gICAgaWYgKFxuICAgICAgZGVwdGhzICYmXG4gICAgICBjb250ZXh0ICE9IGRlcHRoc1swXSAmJlxuICAgICAgIShjb250ZXh0ID09PSBjb250YWluZXIubnVsbENvbnRleHQgJiYgZGVwdGhzWzBdID09PSBudWxsKVxuICAgICkge1xuICAgICAgY3VycmVudERlcHRocyA9IFtjb250ZXh0XS5jb25jYXQoZGVwdGhzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4oXG4gICAgICBjb250YWluZXIsXG4gICAgICBjb250ZXh0LFxuICAgICAgY29udGFpbmVyLmhlbHBlcnMsXG4gICAgICBjb250YWluZXIucGFydGlhbHMsXG4gICAgICBvcHRpb25zLmRhdGEgfHwgZGF0YSxcbiAgICAgIGJsb2NrUGFyYW1zICYmIFtvcHRpb25zLmJsb2NrUGFyYW1zXS5jb25jYXQoYmxvY2tQYXJhbXMpLFxuICAgICAgY3VycmVudERlcHRoc1xuICAgICk7XG4gIH1cblxuICBwcm9nID0gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcyk7XG5cbiAgcHJvZy5wcm9ncmFtID0gaTtcbiAgcHJvZy5kZXB0aCA9IGRlcHRocyA/IGRlcHRocy5sZW5ndGggOiAwO1xuICBwcm9nLmJsb2NrUGFyYW1zID0gZGVjbGFyZWRCbG9ja1BhcmFtcyB8fCAwO1xuICByZXR1cm4gcHJvZztcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGN1cnJlbnRseSBwYXJ0IG9mIHRoZSBvZmZpY2lhbCBBUEksIHRoZXJlZm9yZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXJ0aWFsKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKCFwYXJ0aWFsKSB7XG4gICAgaWYgKG9wdGlvbnMubmFtZSA9PT0gJ0BwYXJ0aWFsLWJsb2NrJykge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdO1xuICAgIH1cbiAgfSBlbHNlIGlmICghcGFydGlhbC5jYWxsICYmICFvcHRpb25zLm5hbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwYXJ0aWFsIHRoYXQgcmV0dXJuZWQgYSBzdHJpbmdcbiAgICBvcHRpb25zLm5hbWUgPSBwYXJ0aWFsO1xuICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW3BhcnRpYWxdO1xuICB9XG4gIHJldHVybiBwYXJ0aWFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFVzZSB0aGUgY3VycmVudCBjbG9zdXJlIGNvbnRleHQgdG8gc2F2ZSB0aGUgcGFydGlhbC1ibG9jayBpZiB0aGlzIHBhcnRpYWxcbiAgY29uc3QgY3VycmVudFBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcbiAgb3B0aW9ucy5wYXJ0aWFsID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoID0gb3B0aW9ucy5pZHNbMF0gfHwgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoO1xuICB9XG5cbiAgbGV0IHBhcnRpYWxCbG9jaztcbiAgaWYgKG9wdGlvbnMuZm4gJiYgb3B0aW9ucy5mbiAhPT0gbm9vcCkge1xuICAgIG9wdGlvbnMuZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgLy8gV3JhcHBlciBmdW5jdGlvbiB0byBnZXQgYWNjZXNzIHRvIGN1cnJlbnRQYXJ0aWFsQmxvY2sgZnJvbSB0aGUgY2xvc3VyZVxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG4gICAgcGFydGlhbEJsb2NrID0gb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBmdW5jdGlvbiBwYXJ0aWFsQmxvY2tXcmFwcGVyKFxuICAgICAgY29udGV4dCxcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgICkge1xuICAgICAgLy8gUmVzdG9yZSB0aGUgcGFydGlhbC1ibG9jayBmcm9tIHRoZSBjbG9zdXJlIGZvciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBibG9ja1xuICAgICAgLy8gaS5lLiB0aGUgcGFydCBpbnNpZGUgdGhlIGJsb2NrIG9mIHRoZSBwYXJ0aWFsIGNhbGwuXG4gICAgICBvcHRpb25zLmRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBjdXJyZW50UGFydGlhbEJsb2NrO1xuICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgaWYgKGZuLnBhcnRpYWxzKSB7XG4gICAgICBvcHRpb25zLnBhcnRpYWxzID0gVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLnBhcnRpYWxzLCBmbi5wYXJ0aWFscyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCAmJiBwYXJ0aWFsQmxvY2spIHtcbiAgICBwYXJ0aWFsID0gcGFydGlhbEJsb2NrO1xuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICB9IGVsc2UgaWYgKHBhcnRpYWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiBwYXJ0aWFsKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge1xuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhKGNvbnRleHQsIGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8ICEoJ3Jvb3QnIGluIGRhdGEpKSB7XG4gICAgZGF0YSA9IGRhdGEgPyBjcmVhdGVGcmFtZShkYXRhKSA6IHt9O1xuICAgIGRhdGEucm9vdCA9IGNvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpIHtcbiAgaWYgKGZuLmRlY29yYXRvcikge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIHByb2cgPSBmbi5kZWNvcmF0b3IoXG4gICAgICBwcm9nLFxuICAgICAgcHJvcHMsXG4gICAgICBjb250YWluZXIsXG4gICAgICBkZXB0aHMgJiYgZGVwdGhzWzBdLFxuICAgICAgZGF0YSxcbiAgICAgIGJsb2NrUGFyYW1zLFxuICAgICAgZGVwdGhzXG4gICAgKTtcbiAgICBVdGlscy5leHRlbmQocHJvZywgcHJvcHMpO1xuICB9XG4gIHJldHVybiBwcm9nO1xufVxuXG5mdW5jdGlvbiB3cmFwSGVscGVyc1RvUGFzc0xvb2t1cFByb3BlcnR5KG1lcmdlZEhlbHBlcnMsIGNvbnRhaW5lcikge1xuICBPYmplY3Qua2V5cyhtZXJnZWRIZWxwZXJzKS5mb3JFYWNoKGhlbHBlck5hbWUgPT4ge1xuICAgIGxldCBoZWxwZXIgPSBtZXJnZWRIZWxwZXJzW2hlbHBlck5hbWVdO1xuICAgIG1lcmdlZEhlbHBlcnNbaGVscGVyTmFtZV0gPSBwYXNzTG9va3VwUHJvcGVydHlPcHRpb24oaGVscGVyLCBjb250YWluZXIpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFzc0xvb2t1cFByb3BlcnR5T3B0aW9uKGhlbHBlciwgY29udGFpbmVyKSB7XG4gIGNvbnN0IGxvb2t1cFByb3BlcnR5ID0gY29udGFpbmVyLmxvb2t1cFByb3BlcnR5O1xuICByZXR1cm4gd3JhcEhlbHBlcihoZWxwZXIsIG9wdGlvbnMgPT4ge1xuICAgIHJldHVybiBVdGlscy5leHRlbmQoeyBsb29rdXBQcm9wZXJ0eSB9LCBvcHRpb25zKTtcbiAgfSk7XG59XG4iXX0=


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/safe-string.js":
/*!********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/safe-string.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Build out our basic SafeString type


exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxTQUFTLFVBQVUsQ0FBQyxNQUFNLEVBQUU7QUFDMUIsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7Q0FDdEI7O0FBRUQsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsWUFBVztBQUN2RSxTQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0NBQ3pCLENBQUM7O3FCQUVhLFVBQVUiLCJmaWxlIjoic2FmZS1zdHJpbmcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCdWlsZCBvdXQgb3VyIGJhc2ljIFNhZmVTdHJpbmcgdHlwZVxuZnVuY3Rpb24gU2FmZVN0cmluZyhzdHJpbmcpIHtcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG59XG5cblNhZmVTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gU2FmZVN0cmluZy5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJyArIHRoaXMuc3RyaW5nO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2FmZVN0cmluZztcbiJdfQ==


/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/utils.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxJQUFNLE1BQU0sR0FBRztBQUNiLEtBQUcsRUFBRSxPQUFPO0FBQ1osS0FBRyxFQUFFLE1BQU07QUFDWCxLQUFHLEVBQUUsTUFBTTtBQUNYLEtBQUcsRUFBRSxRQUFRO0FBQ2IsS0FBRyxFQUFFLFFBQVE7QUFDYixLQUFHLEVBQUUsUUFBUTtBQUNiLEtBQUcsRUFBRSxRQUFRO0NBQ2QsQ0FBQzs7QUFFRixJQUFNLFFBQVEsR0FBRyxZQUFZO0lBQzNCLFFBQVEsR0FBRyxXQUFXLENBQUM7O0FBRXpCLFNBQVMsVUFBVSxDQUFDLEdBQUcsRUFBRTtBQUN2QixTQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNwQjs7QUFFTSxTQUFTLE1BQU0sQ0FBQyxHQUFHLG9CQUFvQjtBQUM1QyxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN6QyxTQUFLLElBQUksR0FBRyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUM1QixVQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUU7QUFDM0QsV0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUM5QjtLQUNGO0dBQ0Y7O0FBRUQsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFTSxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQzs7Ozs7O0FBS2hELElBQUksVUFBVSxHQUFHLG9CQUFTLEtBQUssRUFBRTtBQUMvQixTQUFPLE9BQU8sS0FBSyxLQUFLLFVBQVUsQ0FBQztDQUNwQyxDQUFDOzs7QUFHRixJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNuQixVQU9PLFVBQVUsR0FQakIsVUFBVSxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQzNCLFdBQ0UsT0FBTyxLQUFLLEtBQUssVUFBVSxJQUMzQixRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLG1CQUFtQixDQUM1QztHQUNILENBQUM7Q0FDSDtRQUNRLFVBQVUsR0FBVixVQUFVOzs7OztBQUlaLElBQU0sT0FBTyxHQUNsQixLQUFLLENBQUMsT0FBTyxJQUNiLFVBQVMsS0FBSyxFQUFFO0FBQ2QsU0FBTyxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxHQUNyQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLGdCQUFnQixHQUN6QyxLQUFLLENBQUM7Q0FDWCxDQUFDOzs7OztBQUdHLFNBQVMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDcEMsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNoRCxRQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUU7QUFDdEIsYUFBTyxDQUFDLENBQUM7S0FDVjtHQUNGO0FBQ0QsU0FBTyxDQUFDLENBQUMsQ0FBQztDQUNYOztBQUVNLFNBQVMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFO0FBQ3ZDLE1BQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFOztBQUU5QixRQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO0FBQzNCLGFBQU8sTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQ3hCLE1BQU0sSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO0FBQ3pCLGFBQU8sRUFBRSxDQUFDO0tBQ1gsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2xCLGFBQU8sTUFBTSxHQUFHLEVBQUUsQ0FBQztLQUNwQjs7Ozs7QUFLRCxVQUFNLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQztHQUN0Qjs7QUFFRCxNQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUMxQixXQUFPLE1BQU0sQ0FBQztHQUNmO0FBQ0QsU0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztDQUM3Qzs7QUFFTSxTQUFTLE9BQU8sQ0FBQyxLQUFLLEVBQUU7QUFDN0IsTUFBSSxDQUFDLEtBQUssSUFBSSxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQ3pCLFdBQU8sSUFBSSxDQUFDO0dBQ2IsTUFBTSxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUMvQyxXQUFPLElBQUksQ0FBQztHQUNiLE1BQU07QUFDTCxXQUFPLEtBQUssQ0FBQztHQUNkO0NBQ0Y7O0FBRU0sU0FBUyxXQUFXLENBQUMsTUFBTSxFQUFFO0FBQ2xDLE1BQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDL0IsT0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDdkIsU0FBTyxLQUFLLENBQUM7Q0FDZDs7QUFFTSxTQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFO0FBQ3ZDLFFBQU0sQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ2xCLFNBQU8sTUFBTSxDQUFDO0NBQ2Y7O0FBRU0sU0FBUyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsRUFBRSxFQUFFO0FBQ2pELFNBQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUEsR0FBSSxFQUFFLENBQUM7Q0FDcEQiLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBlc2NhcGUgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5jb25zdCBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXG4gIHBvc3NpYmxlID0gL1smPD5cIidgPV0vO1xuXG5mdW5jdGlvbiBlc2NhcGVDaGFyKGNocikge1xuICByZXR1cm4gZXNjYXBlW2Nocl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQob2JqIC8qICwgLi4uc291cmNlICovKSB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgbGV0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gU291cmNlZCBmcm9tIGxvZGFzaFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xubGV0IGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufTtcbi8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICApO1xuICB9O1xufVxuZXhwb3J0IHsgaXNGdW5jdGlvbiB9O1xuLyogZXNsaW50LWVuYWJsZSBmdW5jLXN0eWxlICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNBcnJheSA9XG4gIEFycmF5LmlzQXJyYXkgfHxcbiAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgICAgPyB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuLy8gT2xkZXIgSUUgdmVyc2lvbnMgZG8gbm90IGRpcmVjdGx5IHN1cHBvcnQgaW5kZXhPZiBzbyB3ZSBtdXN0IGltcGxlbWVudCBvdXIgb3duLCBzYWRseS5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgZXNjYXBlIFNhZmVTdHJpbmdzLCBzaW5jZSB0aGV5J3JlIGFscmVhZHkgc2FmZVxuICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xuICAgICAgcmV0dXJuIHN0cmluZy50b0hUTUwoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICsgJyc7XG4gICAgfVxuXG4gICAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJhbWUob2JqZWN0KSB7XG4gIGxldCBmcmFtZSA9IGV4dGVuZCh7fSwgb2JqZWN0KTtcbiAgZnJhbWUuX3BhcmVudCA9IG9iamVjdDtcbiAgcmV0dXJuIGZyYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxvY2tQYXJhbXMocGFyYW1zLCBpZHMpIHtcbiAgcGFyYW1zLnBhdGggPSBpZHM7XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDb250ZXh0UGF0aChjb250ZXh0UGF0aCwgaWQpIHtcbiAgcmV0dXJuIChjb250ZXh0UGF0aCA/IGNvbnRleHRQYXRoICsgJy4nIDogJycpICsgaWQ7XG59XG4iXX0=


/***/ }),

/***/ "./node_modules/handlebars/runtime.js":
/*!********************************************!*\
  !*** ./node_modules/handlebars/runtime.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = __webpack_require__(/*! ./dist/cjs/handlebars.runtime */ "./node_modules/handlebars/dist/cjs/handlebars.runtime.js")['default'];


/***/ }),

/***/ "./node_modules/pkijs/src/AccessDescription.js":
/*!*****************************************************!*\
  !*** ./node_modules/pkijs/src/AccessDescription.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AccessDescription; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class AccessDescription
{
	//**********************************************************************************
	/**
	 * Constructor for AccessDescription class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc The type and format of the information are specified by the accessMethod field. This profile defines two accessMethod OIDs: id-ad-caIssuers and id-ad-ocsp
		 */
		this.accessMethod = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "accessMethod", AccessDescription.defaultValues("accessMethod"));
		/**
		 * @type {GeneralName}
		 * @desc The accessLocation field specifies the location of the information
		 */
		this.accessLocation = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "accessLocation", AccessDescription.defaultValues("accessLocation"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "accessMethod":
				return "";
			case "accessLocation":
				return new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			default:
				throw new Error(`Invalid member name for AccessDescription class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AccessDescription  ::=  SEQUENCE {
	 *    accessMethod          OBJECT IDENTIFIER,
	 *    accessLocation        GeneralName  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [accessMethod]
		 * @property {string} [accessLocation]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.accessMethod || "") }),
				_GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.accessLocation || {})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"accessMethod",
			"accessLocation"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AccessDescription.schema({
				names: {
					accessMethod: "accessMethod",
					accessLocation: {
						names: {
							blockName: "accessLocation"
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AccessDescription");
		//endregion

		//region Get internal properties from parsed schema
		this.accessMethod = asn1.result.accessMethod.valueBlock.toString();
		this.accessLocation = new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.accessLocation });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.accessMethod }),
				this.accessLocation.toSchema()
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			accessMethod: this.accessMethod,
			accessLocation: this.accessLocation.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/Accuracy.js":
/*!********************************************!*\
  !*** ./node_modules/pkijs/src/Accuracy.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Accuracy; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC3161. Accuracy represents the time deviation around the UTC time contained in GeneralizedTime.
 */
class Accuracy
{
	//**********************************************************************************
	/**
	 * Constructor for Accuracy class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("seconds" in parameters)
			/**
			 * @type {number}
			 * @desc seconds
			 */
			this.seconds = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "seconds", Accuracy.defaultValues("seconds"));
		
		if("millis" in parameters)
			/**
			 * @type {number}
			 * @desc millis
			 */
			this.millis = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "millis", Accuracy.defaultValues("millis"));
		
		if("micros" in parameters)
			/**
			 * @type {number}
			 * @desc micros
			 */
			this.micros = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "micros", Accuracy.defaultValues("micros"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "seconds":
			case "millis":
			case "micros":
				return 0;
			default:
				throw new Error(`Invalid member name for Accuracy class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "seconds":
			case "millis":
			case "micros":
				return (memberValue === Accuracy.defaultValues(memberName));
			default:
				throw new Error(`Invalid member name for Accuracy class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * Accuracy ::= SEQUENCE {
	 *    seconds        INTEGER              OPTIONAL,
	 *    millis     [0] INTEGER  (1..999)    OPTIONAL,
	 *    micros     [1] INTEGER  (1..999)    OPTIONAL  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [seconds]
		 * @property {string} [millis]
		 * @property {string} [micros]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			optional: true,
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
					optional: true,
					name: (names.seconds || "")
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.millis || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.micros || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					}
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"seconds",
			"millis",
			"micros"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			Accuracy.schema({
				names: {
					seconds: "seconds",
					millis: "millis",
					micros: "micros"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for Accuracy");
		//endregion

		//region Get internal properties from parsed schema
		if("seconds" in asn1.result)
			this.seconds = asn1.result.seconds.valueBlock.valueDec;

		if("millis" in asn1.result)
		{
			const intMillis = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: asn1.result.millis.valueBlock.valueHex });
			this.millis = intMillis.valueBlock.valueDec;
		}

		if("micros" in asn1.result)
		{
			const intMicros = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: asn1.result.micros.valueBlock.valueHex });
			this.micros = intMicros.valueBlock.valueDec;
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array of output sequence
		const outputArray = [];

		if("seconds" in this)
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.seconds }));

		if("millis" in this)
		{
			const intMillis = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.millis });

			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				valueHex: intMillis.valueBlock.valueHex
			}));
		}

		if("micros" in this)
		{
			const intMicros = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.micros });

			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				valueHex: intMicros.valueBlock.valueHex
			}));
		}
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {};

		if("seconds" in this)
			_object.seconds = this.seconds;

		if("millis" in this)
			_object.millis = this.millis;

		if("micros" in this)
			_object.micros = this.micros;

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/AlgorithmIdentifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/pkijs/src/AlgorithmIdentifier.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlgorithmIdentifier; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5280
 */
class AlgorithmIdentifier
{
	//**********************************************************************************
	/**
	 * Constructor for AlgorithmIdentifier class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc ObjectIdentifier for algorithm (string representation)
		 */
		this.algorithmId = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "algorithmId", AlgorithmIdentifier.defaultValues("algorithmId"));

		if("algorithmParams" in parameters)
			/**
			 * @type {Object}
			 * @desc Any algorithm parameters
			 */
			this.algorithmParams = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "algorithmParams", AlgorithmIdentifier.defaultValues("algorithmParams"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "algorithmId":
				return "";
			case "algorithmParams":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
			default:
				throw new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "algorithmId":
				return (memberValue === "");
			case "algorithmParams":
				return (memberValue instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]);
			default:
				throw new Error(`Invalid member name for AlgorithmIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AlgorithmIdentifier  ::=  Sequence  {
	 *    algorithm               OBJECT IDENTIFIER,
	 *    parameters              ANY DEFINED BY algorithm OPTIONAL  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm
		 * @property {string} algorithmParams Any algorithm parameters
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			optional: (names.optional || false),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.algorithmIdentifier || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.algorithmParams || ""), optional: true })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"algorithm",
			"params"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AlgorithmIdentifier.schema({
				names: {
					algorithmIdentifier: "algorithm",
					algorithmParams: "params"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");
		//endregion

		//region Get internal properties from parsed schema
		this.algorithmId = asn1.result.algorithm.valueBlock.toString();
		if("params" in asn1.result)
			this.algorithmParams = asn1.result.params;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.algorithmId }));
		if(("algorithmParams" in this) && ((this.algorithmParams instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]) === false))
			outputArray.push(this.algorithmParams);
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			algorithmId: this.algorithmId
		};

		if(("algorithmParams" in this) && ((this.algorithmParams instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]) === false))
			object.algorithmParams = this.algorithmParams.toJSON();

		return object;
	}
	//**********************************************************************************
	/**
	 * Check that two "AlgorithmIdentifiers" are equal
	 * @param {AlgorithmIdentifier} algorithmIdentifier
	 * @returns {boolean}
	 */
	isEqual(algorithmIdentifier)
	{
		//region Check input type
		if((algorithmIdentifier instanceof AlgorithmIdentifier) === false)
			return false;
		//endregion

		//region Check "algorithm_id"
		if(this.algorithmId !== algorithmIdentifier.algorithmId)
			return false;
		//endregion

		//region Check "algorithm_params"
		if("algorithmParams" in this)
		{
			if("algorithmParams" in algorithmIdentifier)
				return JSON.stringify(this.algorithmParams) === JSON.stringify(algorithmIdentifier.algorithmParams);

			return false;
		}

		if("algorithmParams" in algorithmIdentifier)
			return false;
		//endregion

		return true;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/AltName.js":
/*!*******************************************!*\
  !*** ./node_modules/pkijs/src/AltName.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AltName; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class AltName
{
	//**********************************************************************************
	/**
	 * Constructor for AltName class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<GeneralName>}
		 * @desc Array of alternative names in GeneralName type
		 */
		this.altNames = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "altNames", AltName.defaultValues("altNames"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "altNames":
				return [];
			default:
				throw new Error(`Invalid member name for AltName class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AltName ::= GeneralNames
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [altNames]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.altNames || ""),
					value: _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"altNames"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AltName.schema({
				names: {
					altNames: "altNames"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AltName");
		//endregion

		//region Get internal properties from parsed schema
		if("altNames" in asn1.result)
			this.altNames = Array.from(asn1.result.altNames, element => new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.altNames, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			altNames: Array.from(this.altNames, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/Attribute.js":
/*!*********************************************!*\
  !*** ./node_modules/pkijs/src/Attribute.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Attribute; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC2986
 */
class Attribute {
	//**********************************************************************************
	/**
	 * Constructor for Attribute class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc ObjectIdentifier for attribute (string representation)
		 */
		this.type = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "type", Attribute.defaultValues("type"));
		/**
		 * @type {Array}
		 * @desc Any attribute values
		 */
		this.values = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "values", Attribute.defaultValues("values"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "type":
				return "";
			case "values":
				return [];
			default:
				throw new Error(`Invalid member name for Attribute class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "type":
				return (memberValue === "");
			case "values":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for Attribute class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
	 *    type   ATTRIBUTE.&id({IOSet}),
	 *    values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [type]
		 * @property {string} [setName]
		 * @property {string} [values]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.type || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					name: (names.setName || ""),
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.values || ""),
							value: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"type",
			"values"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			Attribute.schema({
				names: {
					type: "type",
					values: "values"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for Attribute");
		//endregion
		
		//region Get internal properties from parsed schema
		this.type = asn1.result.type.valueBlock.toString();
		this.values = asn1.result.values;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.type }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					value: this.values
				})
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			type: this.type,
			values: Array.from(this.values, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/AttributeCertificateV1.js":
/*!**********************************************************!*\
  !*** ./node_modules/pkijs/src/AttributeCertificateV1.js ***!
  \**********************************************************/
/*! exports provided: AttCertValidityPeriod, IssuerSerial, AttributeCertificateInfoV1, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttCertValidityPeriod", function() { return AttCertValidityPeriod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IssuerSerial", function() { return IssuerSerial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeCertificateInfoV1", function() { return AttributeCertificateInfoV1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AttributeCertificateV1; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralNames.js */ "./node_modules/pkijs/src/GeneralNames.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Extensions.js */ "./node_modules/pkijs/src/Extensions.js");






//**************************************************************************************
/**
 * Class from RFC5755
 */
class AttCertValidityPeriod
{
	//**********************************************************************************
	/**
	 * Constructor for AttCertValidityPeriod class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {GeneralizedTime}
		 * @desc notBeforeTime
		 */
		this.notBeforeTime = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "notBeforeTime", AttCertValidityPeriod.defaultValues("notBeforeTime"));
		/**
		 * @type {GeneralizedTime}
		 * @desc notAfterTime
		 */
		this.notAfterTime = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "notAfterTime", AttCertValidityPeriod.defaultValues("notAfterTime"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "notBeforeTime":
			case "notAfterTime":
				return new Date(0, 0, 0);
			default:
				throw new Error(`Invalid member name for AttCertValidityPeriod class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AttCertValidityPeriod  ::= SEQUENCE {
	 *   notBeforeTime  GeneralizedTime,
	 *   notAfterTime   GeneralizedTime
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [notBeforeTime]
		 * @property {string} [notAfterTime]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ name: (names.notBeforeTime || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ name: (names.notAfterTime || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"notBeforeTime",
			"notAfterTime"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AttCertValidityPeriod.schema({
				names: {
					notBeforeTime: "notBeforeTime",
					notAfterTime: "notAfterTime"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AttCertValidityPeriod");
		//endregion
		
		//region Get internal properties from parsed schema
		this.notBeforeTime = asn1.result.notBeforeTime.toDate();
		this.notAfterTime = asn1.result.notAfterTime.toDate();
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueDate: this.notBeforeTime }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueDate: this.notAfterTime }),
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			notBeforeTime: this.notBeforeTime,
			notAfterTime: this.notAfterTime
		};
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Class from RFC5755
 */
class IssuerSerial
{
	//**********************************************************************************
	/**
	 * Constructor for IssuerSerial class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {RelativeDistinguishedNames}
		 * @desc issuer
		 */
		this.issuer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuer", IssuerSerial.defaultValues("issuer"));
		/**
		 * @type {Integer}
		 * @desc serialNumber
		 */
		this.serialNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "serialNumber", IssuerSerial.defaultValues("serialNumber"));
		
		if("issuerUID" in parameters)
			/**
			 * @type {BitString}
			 * @desc issuerUID
			 */
			this.issuerUID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuerUID", IssuerSerial.defaultValues("issuerUID"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "issuer":
				return new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "serialNumber":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "issuerUID":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for IssuerSerial class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * IssuerSerial  ::=  SEQUENCE {
	 *   	issuer         GeneralNames,
	 * 		serial         CertificateSerialNumber,
	 * 		issuerUID      UniqueIdentifier OPTIONAL
	 * }
	 *
	 * CertificateSerialNumber ::= INTEGER
	 * UniqueIdentifier  ::=  BIT STRING
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [issuer]
		 * @property {string} [serialNumber]
		 * @property {string} [issuerUID]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.issuer || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.serialNumber || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({
					optional: true,
					name: (names.issuerUID || "")
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"issuer",
			"serialNumber",
			"issuerUID"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			IssuerSerial.schema({
				names: {
					issuer: {
						names: {
							blockName: "issuer"
						}
					},
					serialNumber: "serialNumber",
					issuerUID: "issuerUID"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for IssuerSerial");
		//endregion
		
		//region Get internal properties from parsed schema
		this.issuer = new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.issuer });
		this.serialNumber = asn1.result.serialNumber;
		
		if("issuerUID" in asn1.result)
			this.issuerUID = asn1.result.issuerUID;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const result = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.issuer.toSchema(),
				this.serialNumber
			]
		});
		
		if("issuerUID" in this)
			result.valueBlock.value.push(this.issuerUID);
		
		//region Construct and return new ASN.1 schema for this object
		return result;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const result = {
			issuer: this.issuer.toJSON(),
			serialNumber: this.serialNumber.toJSON()
		};
		
		if("issuerUID" in this)
			result.issuerUID = this.issuerUID.toJSON();
		
		return result;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Class from RFC5755
 */
class AttributeCertificateInfoV1
{
	//**********************************************************************************
	/**
	 * Constructor for AttributeCertificateInfoV1 class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", AttributeCertificateInfoV1.defaultValues("version"));
		
		if("baseCertificateID" in parameters)
			/**
			 * @type {IssuerSerial}
			 * @desc baseCertificateID
			 */
			this.baseCertificateID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "baseCertificateID", AttributeCertificateInfoV1.defaultValues("baseCertificateID"));
		
		if("subjectName" in parameters)
			/**
			 * @type {GeneralNames}
			 * @desc subjectName
			 */
			this.subjectName = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subjectName", AttributeCertificateInfoV1.defaultValues("subjectName"));

		/**
		 * @type {GeneralNames}
		 * @desc issuer
		 */
		this.issuer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuer", AttributeCertificateInfoV1.defaultValues("issuer"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc signature
		 */
		this.signature = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signature", AttributeCertificateInfoV1.defaultValues("signature"));
		/**
		 * @type {Integer}
		 * @desc serialNumber
		 */
		this.serialNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "serialNumber", AttributeCertificateInfoV1.defaultValues("serialNumber"));
		/**
		 * @type {AttCertValidityPeriod}
		 * @desc attrCertValidityPeriod
		 */
		this.attrCertValidityPeriod = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "attrCertValidityPeriod", AttributeCertificateInfoV1.defaultValues("attrCertValidityPeriod"));
		/**
		 * @type {Array.<Attribute>}
		 * @desc attributes
		 */
		this.attributes = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "attributes", AttributeCertificateInfoV1.defaultValues("attributes"));
		
		if("issuerUniqueID" in parameters)
			/**
			 * @type {BitString}
			 * @desc issuerUniqueID
			 */
			this.issuerUniqueID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuerUniqueID", AttributeCertificateInfoV1.defaultValues("issuerUniqueID"));
			
		if("extensions" in parameters)
			/**
			 * @type {Extensions}
			 * @desc extensions
			 */
			this.extensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "extensions", AttributeCertificateInfoV1.defaultValues("extensions"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "baseCertificateID":
				return new IssuerSerial();
			case "subjectName":
				return new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "issuer":
				return {};
			case "signature":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "serialNumber":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "attrCertValidityPeriod":
				return new AttCertValidityPeriod();
			case "attributes":
				return [];
			case "issuerUniqueID":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			case "extensions":
				return new _Extensions_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			default:
				throw new Error(`Invalid member name for AttributeCertificateInfoV1 class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AttributeCertificateInfo ::= SEQUENCE {
	 * 	version Version DEFAULT v1,
	 * 	subject CHOICE {
	 * 		baseCertificateID [0] IssuerSerial, -- associated with a Public Key Certificate
	 * 		subjectName [1] GeneralNames }, -- associated with a name
	 * 	issuer GeneralNames, -- CA issuing the attribute certificate
	 * 	signature AlgorithmIdentifier,
	 * 	serialNumber CertificateSerialNumber,
	 * 	attrCertValidityPeriod AttCertValidityPeriod,
	 * 	attributes SEQUENCE OF Attribute,
	 * 	issuerUniqueID UniqueIdentifier OPTIONAL,
	 * 	extensions Extensions OPTIONAL
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [issuer]
		 * @property {string} [serialNumber]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							name: (names.baseCertificateID || ""),
							idBlock: {
								tagClass: 3,
								tagNumber: 0 // [0]
							},
							value: IssuerSerial.schema().valueBlock.value
						}),
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							name: (names.subjectName || ""),
							idBlock: {
								tagClass: 3,
								tagNumber: 1 // [2]
							},
							value: _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema().valueBlock.value
						}),
					]
				}),
				_GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema({
					names: {
						blockName: (names.issuer || "")
					}
				}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.signature || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.serialNumber || "") }),
				AttCertValidityPeriod.schema(names.attrCertValidityPeriod || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					name: (names.attributes || ""),
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							value: _Attribute_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema()
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({
					optional: true,
					name: (names.issuerUniqueID || "")
				}),
				_Extensions_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.extensions || {}, true)
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"baseCertificateID",
			"subjectName",
			"issuer",
			"signature",
			"serialNumber",
			"attrCertValidityPeriod",
			"attributes",
			"issuerUniqueID",
			"extensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AttributeCertificateInfoV1.schema({
				names: {
					version: "version",
					baseCertificateID: "baseCertificateID",
					subjectName: "subjectName",
					issuer: "issuer",
					signature: {
						names: {
							blockName: "signature"
						}
					},
					serialNumber: "serialNumber",
					attrCertValidityPeriod: {
						names: {
							blockName: "attrCertValidityPeriod"
						}
					},
					attributes: "attributes",
					issuerUniqueID: "issuerUniqueID",
					extensions: {
						names: {
							blockName: "extensions"
						}
					}
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AttributeCertificateInfoV1");
		//endregion
		
		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		
		if("baseCertificateID" in asn1.result)
		{
			this.baseCertificateID = new IssuerSerial({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.baseCertificateID.valueBlock.value
				})
			});
		}
		
		if("subjectName" in asn1.result)
		{
			this.subjectName = new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.subjectName.valueBlock.value
				})
			});
		}
		
		this.issuer = asn1.result.issuer;
		this.signature = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.signature });
		this.serialNumber = asn1.result.serialNumber;
		this.attrCertValidityPeriod = new AttCertValidityPeriod({ schema: asn1.result.attrCertValidityPeriod });
		this.attributes = Array.from(asn1.result.attributes.valueBlock.value, element => new _Attribute_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: element }));
		
		if("issuerUniqueID" in asn1.result)
			this.issuerUniqueID = asn1.result.issuerUniqueID;
		
		if("extensions" in asn1.result)
			this.extensions = new _Extensions_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result.extensions });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const result = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version })]
		});
		
		if("baseCertificateID" in this)
		{
			result.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3,
					tagNumber: 0 // [0]
				},
				value: this.baseCertificateID.toSchema().valueBlock.value
			}));
		}
		
		if("subjectName" in this)
		{
			result.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3,
					tagNumber: 1 // [1]
				},
				value: this.subjectName.toSchema().valueBlock.value
			}));
		}
		
		result.valueBlock.value.push(this.issuer.toSchema());
		result.valueBlock.value.push(this.signature.toSchema());
		result.valueBlock.value.push(this.serialNumber);
		result.valueBlock.value.push(this.attrCertValidityPeriod.toSchema());
		result.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.attributes, element => element.toSchema())
		}));
		
		if("issuerUniqueID" in this)
			result.valueBlock.value.push(this.issuerUniqueID);
		
		if("extensions" in this)
			result.valueBlock.value.push(this.extensions.toSchema());
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const result = {
			version: this.version
		};
		
		if("baseCertificateID" in this)
			result.baseCertificateID = this.baseCertificateID.toJSON();
		
		if("subjectName" in this)
			result.subjectName = this.subjectName.toJSON();

		result.issuer = this.issuer.toJSON();
		result.signature = this.signature.toJSON();
		result.serialNumber = this.serialNumber.toJSON();
		result.attrCertValidityPeriod = this.attrCertValidityPeriod.toJSON();
		result.attributes = Array.from(this.attributes, element => element.toJSON());
		
		if("issuerUniqueID" in this)
			result.issuerUniqueID = this.issuerUniqueID.toJSON();
		
		if("extensions" in this)
			result.extensions = this.extensions.toJSON();
		
		return result;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Class from X.509:1997
 */
class AttributeCertificateV1
{
	//**********************************************************************************
	/**
	 * Constructor for AttributeCertificateV1 class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AttributeCertificateInfoV1}
		 * @desc acinfo
		 */
		this.acinfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "acinfo", AttributeCertificateV1.defaultValues("acinfo"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc signatureAlgorithm
		 */
		this.signatureAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureAlgorithm", AttributeCertificateV1.defaultValues("signatureAlgorithm"));
		/**
		 * @type {BitString}
		 * @desc signatureValue
		 */
		this.signatureValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureValue", AttributeCertificateV1.defaultValues("signatureValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "acinfo":
				return new AttributeCertificateInfoV1();
			case "signatureAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "signatureValue":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for AttributeCertificateV1 class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AttributeCertificate ::= SEQUENCE {
	 *   acinfo               AttributeCertificateInfoV1,
	 *   signatureAlgorithm   AlgorithmIdentifier,
	 *   signatureValue       BIT STRING
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {Object} [acinfo]
		 * @property {Object} [signatureAlgorithm]
		 * @property {string} [signatureValue]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				AttributeCertificateInfoV1.schema(names.acinfo || {}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.signatureAlgorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.signatureValue || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"acinfo",
			"signatureValue",
			"signatureAlgorithm"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AttributeCertificateV1.schema({
				names: {
					acinfo: {
						names: {
							blockName: "acinfo"
						}
					},
					signatureAlgorithm: {
						names: {
							blockName: "signatureAlgorithm"
						}
					},
					signatureValue: "signatureValue"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AttributeCertificateV1");
		//endregion
		
		//region Get internal properties from parsed schema
		this.acinfo = new AttributeCertificateInfoV1({ schema: asn1.result.acinfo });
		this.signatureAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.signatureAlgorithm });
		this.signatureValue = asn1.result.signatureValue;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.acinfo.toSchema(),
				this.signatureAlgorithm.toSchema(),
				this.signatureValue
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			acinfo: this.acinfo.toJSON(),
			signatureAlgorithm: this.signatureAlgorithm.toJSON(),
			signatureValue: this.signatureValue.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/AttributeCertificateV2.js":
/*!**********************************************************!*\
  !*** ./node_modules/pkijs/src/AttributeCertificateV2.js ***!
  \**********************************************************/
/*! exports provided: ObjectDigestInfo, V2Form, Holder, AttributeCertificateInfoV2, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectDigestInfo", function() { return ObjectDigestInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "V2Form", function() { return V2Form; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Holder", function() { return Holder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeCertificateInfoV2", function() { return AttributeCertificateInfoV2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AttributeCertificateV2; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralNames.js */ "./node_modules/pkijs/src/GeneralNames.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Extensions.js */ "./node_modules/pkijs/src/Extensions.js");
/* harmony import */ var _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AttributeCertificateV1.js */ "./node_modules/pkijs/src/AttributeCertificateV1.js");







//**************************************************************************************
/**
 * Class from RFC5755
 */
class ObjectDigestInfo
{
	//**********************************************************************************
	/**
	 * Constructor for ObjectDigestInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Enumerated}
		 * @desc digestedObjectType
		 */
		this.digestedObjectType = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "digestedObjectType", ObjectDigestInfo.defaultValues("digestedObjectType"));
		
		if("otherObjectTypeID" in parameters)
			/**
			 * @type {ObjectIdentifier}
			 * @desc otherObjectTypeID
			 */
			this.otherObjectTypeID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "otherObjectTypeID", ObjectDigestInfo.defaultValues("otherObjectTypeID"));
		
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc digestAlgorithm
		 */
		this.digestAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "digestAlgorithm", ObjectDigestInfo.defaultValues("digestAlgorithm"));
		/**
		 * @type {BitString}
		 * @desc objectDigest
		 */
		this.objectDigest = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "objectDigest", ObjectDigestInfo.defaultValues("objectDigest"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "digestedObjectType":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Enumerated"]();
			case "otherObjectTypeID":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]();
			case "digestAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "objectDigest":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for ObjectDigestInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * ObjectDigestInfo ::= SEQUENCE {
	 *   digestedObjectType  ENUMERATED {
	 *     publicKey            (0),
	 *     publicKeyCert        (1),
	 *     otherObjectTypes     (2) },
	 *   -- otherObjectTypes MUST NOT
	 *   -- be used in this profile
	 *   otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
	 *   digestAlgorithm     AlgorithmIdentifier,
	 *   objectDigest        BIT STRING
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [digestedObjectType]
		 * @property {string} [otherObjectTypeID]
		 * @property {string} [digestAlgorithm]
		 * @property {string} [objectDigest]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Enumerated"]({ name: (names.digestedObjectType || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({
					optional: true,
					name: (names.otherObjectTypeID || "")
				}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.digestAlgorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.objectDigest || "") }),
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"digestedObjectType",
			"otherObjectTypeID",
			"digestAlgorithm",
			"objectDigest"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			ObjectDigestInfo.schema({
				names: {
					digestedObjectType: "digestedObjectType",
					otherObjectTypeID: "otherObjectTypeID",
					digestAlgorithm: {
						names: {
							blockName: "digestAlgorithm"
						}
					},
					objectDigest: "objectDigest"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for ObjectDigestInfo");
		//endregion
		
		//region Get internal properties from parsed schema
		this.digestedObjectType = asn1.result.digestedObjectType;
		
		if("otherObjectTypeID" in asn1.result)
			this.otherObjectTypeID = asn1.result.otherObjectTypeID;
		
		this.digestAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.digestAlgorithm });
		this.objectDigest = asn1.result.objectDigest;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const result = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [this.digestedObjectType]
		});
		
		if("otherObjectTypeID" in this)
			result.valueBlock.value.push(this.otherObjectTypeID);
		
		result.valueBlock.value.push(this.digestAlgorithm.toSchema());
		result.valueBlock.value.push(this.objectDigest);
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const result = {
			digestedObjectType: this.digestedObjectType.toJSON()
		};
		
		if("otherObjectTypeID" in this)
			result.otherObjectTypeID = this.otherObjectTypeID.toJSON();
		
		result.digestAlgorithm = this.digestAlgorithm.toJSON();
		result.objectDigest = this.objectDigest.toJSON();
		
		return result;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Class from RFC5755
 */
class V2Form
{
	//**********************************************************************************
	/**
	 * Constructor for V2Form class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("issuerName" in parameters)
			/**
			 * @type {GeneralNames}
			 * @desc issuerName
			 */
			this.issuerName = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuerName", V2Form.defaultValues("issuerName"));
		
		if("baseCertificateID" in parameters)
			/**
			 * @type {IssuerSerial}
			 * @desc baseCertificateID
			 */
			this.baseCertificateID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "baseCertificateID", V2Form.defaultValues("baseCertificateID"));
		
		if("objectDigestInfo" in parameters)
			/**
			 * @type {ObjectDigestInfo}
			 * @desc objectDigestInfo
			 */
			this.objectDigestInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "objectDigestInfo", V2Form.defaultValues("objectDigestInfo"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "issuerName":
				return new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "baseCertificateID":
				return new _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__["IssuerSerial"]();
			case "objectDigestInfo":
				return new ObjectDigestInfo();
			default:
				throw new Error(`Invalid member name for V2Form class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * V2Form ::= SEQUENCE {
	 *   issuerName            GeneralNames  OPTIONAL,
	 *   baseCertificateID     [0] IssuerSerial  OPTIONAL,
	 *   objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL
	 *     -- issuerName MUST be present in this profile
	 *     -- baseCertificateID and objectDigestInfo MUST NOT
	 *     -- be present in this profile
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [issuerName]
		 * @property {string} [baseCertificateID]
		 * @property {string} [objectDigestInfo]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema({
					names: {
						blockName: names.issuerName
					}
				}, true),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					name: (names.baseCertificateID || ""),
					idBlock: {
						tagClass: 3,
						tagNumber: 0 // [0]
					},
					value: _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__["IssuerSerial"].schema().valueBlock.value
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					name: (names.objectDigestInfo || ""),
					idBlock: {
						tagClass: 3,
						tagNumber: 1 // [1]
					},
					value: ObjectDigestInfo.schema().valueBlock.value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"issuerName",
			"baseCertificateID",
			"objectDigestInfo"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			V2Form.schema({
				names: {
					issuerName: "issuerName",
					baseCertificateID: "baseCertificateID",
					objectDigestInfo: "objectDigestInfo"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for V2Form");
		//endregion
		
		//region Get internal properties from parsed schema
		if("issuerName" in asn1.result)
			this.issuerName = new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.issuerName });
		
		if("baseCertificateID" in asn1.result)
		{
			this.baseCertificateID = new _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__["IssuerSerial"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.baseCertificateID.valueBlock.value
				})
			});
		}
		
		if("objectDigestInfo" in asn1.result)
		{
			this.objectDigestInfo = new ObjectDigestInfo({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.objectDigestInfo.valueBlock.value
				})
			});
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const result = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]();
		
		if("issuerName" in this)
			result.valueBlock.value.push(this.issuerName.toSchema());
		
		if("baseCertificateID" in this)
		{
			result.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3,
					tagNumber: 0 // [0]
				},
				value: this.baseCertificateID.toSchema().valueBlock.value
			}));
		}
		
		if("objectDigestInfo" in this)
		{
			result.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3,
					tagNumber: 1 // [1]
				},
				value: this.objectDigestInfo.toSchema().valueBlock.value
			}));
		}
		
		//region Construct and return new ASN.1 schema for this object
		return result;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const result = {};
		
		if("issuerName" in this)
			result.issuerName = this.issuerName.toJSON();
		
		if("baseCertificateID" in this)
			result.baseCertificateID = this.baseCertificateID.toJSON();
		
		if("objectDigestInfo" in this)
			result.objectDigestInfo = this.objectDigestInfo.toJSON();
		
		return result;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Class from RFC5755
 */
class Holder
{
	//**********************************************************************************
	/**
	 * Constructor for Holder class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("baseCertificateID" in parameters)
			/**
			 * @type {IssuerSerial}
			 * @desc baseCertificateID
			 */
			this.baseCertificateID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "baseCertificateID", Holder.defaultValues("baseCertificateID"));
		
		if("entityName" in parameters)
			/**
			 * @type {GeneralNames}
			 * @desc entityName
			 */
			this.entityName = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "entityName", Holder.defaultValues("entityName"));
		
		if("objectDigestInfo" in parameters)
			/**
			 * @type {ObjectDigestInfo}
			 * @desc objectDigestInfo
			 */
			this.objectDigestInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "objectDigestInfo", Holder.defaultValues("objectDigestInfo"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "baseCertificateID":
				return new _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__["IssuerSerial"]();
			case "entityName":
				return new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "objectDigestInfo":
				return new ObjectDigestInfo();
			default:
				throw new Error(`Invalid member name for Holder class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * Holder ::= SEQUENCE {
	 *   baseCertificateID   [0] IssuerSerial OPTIONAL,
	 *       -- the issuer and serial number of
	 *       -- the holder's Public Key Certificate
	 *   entityName          [1] GeneralNames OPTIONAL,
	 *       -- the name of the claimant or role
	 *   objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
	 *       -- used to directly authenticate the holder,
	 *       -- for example, an executable
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [baseCertificateID]
		 * @property {string} [entityName]
		 * @property {string} [objectDigestInfo]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					name: (names.baseCertificateID || ""),
					idBlock: {
						tagClass: 3,
						tagNumber: 0 // [0]
					},
					value: _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__["IssuerSerial"].schema().valueBlock.value
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					name: (names.entityName || ""),
					idBlock: {
						tagClass: 3,
						tagNumber: 1 // [2]
					},
					value: _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema().valueBlock.value
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					name: (names.objectDigestInfo || ""),
					idBlock: {
						tagClass: 3,
						tagNumber: 2 // [2]
					},
					value: ObjectDigestInfo.schema().valueBlock.value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"baseCertificateID",
			"entityName",
			"objectDigestInfo"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			Holder.schema({
				names: {
					baseCertificateID: "baseCertificateID",
					entityName: "entityName",
					objectDigestInfo: "objectDigestInfo"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for Holder");
		//endregion
		
		//region Get internal properties from parsed schema
		if("baseCertificateID" in asn1.result)
		{
			this.baseCertificateID = new _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__["IssuerSerial"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.baseCertificateID.valueBlock.value
				})
			});
		}
		
		if("entityName" in asn1.result)
		{
			this.entityName = new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.entityName.valueBlock.value
				})
			});
		}
		
		if("objectDigestInfo" in asn1.result)
		{
			this.objectDigestInfo = new ObjectDigestInfo({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.objectDigestInfo.valueBlock.value
				})
			});
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const result = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]();
		
		if("baseCertificateID" in this)
		{
			result.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3,
					tagNumber: 0 // [0]
				},
				value: this.baseCertificateID.toSchema().valueBlock.value
			}));
		}
		
		if("entityName" in this)
		{
			result.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3,
					tagNumber: 1 // [1]
				},
				value: this.entityName.toSchema().valueBlock.value
			}));
		}
		
		if("objectDigestInfo" in this)
		{
			result.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3,
					tagNumber: 2 // [2]
				},
				value: this.objectDigestInfo.toSchema().valueBlock.value
			}));
		}
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const result = {};
		
		if("baseCertificateID" in this)
			result.baseCertificateID = this.baseCertificateID.toJSON();
		
		if("entityName" in this)
			result.entityName = this.entityName.toJSON();
		
		if("objectDigestInfo" in this)
			result.objectDigestInfo = this.objectDigestInfo.toJSON();
		
		return result;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Class from RFC5755
 */
class AttributeCertificateInfoV2
{
	//**********************************************************************************
	/**
	 * Constructor for AttributeCertificateInfoV2 class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", AttributeCertificateInfoV2.defaultValues("version"));
		/**
		 * @type {Holder}
		 * @desc holder
		 */
		this.holder = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "holder", AttributeCertificateInfoV2.defaultValues("holder"));
		/**
		 * @type {GeneralNames|V2Form}
		 * @desc issuer
		 */
		this.issuer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuer", AttributeCertificateInfoV2.defaultValues("issuer"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc signature
		 */
		this.signature = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signature", AttributeCertificateInfoV2.defaultValues("signature"));
		/**
		 * @type {Integer}
		 * @desc serialNumber
		 */
		this.serialNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "serialNumber", AttributeCertificateInfoV2.defaultValues("serialNumber"));
		/**
		 * @type {AttCertValidityPeriod}
		 * @desc attrCertValidityPeriod
		 */
		this.attrCertValidityPeriod = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "attrCertValidityPeriod", AttributeCertificateInfoV2.defaultValues("attrCertValidityPeriod"));
		/**
		 * @type {Array.<Attribute>}
		 * @desc attributes
		 */
		this.attributes = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "attributes", AttributeCertificateInfoV2.defaultValues("attributes"));
		
		if("issuerUniqueID" in parameters)
			/**
			 * @type {BitString}
			 * @desc issuerUniqueID
			 */
			this.issuerUniqueID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuerUniqueID", AttributeCertificateInfoV2.defaultValues("issuerUniqueID"));
		
		if("extensions" in parameters)
			/**
			 * @type {Extensions}
			 * @desc extensions
			 */
			this.extensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "extensions", AttributeCertificateInfoV2.defaultValues("extensions"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 1;
			case "holder":
				return new Holder();
			case "issuer":
				return {};
			case "signature":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "serialNumber":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "attrCertValidityPeriod":
				return new _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__["AttCertValidityPeriod"]();
			case "attributes":
				return [];
			case "issuerUniqueID":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			case "extensions":
				return new _Extensions_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			default:
				throw new Error(`Invalid member name for AttributeCertificateInfoV2 class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AttributeCertificateInfoV2 ::= SEQUENCE {
	 *   version                 AttCertVersion, -- version is v2
	 *   holder                  Holder,
	 *   issuer                  AttCertIssuer,
	 *   signature               AlgorithmIdentifier,
	 *   serialNumber            CertificateSerialNumber,
	 *   attrCertValidityPeriod  AttCertValidityPeriod,
	 *   attributes              SEQUENCE OF Attribute,
	 *   issuerUniqueID          UniqueIdentifier OPTIONAL,
	 *   extensions              Extensions OPTIONAL
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [issuer]
		 * @property {string} [serialNumber]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				Holder.schema(names.holder || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
					value: [
						_GeneralNames_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema({
							names: {
								blockName: (names.issuer || "")
							}
						}),
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							name: (names.issuer || ""),
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 0 // [0]
							},
							value: V2Form.schema().valueBlock.value
						})
					]
				}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.signature || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.serialNumber || "") }),
				_AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__["AttCertValidityPeriod"].schema(names.attrCertValidityPeriod || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					name: (names.attributes || ""),
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							value: _Attribute_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema()
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({
					optional: true,
					name: (names.issuerUniqueID || "")
				}),
				_Extensions_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.extensions || {}, true)
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"holder",
			"issuer",
			"signature",
			"serialNumber",
			"attrCertValidityPeriod",
			"attributes",
			"issuerUniqueID",
			"extensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AttributeCertificateInfoV2.schema({
				names: {
					version: "version",
					holder: {
						names: {
							blockName: "holder"
						}
					},
					issuer: "issuer",
					signature: {
						names: {
							blockName: "signature"
						}
					},
					serialNumber: "serialNumber",
					attrCertValidityPeriod: {
						names: {
							blockName: "attrCertValidityPeriod"
						}
					},
					attributes: "attributes",
					issuerUniqueID: "issuerUniqueID",
					extensions: {
						names: {
							blockName: "extensions"
						}
					}
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AttributeCertificateInfoV2");
		//endregion
		
		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.holder = new Holder({ schema: asn1.result.holder });
		
		switch(asn1.result.issuer.idBlock.tagClass)
		{
			case 3: // V2Form
				this.issuer = new V2Form({
					schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
						value: asn1.result.issuer.valueBlock.value
					})
				});
				break;
			case 1: // GeneralNames (should not be used)
			default:
				throw new Error("Incorect value for 'issuer' in AttributeCertificateInfoV2");
		}
		
		this.signature = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.signature });
		this.serialNumber = asn1.result.serialNumber;
		this.attrCertValidityPeriod = new _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_6__["AttCertValidityPeriod"]({ schema: asn1.result.attrCertValidityPeriod });
		this.attributes = Array.from(asn1.result.attributes.valueBlock.value, element => new _Attribute_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: element }));
		
		if("issuerUniqueID" in asn1.result)
			this.issuerUniqueID = asn1.result.issuerUniqueID;
		
		if("extensions" in asn1.result)
			this.extensions = new _Extensions_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result.extensions });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const result = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }),
				this.holder.toSchema(),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: this.issuer.toSchema().valueBlock.value
				}),
				this.signature.toSchema(),
				this.serialNumber,
				this.attrCertValidityPeriod.toSchema(),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: Array.from(this.attributes, element => element.toSchema())
				})
			]
		});
		
		if("issuerUniqueID" in this)
			result.valueBlock.value.push(this.issuerUniqueID);
		
		if("extensions" in this)
			result.valueBlock.value.push(this.extensions.toSchema());
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const result = {
			version: this.version,
			holder: this.holder.toJSON(),
			issuer: this.issuer.toJSON(),
			signature: this.signature.toJSON(),
			serialNumber: this.serialNumber.toJSON(),
			attrCertValidityPeriod: this.attrCertValidityPeriod.toJSON(),
			attributes: Array.from(this.attributes, element => element.toJSON())
		};
		
		if("issuerUniqueID" in this)
			result.issuerUniqueID = this.issuerUniqueID.toJSON();
		
		if("extensions" in this)
			result.extensions = this.extensions.toJSON();
		
		return result;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Class from RFC5755
 */
class AttributeCertificateV2
{
	//**********************************************************************************
	/**
	 * Constructor for AttributeCertificateV2 class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AttributeCertificateInfoV2}
		 * @desc acinfo
		 */
		this.acinfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "acinfo", AttributeCertificateV2.defaultValues("acinfo"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc signatureAlgorithm
		 */
		this.signatureAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureAlgorithm", AttributeCertificateV2.defaultValues("signatureAlgorithm"));
		/**
		 * @type {BitString}
		 * @desc signatureValue
		 */
		this.signatureValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureValue", AttributeCertificateV2.defaultValues("signatureValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "acinfo":
				return new AttributeCertificateInfoV2();
			case "signatureAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "signatureValue":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for AttributeCertificateV2 class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AttributeCertificate ::= SEQUENCE {
	 *   acinfo               AttributeCertificateInfoV2,
	 *   signatureAlgorithm   AlgorithmIdentifier,
	 *   signatureValue       BIT STRING
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {Object} [acinfo]
		 * @property {Object} [signatureAlgorithm]
		 * @property {string} [signatureValue]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				AttributeCertificateInfoV2.schema(names.acinfo || {}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.signatureAlgorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.signatureValue || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"acinfo",
			"signatureAlgorithm",
			"signatureValue"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AttributeCertificateV2.schema({
				names: {
					acinfo: {
						names: {
							blockName: "acinfo"
						}
					},
					signatureAlgorithm: {
						names: {
							blockName: "signatureAlgorithm"
						}
					},
					signatureValue: "signatureValue"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AttributeCertificateV2");
		//endregion
		
		//region Get internal properties from parsed schema
		this.acinfo = new AttributeCertificateInfoV2({ schema: asn1.result.acinfo });
		this.signatureAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.signatureAlgorithm });
		this.signatureValue = asn1.result.signatureValue;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.acinfo.toSchema(),
				this.signatureAlgorithm.toSchema(),
				this.signatureValue
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			acinfo: this.acinfo.toJSON(),
			signatureAlgorithm: this.signatureAlgorithm.toJSON(),
			signatureValue: this.signatureValue.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/AttributeTypeAndValue.js":
/*!*********************************************************!*\
  !*** ./node_modules/pkijs/src/AttributeTypeAndValue.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AttributeTypeAndValue; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class AttributeTypeAndValue
{
	//**********************************************************************************
	/**
	 * Constructor for AttributeTypeAndValue class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc type
		 */
		this.type = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "type", AttributeTypeAndValue.defaultValues("type"));
		/**
		 * @type {Object}
		 * @desc Value of the AttributeTypeAndValue class
		 */
		this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "value", AttributeTypeAndValue.defaultValues("value"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "type":
				return "";
			case "value":
				return {};
			default:
				throw new Error(`Invalid member name for AttributeTypeAndValue class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AttributeTypeAndValue ::= Sequence {
	 *    type     AttributeType,
	 *    value    AttributeValue }
	 *
	 * AttributeType ::= OBJECT IDENTIFIER
	 *
	 * AttributeValue ::= ANY -- DEFINED BY AttributeType
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName] Name for entire block
		 * @property {string} [type] Name for "type" element
		 * @property {string} [value] Name for "value" element
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.type || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.value || "") })
			]
		}));
	}
	//**********************************************************************************
	static blockName()
	{
		return "AttributeTypeAndValue";
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"type",
			"typeValue"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AttributeTypeAndValue.schema({
				names: {
					type: "type",
					value: "typeValue"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AttributeTypeAndValue");
		//endregion

		//region Get internal properties from parsed schema
		this.type = asn1.result.type.valueBlock.toString();
		// noinspection JSUnresolvedVariable
		this.value = asn1.result.typeValue;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.type }),
				this.value
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			type: this.type
		};

		if(Object.keys(this.value).length !== 0)
			_object.value = this.value.toJSON();
		else
			_object.value = this.value;

		return _object;
	}
	//**********************************************************************************
	/**
	 * Compare two AttributeTypeAndValue values, or AttributeTypeAndValue with ArrayBuffer value
	 * @param {(AttributeTypeAndValue|ArrayBuffer)} compareTo The value compare to current
	 * @returns {boolean}
	 */
	isEqual(compareTo)
	{
		const stringBlockNames = [
			asn1js__WEBPACK_IMPORTED_MODULE_0__["Utf8String"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["BmpString"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["UniversalString"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["NumericString"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["PrintableString"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["TeletexString"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["VideotexString"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["IA5String"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["GraphicString"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["VisibleString"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralString"].blockName(),
			asn1js__WEBPACK_IMPORTED_MODULE_0__["CharacterString"].blockName()
		];

		if(compareTo.constructor.blockName() === AttributeTypeAndValue.blockName())
		{
			if(this.type !== compareTo.type)
				return false;

			//region Check we do have both strings
			let isString = [false, false];
			const thisName = this.value.constructor.blockName();
			for(const name of stringBlockNames)
			{
				if(thisName === name)
				{
					isString[0] = true;
				}
				if(compareTo.value.constructor.blockName() === name)
				{
					isString[1] = true;
				}
			}
			if(isString[0] ^ isString[1])
				return false;

			isString = (isString[0] && isString[1]);
			//endregion

			if(isString)
			{
				const value1 = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["stringPrep"])(this.value.valueBlock.value);
				const value2 = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["stringPrep"])(compareTo.value.valueBlock.value);

				if(value1.localeCompare(value2) !== 0)
					return false;
			}
			else // Comparing as two ArrayBuffers
			{
				if(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(this.value.valueBeforeDecode, compareTo.value.valueBeforeDecode) === false)
					return false;
			}

			return true;
		}

		if(compareTo instanceof ArrayBuffer)
			return Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(this.value.valueBeforeDecode, compareTo);

		return false;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/AuthenticatedSafe.js":
/*!*****************************************************!*\
  !*** ./node_modules/pkijs/src/AuthenticatedSafe.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AuthenticatedSafe; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _ContentInfo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ContentInfo.js */ "./node_modules/pkijs/src/ContentInfo.js");
/* harmony import */ var _SafeContents_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SafeContents.js */ "./node_modules/pkijs/src/SafeContents.js");
/* harmony import */ var _EnvelopedData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EnvelopedData.js */ "./node_modules/pkijs/src/EnvelopedData.js");
/* harmony import */ var _EncryptedData_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EncryptedData.js */ "./node_modules/pkijs/src/EncryptedData.js");






//**************************************************************************************
/**
 * Class from RFC7292
 */
class AuthenticatedSafe
{
	//**********************************************************************************
	/**
	 * Constructor for AuthenticatedSafe class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<ContentInfo>}
		 * @desc safeContents
		 */
		this.safeContents = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "safeContents", AuthenticatedSafe.defaultValues("safeContents"));

		if("parsedValue" in parameters)
			/**
			 * @type {*}
			 * @desc parsedValue
			 */
			this.parsedValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "parsedValue", AuthenticatedSafe.defaultValues("parsedValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "safeContents":
				return [];
			case "parsedValue":
				return {};
			default:
				throw new Error(`Invalid member name for AuthenticatedSafe class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "safeContents":
				return (memberValue.length === 0);
			case "parsedValue":
				return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
			default:
				throw new Error(`Invalid member name for AuthenticatedSafe class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AuthenticatedSafe ::= SEQUENCE OF ContentInfo
	 * -- Data if unencrypted
	 * -- EncryptedData if password-encrypted
	 * -- EnvelopedData if public key-encrypted
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [contentInfos]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.contentInfos || ""),
					value: _ContentInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"contentInfos"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AuthenticatedSafe.schema({
				names: {
					contentInfos: "contentInfos"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AuthenticatedSafe");
		//endregion
		
		//region Get internal properties from parsed schema
		this.safeContents = Array.from(asn1.result.contentInfos, element => new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.safeContents, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			safeContents: Array.from(this.safeContents, element => element.toJSON())
		};
	}
	//**********************************************************************************
	parseInternalValues(parameters)
	{
		//region Check input data from "parameters" 
		if((parameters instanceof Object) === false)
			return Promise.reject("The \"parameters\" must has \"Object\" type");
		
		if(("safeContents" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"safeContents\"");
		
		if((parameters.safeContents instanceof Array) === false)
			return Promise.reject("The \"parameters.safeContents\" must has \"Array\" type");
		
		if(parameters.safeContents.length !== this.safeContents.length)
			return Promise.reject("Length of \"parameters.safeContents\" must be equal to \"this.safeContents.length\"");
		//endregion 
		
		//region Initial variables 
		let sequence = Promise.resolve();
		//endregion
		
		//region Create value for "this.parsedValue.authenticatedSafe" 
		this.parsedValue = {
			safeContents: []
		};
		
		for(const [index, content] of this.safeContents.entries())
		{
			switch(content.contentType)
			{
				//region data 
				case "1.2.840.113549.1.7.1":
					{
						//region Check that we do have OCTETSTRING as "content"
						if((content.content instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]) === false)
							return Promise.reject("Wrong type of \"this.safeContents[j].content\"");
						//endregion
						
						//region Check we have "constructive encoding" for AuthSafe content
						let authSafeContent = new ArrayBuffer(0);
						
						if(content.content.valueBlock.isConstructed)
						{
							for(const contentValue of content.content.valueBlock.value)
								authSafeContent = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(authSafeContent, contentValue.valueBlock.valueHex);
						}
						else
							authSafeContent = content.content.valueBlock.valueHex;
						//endregion
						
						//region Parse internal ASN.1 data
						const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](authSafeContent);
						if(asn1.offset === (-1))
							return Promise.reject("Error during parsing of ASN.1 data inside \"content.content\"");
						//endregion
						
						//region Finilly initialize initial values of "SafeContents" type
						this.parsedValue.safeContents.push({
							privacyMode: 0, // No privacy, clear data
							value: new _SafeContents_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result })
						});
						//endregion
					}
					break;
				//endregion 
				//region envelopedData 
				case "1.2.840.113549.1.7.3":
					{
						//region Initial variables
						const cmsEnveloped = new _EnvelopedData_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: content.content });
						//endregion
						
						//region Check mandatory parameters
						if(("recipientCertificate" in parameters.safeContents[index]) === false)
							return Promise.reject("Absent mandatory parameter \"recipientCertificate\" in \"parameters.safeContents[j]\"");
						
						const recipientCertificate = parameters.safeContents[index].recipientCertificate;
						
						if(("recipientKey" in parameters.safeContents[index]) === false)
							return Promise.reject("Absent mandatory parameter \"recipientKey\" in \"parameters.safeContents[j]\"");
						
						// noinspection JSUnresolvedVariable
						const recipientKey = parameters.safeContents[index].recipientKey;
						//endregion
						
						//region Decrypt CMS EnvelopedData using first recipient information
						sequence = sequence.then(
							() => cmsEnveloped.decrypt(0, {
								recipientCertificate,
								recipientPrivateKey: recipientKey
							})
						);
						
						sequence = sequence.then(
							/**
							 * @param {ArrayBuffer} result
							 */
							result =>
							{
								const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](result);
								if(asn1.offset === (-1))
									return Promise.reject("Error during parsing of decrypted data");
								
								this.parsedValue.safeContents.push({
									privacyMode: 2, // Public-key privacy mode
									value: new _SafeContents_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result })
								});
								
								return Promise.resolve();
							}
						);
						//endregion
					}
					break;
				//endregion   
				//region encryptedData 
				case "1.2.840.113549.1.7.6":
					{
						//region Initial variables
						const cmsEncrypted = new _EncryptedData_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: content.content });
						//endregion
						
						//region Check mandatory parameters
						if(("password" in parameters.safeContents[index]) === false)
							return Promise.reject("Absent mandatory parameter \"password\" in \"parameters.safeContents[j]\"");
						
						const password = parameters.safeContents[index].password;
						//endregion
						
						//region Decrypt CMS EncryptedData using password
						sequence = sequence.then(
							() => cmsEncrypted.decrypt({
								password
							}),
							error => Promise.reject(error)
						);
						//endregion
						
						//region Initialize internal data
						sequence = sequence.then(
							/**
							 * @param {ArrayBuffer} result
							 */
							result =>
							{
								const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](result);
								if(asn1.offset === (-1))
									return Promise.reject("Error during parsing of decrypted data");
								
								this.parsedValue.safeContents.push({
									privacyMode: 1, // Password-based privacy mode
									value: new _SafeContents_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result })
								});
								
								return Promise.resolve();
							},
							error => Promise.reject(error)
						);
						//endregion
					}
					break;
				//endregion   
				//region default 
				default:
					throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${content.contentType}`);
				//endregion 
			}
		}
		//endregion 
		
		return sequence;
	}
	//**********************************************************************************
	makeInternalValues(parameters)
	{
		//region Check data in "parsedValue" 
		if(("parsedValue" in this) === false)
			return Promise.reject("Please run \"parseValues\" first or add \"parsedValue\" manually");
		
		if((this.parsedValue instanceof Object) === false)
			return Promise.reject("The \"this.parsedValue\" must has \"Object\" type");
		
		if((this.parsedValue.safeContents instanceof Array) === false)
			return Promise.reject("The \"this.parsedValue.safeContents\" must has \"Array\" type");
		//endregion 
		
		//region Check input data from "parameters" 
		if((parameters instanceof Object) === false)
			return Promise.reject("The \"parameters\" must has \"Object\" type");
		
		if(("safeContents" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"safeContents\"");
		
		if((parameters.safeContents instanceof Array) === false)
			return Promise.reject("The \"parameters.safeContents\" must has \"Array\" type");
		
		if(parameters.safeContents.length !== this.parsedValue.safeContents.length)
			return Promise.reject("Length of \"parameters.safeContents\" must be equal to \"this.parsedValue.safeContents\"");
		//endregion 
		
		//region Initial variables 
		let sequence = Promise.resolve();
		//endregion
		
		//region Create internal values from already parsed values 
		this.safeContents = [];
		
		for(const [index, content] of this.parsedValue.safeContents.entries())
		{
			//region Check current "content" value
			if(("privacyMode" in content) === false)
				return Promise.reject("The \"privacyMode\" is a mandatory parameter for \"content\"");
			
			if(("value" in content) === false)
				return Promise.reject("The \"value\" is a mandatory parameter for \"content\"");
			
			if((content.value instanceof _SafeContents_js__WEBPACK_IMPORTED_MODULE_3__["default"]) === false)
				return Promise.reject("The \"content.value\" must has \"SafeContents\" type");
			//endregion 
			
			switch(content.privacyMode)
			{
				//region No privacy 
				case 0:
					{
						const contentBuffer = content.value.toSchema().toBER(false);
						
						sequence = sequence.then(
							() =>
							{
								this.safeContents.push(new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
									contentType: "1.2.840.113549.1.7.1",
									content: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: contentBuffer })
								}));
							});
					}
					break;
				//endregion 
				//region Privacy with password
				case 1:
					{
						//region Initial variables
						const cmsEncrypted = new _EncryptedData_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
						
						const currentParameters = parameters.safeContents[index];
						currentParameters.contentToEncrypt = content.value.toSchema().toBER(false);
						//endregion
						
						//region Encrypt CMS EncryptedData using password
						sequence = sequence.then(
							() => cmsEncrypted.encrypt(currentParameters),
							error => Promise.reject(error)
						);
						//endregion
						
						//region Store result content in CMS_CONTENT_INFO type
						sequence = sequence.then(
							() =>
							{
								this.safeContents.push(new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
									contentType: "1.2.840.113549.1.7.6",
									content: cmsEncrypted.toSchema()
								}));
							},
							error => Promise.reject(error)
						);
						//endregion
					}
					break;
				//endregion 
				//region Privacy with public key
				case 2:
					{
						//region Initial variables
						const cmsEnveloped = new _EnvelopedData_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
						const contentToEncrypt = content.value.toSchema().toBER(false);
						//endregion
						
						//region Check mandatory parameters
						if(("encryptingCertificate" in parameters.safeContents[index]) === false)
							return Promise.reject("Absent mandatory parameter \"encryptingCertificate\" in \"parameters.safeContents[i]\"");
						
						if(("encryptionAlgorithm" in parameters.safeContents[index]) === false)
							return Promise.reject("Absent mandatory parameter \"encryptionAlgorithm\" in \"parameters.safeContents[i]\"");
						
						switch(true)
						{
							case (parameters.safeContents[index].encryptionAlgorithm.name.toLowerCase() === "aes-cbc"):
							case (parameters.safeContents[index].encryptionAlgorithm.name.toLowerCase() === "aes-gcm"):
								break;
							default:
								return Promise.reject(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${parameters.safeContents[index].encryptionAlgorithm}`);
						}
						
						switch(true)
						{
							case (parameters.safeContents[index].encryptionAlgorithm.length === 128):
							case (parameters.safeContents[index].encryptionAlgorithm.length === 192):
							case (parameters.safeContents[index].encryptionAlgorithm.length === 256):
								break;
							default:
								return Promise.reject(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${parameters.safeContents[index].encryptionAlgorithm.length}`);
						}
						//endregion
						
						//region Making correct "encryptionAlgorithm" variable
						const encryptionAlgorithm = parameters.safeContents[index].encryptionAlgorithm;
						//endregion
						
						//region Append recipient for enveloped data
						cmsEnveloped.addRecipientByCertificate(parameters.safeContents[index].encryptingCertificate);
						//endregion
						
						//region Making encryption
						sequence = sequence.then(
							() => cmsEnveloped.encrypt(encryptionAlgorithm, contentToEncrypt)
						);
						
						sequence = sequence.then(
							() =>
							{
								this.safeContents.push(new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
									contentType: "1.2.840.113549.1.7.3",
									content: cmsEnveloped.toSchema()
								}));
							}
						);
						//endregion
					}
					break;
				//endregion 
				//region default 
				default:
					return Promise.reject(`Incorrect value for "content.privacyMode": ${content.privacyMode}`);
				//endregion 
			}
		}
		//endregion 
		
		//region Return result of the function 
		return sequence.then(
			() => this,
			error => Promise.reject(`Error during parsing: ${error}`)
		);
		//endregion   
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/AuthorityKeyIdentifier.js":
/*!**********************************************************!*\
  !*** ./node_modules/pkijs/src/AuthorityKeyIdentifier.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AuthorityKeyIdentifier; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class AuthorityKeyIdentifier
{
	//**********************************************************************************
	/**
	 * Constructor for AuthorityKeyIdentifier class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("keyIdentifier" in parameters)
			/**
			 * @type {OctetString}
			 * @desc keyIdentifier
			 */
			this.keyIdentifier = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyIdentifier", AuthorityKeyIdentifier.defaultValues("keyIdentifier"));

		if("authorityCertIssuer" in parameters)
			/**
			 * @type {Array.<GeneralName>}
			 * @desc authorityCertIssuer
			 */
			this.authorityCertIssuer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "authorityCertIssuer", AuthorityKeyIdentifier.defaultValues("authorityCertIssuer"));

		if("authorityCertSerialNumber" in parameters)
			/**
			 * @type {Integer}
			 * @desc authorityCertIssuer
			 */
			this.authorityCertSerialNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "authorityCertSerialNumber", AuthorityKeyIdentifier.defaultValues("authorityCertSerialNumber"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "keyIdentifier":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "authorityCertIssuer":
				return [];
			case "authorityCertSerialNumber":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			default:
				throw new Error(`Invalid member name for AuthorityKeyIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AuthorityKeyIdentifier OID ::= 2.5.29.35
	 *
	 * AuthorityKeyIdentifier ::= SEQUENCE {
	 *    keyIdentifier             [0] KeyIdentifier           OPTIONAL,
	 *    authorityCertIssuer       [1] GeneralNames            OPTIONAL,
	 *    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
	 *
	 * KeyIdentifier ::= OCTET STRING
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [keyIdentifier]
		 * @property {string} [authorityCertIssuer]
		 * @property {string} [authorityCertSerialNumber]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.keyIdentifier || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.authorityCertIssuer || ""),
							value: _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.authorityCertSerialNumber || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					}
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"keyIdentifier",
			"authorityCertIssuer",
			"authorityCertSerialNumber"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			AuthorityKeyIdentifier.schema({
				names: {
					keyIdentifier: "keyIdentifier",
					authorityCertIssuer: "authorityCertIssuer",
					authorityCertSerialNumber: "authorityCertSerialNumber"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");
		//endregion

		//region Get internal properties from parsed schema
		if("keyIdentifier" in asn1.result)
			this.keyIdentifier = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: asn1.result.keyIdentifier.valueBlock.valueHex });

		if("authorityCertIssuer" in asn1.result)
			this.authorityCertIssuer = Array.from(asn1.result.authorityCertIssuer, element => new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));

		if("authorityCertSerialNumber" in asn1.result)
			this.authorityCertSerialNumber = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: asn1.result.authorityCertSerialNumber.valueBlock.valueHex });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if("keyIdentifier" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				valueHex: this.keyIdentifier.valueBlock.valueHex
			}));
		}
		
		if("authorityCertIssuer" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.authorityCertIssuer, element => element.toSchema())
			}));
		}
		
		if("authorityCertSerialNumber" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 2 // [2]
				},
				valueHex: this.authorityCertSerialNumber.valueBlock.valueHex
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};

		if("keyIdentifier" in this)
			object.keyIdentifier = this.keyIdentifier.toJSON();

		if("authorityCertIssuer" in this)
			object.authorityCertIssuer = Array.from(this.authorityCertIssuer, element => element.toJSON());

		if("authorityCertSerialNumber" in this)
			object.authorityCertSerialNumber = this.authorityCertSerialNumber.toJSON();

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/BasicConstraints.js":
/*!****************************************************!*\
  !*** ./node_modules/pkijs/src/BasicConstraints.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BasicConstraints; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5280
 */
class BasicConstraints
{
	//**********************************************************************************
	/**
	 * Constructor for BasicConstraints class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 * @property {Object} [cA]
	 * @property {Object} [pathLenConstraint]
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {boolean}
		 * @desc cA
		 */
		this.cA = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "cA", false);

		if("pathLenConstraint" in parameters)
			/**
			 * @type {number|Integer}
			 * @desc pathLenConstraint
			 */
			this.pathLenConstraint = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "pathLenConstraint", 0);
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "cA":
				return false;
			default:
				throw new Error(`Invalid member name for BasicConstraints class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * BasicConstraints ::= SEQUENCE {
	 *    cA                      BOOLEAN DEFAULT FALSE,
	 *    pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [cA]
		 * @property {string} [pathLenConstraint]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Boolean"]({
					optional: true,
					name: (names.cA || "")
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
					optional: true,
					name: (names.pathLenConstraint || "")
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"cA",
			"pathLenConstraint"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			BasicConstraints.schema({
				names: {
					cA: "cA",
					pathLenConstraint: "pathLenConstraint"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for BasicConstraints");
		//endregion

		//region Get internal properties from parsed schema
		if("cA" in asn1.result)
			this.cA = asn1.result.cA.valueBlock.value;

		if("pathLenConstraint" in asn1.result)
		{
			if(asn1.result.pathLenConstraint.valueBlock.isHexOnly)
				this.pathLenConstraint = asn1.result.pathLenConstraint;
			else
				this.pathLenConstraint = asn1.result.pathLenConstraint.valueBlock.valueDec;
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if(this.cA !== BasicConstraints.defaultValues("cA"))
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Boolean"]({ value: this.cA }));
		
		if("pathLenConstraint" in this)
		{
			if(this.pathLenConstraint instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"])
				outputArray.push(this.pathLenConstraint);
			else
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.pathLenConstraint }));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};

		if(this.cA !== BasicConstraints.defaultValues("cA"))
			object.cA = this.cA;

		if("pathLenConstraint" in this)
		{
			if(this.pathLenConstraint instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"])
				object.pathLenConstraint = this.pathLenConstraint.toJSON();
			else
				object.pathLenConstraint = this.pathLenConstraint;
		}

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/BasicOCSPResponse.js":
/*!*****************************************************!*\
  !*** ./node_modules/pkijs/src/BasicOCSPResponse.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BasicOCSPResponse; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _ResponseData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ResponseData.js */ "./node_modules/pkijs/src/ResponseData.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Certificate.js */ "./node_modules/pkijs/src/Certificate.js");
/* harmony import */ var _CertID_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CertID.js */ "./node_modules/pkijs/src/CertID.js");
/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");
/* harmony import */ var _CertificateChainValidationEngine_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CertificateChainValidationEngine.js */ "./node_modules/pkijs/src/CertificateChainValidationEngine.js");









//**************************************************************************************
/**
 * Class from RFC6960
 */
class BasicOCSPResponse
{
	//**********************************************************************************
	/**
	 * Constructor for BasicOCSPResponse class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {ResponseData}
		 * @desc tbsResponseData
		 */
		this.tbsResponseData = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "tbsResponseData", BasicOCSPResponse.defaultValues("tbsResponseData"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc signatureAlgorithm
		 */
		this.signatureAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureAlgorithm", BasicOCSPResponse.defaultValues("signatureAlgorithm"));
		/**
		 * @type {BitString}
		 * @desc signature
		 */
		this.signature = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signature", BasicOCSPResponse.defaultValues("signature"));
		
		if("certs" in parameters)
			/**
			 * @type {Array.<Certificate>}
			 * @desc certs
			 */
			this.certs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certs", BasicOCSPResponse.defaultValues("certs"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "tbsResponseData":
				return new _ResponseData_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "signatureAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			case "signature":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			case "certs":
				return [];
			default:
				throw new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "type":
				{
					// noinspection OverlyComplexBooleanExpressionJS
					let comparisonResult = ((_ResponseData_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("tbs", memberValue.tbs)) &&
					(_ResponseData_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("responderID", memberValue.responderID)) &&
					(_ResponseData_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("producedAt", memberValue.producedAt)) &&
					(_ResponseData_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("responses", memberValue.responses)));
					
					if("responseExtensions" in memberValue)
						comparisonResult = comparisonResult && (_ResponseData_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("responseExtensions", memberValue.responseExtensions));
					
					return comparisonResult;
				}
			case "signatureAlgorithm":
				return ((memberValue.algorithmId === "") && (("algorithmParams" in memberValue) === false));
			case "signature":
				return (memberValue.isEqual(BasicOCSPResponse.defaultValues(memberName)));
			case "certs":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for BasicOCSPResponse class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * BasicOCSPResponse       ::= SEQUENCE {
	 *    tbsResponseData      ResponseData,
	 *    signatureAlgorithm   AlgorithmIdentifier,
	 *    signature            BIT STRING,
	 *    certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [tbsResponseData]
		 * @property {string} [signatureAlgorithm]
		 * @property {string} [signature]
		 * @property {string} [certs]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "BasicOCSPResponse"),
			value: [
				_ResponseData_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.tbsResponseData || {
					names: {
						blockName: "BasicOCSPResponse.tbsResponseData"
					}
				}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.signatureAlgorithm || {
					names: {
						blockName: "BasicOCSPResponse.signatureAlgorithm"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.signature || "BasicOCSPResponse.signature") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
							value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
								name: "BasicOCSPResponse.certs",
								value: _Certificate_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.certs || {})
							})]
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"BasicOCSPResponse.tbsResponseData",
			"BasicOCSPResponse.signatureAlgorithm",
			"BasicOCSPResponse.signature",
			"BasicOCSPResponse.certs"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			BasicOCSPResponse.schema()
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for BasicOCSPResponse");
		//endregion
		
		//region Get internal properties from parsed schema
		this.tbsResponseData = new _ResponseData_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result["BasicOCSPResponse.tbsResponseData"] });
		this.signatureAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result["BasicOCSPResponse.signatureAlgorithm"] });
		this.signature = asn1.result["BasicOCSPResponse.signature"];
		
		if("BasicOCSPResponse.certs" in asn1.result)
			this.certs = Array.from(asn1.result["BasicOCSPResponse.certs"], element => new _Certificate_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		outputArray.push(this.tbsResponseData.toSchema());
		outputArray.push(this.signatureAlgorithm.toSchema());
		outputArray.push(this.signature);
		
		//region Create array of certificates
		if("certs" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
						value: Array.from(this.certs, element => element.toSchema())
					})
				]
			}));
		}
		//endregion
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			tbsResponseData: this.tbsResponseData.toJSON(),
			signatureAlgorithm: this.signatureAlgorithm.toJSON(),
			signature: this.signature.toJSON()
		};
		
		if("certs" in this)
			_object.certs = Array.from(this.certs, element => element.toJSON());
		
		return _object;
	}
	//**********************************************************************************
	/**
	 * Get OCSP response status for specific certificate
	 * @param {Certificate} certificate Certificate to be checked
	 * @param {Certificate} issuerCertificate Certificate of issuer for certificate to be checked
	 * @returns {Promise}
	 */
	getCertificateStatus(certificate, issuerCertificate)
	{
		//region Initial variables
		let sequence = Promise.resolve();
		
		const result = {
			isForCertificate: false,
			status: 2 // 0 = good, 1 = revoked, 2 = unknown
		};
		
		const hashesObject = {};
		
		const certIDs = [];
		const certIDPromises = [];
		//endregion
		
		//region Create all "certIDs" for input certificates
		for(const response of this.tbsResponseData.responses)
		{
			const hashAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(response.certID.hashAlgorithm.algorithmId);
			if(("name" in hashAlgorithm) === false)
				return Promise.reject(`Wrong CertID hashing algorithm: ${response.certID.hashAlgorithm.algorithmId}`);
			
			if((hashAlgorithm.name in hashesObject) === false)
			{
				hashesObject[hashAlgorithm.name] = 1;
				
				const certID = new _CertID_js__WEBPACK_IMPORTED_MODULE_6__["default"]();
				
				certIDs.push(certID);
				certIDPromises.push(certID.createForCertificate(certificate, {
					hashAlgorithm: hashAlgorithm.name,
					issuerCertificate
				}));
			}
		}
		
		sequence = sequence.then(() =>
			Promise.all(certIDPromises)
		);
		//endregion
		
		//region Compare all response's "certIDs" with identifiers for input certificate
		sequence = sequence.then(() =>
		{
			for(const response of this.tbsResponseData.responses)
			{
				for(const id of certIDs)
				{
					if(response.certID.isEqual(id))
					{
						result.isForCertificate = true;

						try
						{
							switch(response.certStatus.idBlock.isConstructed)
							{
								case true:
									if(response.certStatus.idBlock.tagNumber === 1)
										result.status = 1; // revoked
									
									break;
								case false:
									switch(response.certStatus.idBlock.tagNumber)
									{
										case 0: // good
											result.status = 0;
											break;
										case 2: // unknown
											result.status = 2;
											break;
										default:
									}
									
									break;
								default:
							}
						}
						catch(ex)
						{
						}
						
						return result;
					}
				}
			}
			
			return result;
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Make signature for current OCSP Basic Response
	 * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
	 * @param {string} [hashAlgorithm="SHA-1"] Hashing algorithm. Default SHA-1
	 * @returns {Promise}
	 */
	sign(privateKey, hashAlgorithm = "SHA-1")
	{
		//region Initial checking
		//region Get a private key from function parameter
		if(typeof privateKey === "undefined")
			return Promise.reject("Need to provide a private key for signing");
		//endregion
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		let parameters;
		
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		//endregion
		
		//region Get a "default parameters" for current algorithm and set correct signature algorithm
		sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
		
		sequence = sequence.then(result =>
		{
			parameters = result.parameters;
			this.signatureAlgorithm = result.signatureAlgorithm;
		});
		//endregion
		
		//region Create TBS data for signing
		sequence = sequence.then(() =>
		{
			this.tbsResponseData.tbs = this.tbsResponseData.toSchema(true).toBER(false);
		});
		//endregion
		
		//region Signing TBS data on provided private key
		sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbsResponseData.tbs, privateKey, parameters));
		
		sequence = sequence.then(result =>
		{
			this.signature = new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ valueHex: result });
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Verify existing OCSP Basic Response
	 * @param {Object} parameters Additional parameters
	 * @returns {Promise}
	 */
	verify(parameters = {})
	{
		//region Initial variables
		let signerCert = null;
		
		let certIndex = -1;
		
		let sequence = Promise.resolve();
		
		let trustedCerts = [];
		
		const _this = this;
		
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		//endregion
		
		//region Check amount of certificates
		if(("certs" in this) === false)
			return Promise.reject("No certificates attached to the BasicOCSPResponce");
		//endregion
		
		//region Get input values
		if("trustedCerts" in parameters)
			trustedCerts = parameters.trustedCerts;
		//endregion
		
		//region Aux functions
		/**
		 * Check CA flag for the certificate
		 * @param {Certificate} cert Certificate to find CA flag for
		 * @returns {*}
		 */
		function checkCA(cert)
		{
			//region Do not include signer's certificate
			if((cert.issuer.isEqual(signerCert.issuer) === true) && (cert.serialNumber.isEqual(signerCert.serialNumber) === true))
				return null;
			//endregion
			
			let isCA = false;
			
			for(const extension of cert.extensions)
			{
				if(extension.extnID === "2.5.29.19") // BasicConstraints
				{
					if("cA" in extension.parsedValue)
					{
						if(extension.parsedValue.cA === true)
							isCA = true;
					}
				}
			}
			
			if(isCA)
				return cert;
			
			return null;
		}
		//endregion

		//region Get a "crypto" extension
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion
		
		//region Find correct value for "responderID"
		switch(true)
		{
			case (this.tbsResponseData.responderID instanceof _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_7__["default"]): // [1] Name
				sequence = sequence.then(() =>
				{
					for(const [index, certificate] of _this.certs.entries())
					{
						if(certificate.subject.isEqual(_this.tbsResponseData.responderID))
						{
							certIndex = index;
							break;
						}
					}
				});
				break;
			case (this.tbsResponseData.responderID instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]): // [2] KeyHash
				sequence = sequence.then(() => Promise.all(Array.from(_this.certs, element =>
					crypto.digest({ name: "sha-1" }, new Uint8Array(element.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(results =>
				{
					for(const [index, ] of _this.certs.entries())
					{
						if(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(results[index], _this.tbsResponseData.responderID.valueBlock.valueHex))
						{
							certIndex = index;
							break;
						}
					}
				}));
				break;
			default:
				return Promise.reject("Wrong value for responderID");
		}
		//endregion
		
		//region Make additional verification for signer's certificate
		sequence = sequence.then(() =>
		{
			if(certIndex === (-1))
				return Promise.reject("Correct certificate was not found in OCSP response");
			
			signerCert = this.certs[certIndex];
			
			return Promise.all(Array.from(_this.certs, element => checkCA(element))).then(promiseResults =>
			{
				const additionalCerts = [];
				additionalCerts.push(signerCert);
				
				for(const promiseResult of promiseResults)
				{
					if(promiseResult !== null)
						additionalCerts.push(promiseResult);
				}
				
				const certChain = new _CertificateChainValidationEngine_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
					certs: additionalCerts,
					trustedCerts
				});
				
				return certChain.verify().then(verificationResult =>
				{
					if(verificationResult.result === true)
						return Promise.resolve();
					
					return Promise.reject("Validation of signer's certificate failed");
				}, error =>
					Promise.reject(`Validation of signer's certificate failed with error: ${((error instanceof Object) ? error.resultMessage : error)}`)
				);
			}, promiseError =>
				Promise.reject(`Error during checking certificates for CA flag: ${promiseError}`)
			);
		});
		//endregion
		
		sequence = sequence.then(() => engine.subtle.verifyWithPublicKey(this.tbsResponseData.tbs, this.signature, this.certs[certIndex].subjectPublicKeyInfo, this.signatureAlgorithm));
		
		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CAVersion.js":
/*!*********************************************!*\
  !*** ./node_modules/pkijs/src/CAVersion.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CAVersion; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from https://docs.microsoft.com/en-us/windows/desktop/seccrypto/certification-authority-renewal
 */
class CAVersion
{
	//**********************************************************************************
	/**
	 * Constructor for CAVersion class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc certificateIndex
		 */
		this.certificateIndex = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certificateIndex", CAVersion.defaultValues("certificateIndex"));

		/**
		 * @type {number}
		 * @desc keyIndex
		 */
		this.keyIndex = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyIndex", CAVersion.defaultValues("keyIndex"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "certificateIndex":
			case "keyIndex":
				return 0;
			default:
				throw new Error(`Invalid member name for CAVersion class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * CAVersion ::= INTEGER
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]());
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Check the schema is valid
		if(schema.constructor.blockName() !== asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"].blockName())
			throw new Error("Object's schema was not verified against input data for CAVersion");
		//endregion

		//region Check length of the input value and correct it if needed
		let value = schema.valueBlock.valueHex.slice(0);
		const valueView = new Uint8Array(value);

		switch(true)
		{
			case (value.byteLength < 4):
				{
					const tempValue = new ArrayBuffer(4);
					const tempValueView = new Uint8Array(tempValue);

					tempValueView.set(valueView, 4 - value.byteLength);

					value = tempValue.slice(0);
				}
				break;
			case (value.byteLength > 4):
				{
					const tempValue = new ArrayBuffer(4);
					const tempValueView = new Uint8Array(tempValue);

					tempValueView.set(valueView.slice(0, 4));

					value = tempValue.slice(0);
				}
				break;
			default:
		}
		//endregion

		//region Get internal properties from parsed schema
		const keyIndexBuffer = value.slice(0, 2);
		const keyIndexView8 = new Uint8Array(keyIndexBuffer);
		let temp = keyIndexView8[0];
		keyIndexView8[0] = keyIndexView8[1];
		keyIndexView8[1] = temp;

		const keyIndexView16 = new Uint16Array(keyIndexBuffer);

		this.keyIndex = keyIndexView16[0];

		const certificateIndexBuffer = value.slice(2);
		const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
		temp = certificateIndexView8[0];
		certificateIndexView8[0] = certificateIndexView8[1];
		certificateIndexView8[1] = temp;

		const certificateIndexView16 = new Uint16Array(certificateIndexBuffer);

		this.certificateIndex = certificateIndexView16[0];
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create raw values
		const certificateIndexBuffer = new ArrayBuffer(2);
		const certificateIndexView = new Uint16Array(certificateIndexBuffer);

		certificateIndexView[0] = this.certificateIndex;

		const certificateIndexView8 = new Uint8Array(certificateIndexBuffer);
		let temp = certificateIndexView8[0];
		certificateIndexView8[0] = certificateIndexView8[1];
		certificateIndexView8[1] = temp;

		const keyIndexBuffer = new ArrayBuffer(2);
		const keyIndexView = new Uint16Array(keyIndexBuffer);

		keyIndexView[0] = this.keyIndex;

		const keyIndexView8 = new Uint8Array(keyIndexBuffer);
		temp = keyIndexView8[0];
		keyIndexView8[0] = keyIndexView8[1];
		keyIndexView8[1] = temp;
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
			valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(keyIndexBuffer, certificateIndexBuffer)
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			certificateIndex: this.certificateIndex,
			keyIndex: this.keyIndex
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CRLBag.js":
/*!******************************************!*\
  !*** ./node_modules/pkijs/src/CRLBag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CRLBag; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _CertificateRevocationList_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CertificateRevocationList.js */ "./node_modules/pkijs/src/CertificateRevocationList.js");



//**************************************************************************************
/**
 * Class from RFC7292
 */
class CRLBag
{
	//**********************************************************************************
	/**
	 * Constructor for CRLBag class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc crlId
		 */
		this.crlId = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "crlId", CRLBag.defaultValues("crlId"));
		/**
		 * @type {*}
		 * @desc crlValue
		 */
		this.crlValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "crlValue", CRLBag.defaultValues("crlValue"));
		
		if("parsedValue" in parameters)
			/**
			 * @type {*}
			 * @desc parsedValue
			 */
			this.parsedValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "parsedValue", CRLBag.defaultValues("parsedValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "crlId":
				return "";
			case "crlValue":
				return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]());
			case "parsedValue":
				return {};
			default:
				throw new Error(`Invalid member name for CRLBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "crlId":
				return (memberValue === "");
			case "crlValue":
				return (memberValue instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]);
			case "parsedValue":
				return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
			default:
				throw new Error(`Invalid member name for CRLBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * CRLBag ::= SEQUENCE {
	 *    crlId     	BAG-TYPE.&id ({CRLTypes}),
	 *    crlValue 	[0] EXPLICIT BAG-TYPE.&Type ({CRLTypes}{@crlId})
	 *}
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [id]
		 * @property {string} [value]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.id || "id") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.value || "value") })] // EXPLICIT ANY value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"crlId",
			"crlValue"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			CRLBag.schema({
				names: {
					id: "crlId",
					value: "crlValue"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for CRLBag");
		//endregion
		
		//region Get internal properties from parsed schema
		this.crlId = asn1.result.crlId.valueBlock.toString();
		this.crlValue = asn1.result.crlValue;
		
		switch(this.crlId)
		{
			case "1.2.840.113549.1.9.23.1": // x509CRL
				{
					const asn1Inner = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.certValue.valueBlock.valueHex);
					this.parsedValue = new _CertificateRevocationList_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1Inner.result });
				}
				break;
			default:
				throw new Error(`Incorrect "crlId" value in CRLBag: ${this.crlId}`);
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		if("parsedValue" in this)
		{
			this.certId = "1.2.840.113549.1.9.23.1";
			this.certValue = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: this.parsedValue.toSchema().toBER(false) });
		}
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.crlId }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [this.crlValue.toSchema()]
				})
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			crlId: this.crlId,
			crlValue: this.crlValue.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CRLDistributionPoints.js":
/*!*********************************************************!*\
  !*** ./node_modules/pkijs/src/CRLDistributionPoints.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CRLDistributionPoints; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _DistributionPoint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DistributionPoint.js */ "./node_modules/pkijs/src/DistributionPoint.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class CRLDistributionPoints
{
	//**********************************************************************************
	/**
	 * Constructor for CRLDistributionPoints class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<DistributionPoint>}
		 * @desc distributionPoints
		 */
		this.distributionPoints = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "distributionPoints", CRLDistributionPoints.defaultValues("distributionPoints"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "distributionPoints":
				return [];
			default:
				throw new Error(`Invalid member name for CRLDistributionPoints class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [distributionPoints]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.distributionPoints || ""),
					value: _DistributionPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"distributionPoints"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			CRLDistributionPoints.schema({
				names: {
					distributionPoints: "distributionPoints"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");
		//endregion

		//region Get internal properties from parsed schema
		this.distributionPoints = Array.from(asn1.result.distributionPoints, element => new _DistributionPoint_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.distributionPoints, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			distributionPoints: Array.from(this.distributionPoints, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CertBag.js":
/*!*******************************************!*\
  !*** ./node_modules/pkijs/src/CertBag.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CertBag; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Certificate.js */ "./node_modules/pkijs/src/Certificate.js");
/* harmony import */ var _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AttributeCertificateV2.js */ "./node_modules/pkijs/src/AttributeCertificateV2.js");




//**************************************************************************************
/**
 * Class from RFC7292
 */
class CertBag
{
	//**********************************************************************************
	/**
	 * Constructor for CertBag class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc certId
		 */
		this.certId = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certId", CertBag.defaultValues("certId"));
		/**
		 * @type {*}
		 * @desc certValue
		 */
		this.certValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certValue", CertBag.defaultValues("certValue"));
		
		if("parsedValue" in parameters)
			/**
			 * @type {*}
			 * @desc parsedValue
			 */
			this.parsedValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "parsedValue", CertBag.defaultValues("parsedValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "certId":
				return "";
			case "certValue":
				return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]());
			case "parsedValue":
				return {};
			default:
				throw new Error(`Invalid member name for CertBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "certId":
				return (memberValue === "");
			case "certValue":
				return (memberValue instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]);
			case "parsedValue":
				return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
			default:
				throw new Error(`Invalid member name for CertBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * CertBag ::= SEQUENCE {
	 *    certId    BAG-TYPE.&id   ({CertTypes}),
	 *    certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [id]
		 * @property {string} [value]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.id || "id") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.value || "value") })] // EXPLICIT ANY value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"certId",
			"certValue"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			CertBag.schema({
				names: {
					id: "certId",
					value: "certValue"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for CertBag");
		//endregion 
		
		//region Get internal properties from parsed schema 
		this.certId = asn1.result.certId.valueBlock.toString();
		this.certValue = asn1.result.certValue;
		
		switch(this.certId)
		{
			case "1.2.840.113549.1.9.22.1": // x509Certificate
				{
					const asn1Inner = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.certValue.valueBlock.valueHex);
					
					try
					{
						this.parsedValue = new _Certificate_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1Inner.result });
					}
					catch(ex) // In some realizations the same OID used for attribute certificates
					{
						this.parsedValue = new _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1Inner.result });
					}
				}
				break;
			case "1.2.840.113549.1.9.22.3": // attributeCertificate - (!!!) THIS OID IS SUBJECT FOR CHANGE IN FUTURE (!!!)
				{
					const asn1Inner = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.certValue.valueBlock.valueHex);
					this.parsedValue = new _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1Inner.result });
				}
				break;
			case "1.2.840.113549.1.9.22.2": // sdsiCertificate
			default:
				throw new Error(`Incorrect "certId" value in CertBag: ${this.certId}`);
		}
		//endregion 
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		if("parsedValue" in this)
		{
			if("acinfo" in this.parsedValue) // attributeCertificate
				this.certId = "1.2.840.113549.1.9.22.3";
			else // x509Certificate
				this.certId = "1.2.840.113549.1.9.22.1";

			this.certValue = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: this.parsedValue.toSchema().toBER(false) });
		}
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.certId }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [(("toSchema" in this.certValue) ? this.certValue.toSchema() : this.certValue)]
				})
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			certId: this.certId,
			certValue: this.certValue.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CertID.js":
/*!******************************************!*\
  !*** ./node_modules/pkijs/src/CertID.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CertID; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");




//**************************************************************************************
/**
 * Class from RFC6960
 */
class CertID 
{
	//**********************************************************************************
	/**
	 * Constructor for CertID class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc hashAlgorithm
		 */
		this.hashAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "hashAlgorithm", CertID.defaultValues("hashAlgorithm"));
		/**
		 * @type {OctetString}
		 * @desc issuerNameHash
		 */
		this.issuerNameHash = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuerNameHash", CertID.defaultValues("issuerNameHash"));
		/**
		 * @type {OctetString}
		 * @desc issuerKeyHash
		 */
		this.issuerKeyHash = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuerKeyHash", CertID.defaultValues("issuerKeyHash"));
		/**
		 * @type {Integer}
		 * @desc serialNumber
		 */
		this.serialNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "serialNumber", CertID.defaultValues("serialNumber"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "hashAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "issuerNameHash":
			case "issuerKeyHash":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "serialNumber":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			default:
				throw new Error(`Invalid member name for CertID class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "hashAlgorithm":
				return ((memberValue.algorithmId === "") && (("algorithmParams" in memberValue) === false));
			case "issuerNameHash":
			case "issuerKeyHash":
			case "serialNumber":
				return (memberValue.isEqual(CertID.defaultValues(memberName)));
			default:
				throw new Error(`Invalid member name for CertID class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * CertID          ::=     SEQUENCE {
	 *    hashAlgorithm       AlgorithmIdentifier,
	 *    issuerNameHash      OCTET STRING, -- Hash of issuer's DN
	 *    issuerKeyHash       OCTET STRING, -- Hash of issuer's public key
	 *    serialNumber        CertificateSerialNumber }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [hashAlgorithm]
		 * @property {string} [hashAlgorithmObject]
		 * @property {string} [issuerNameHash]
		 * @property {string} [issuerKeyHash]
		 * @property {string} [serialNumber]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.hashAlgorithmObject || {
					names: {
						blockName: (names.hashAlgorithm || "")
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.issuerNameHash || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.issuerKeyHash || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.serialNumber || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"hashAlgorithm",
			"issuerNameHash",
			"issuerKeyHash",
			"serialNumber"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			CertID.schema({
				names: {
					hashAlgorithm: "hashAlgorithm",
					issuerNameHash: "issuerNameHash",
					issuerKeyHash: "issuerKeyHash",
					serialNumber: "serialNumber"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for CertID");
		//endregion
		
		//region Get internal properties from parsed schema
		this.hashAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.hashAlgorithm });
		this.issuerNameHash = asn1.result.issuerNameHash;
		this.issuerKeyHash = asn1.result.issuerKeyHash;
		this.serialNumber = asn1.result.serialNumber;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.hashAlgorithm.toSchema(),
				this.issuerNameHash,
				this.issuerKeyHash,
				this.serialNumber
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			hashAlgorithm: this.hashAlgorithm.toJSON(),
			issuerNameHash: this.issuerNameHash.toJSON(),
			issuerKeyHash: this.issuerKeyHash.toJSON(),
			serialNumber: this.serialNumber.toJSON()
		};
	}
	//**********************************************************************************
	/**
	 * Check that two "CertIDs" are equal
	 * @param {CertID} certificateID Identifier of the certificate to be checked
	 * @returns {boolean}
	 */
	isEqual(certificateID)
	{
		//region Check "hashAlgorithm"
		if(!this.hashAlgorithm.algorithmId === certificateID.hashAlgorithm.algorithmId)
			return false;
		//endregion
		
		//region Check "issuerNameHash"
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(this.issuerNameHash.valueBlock.valueHex, certificateID.issuerNameHash.valueBlock.valueHex) === false)
			return false;
		//endregion
		
		//region Check "issuerKeyHash"
		if(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(this.issuerKeyHash.valueBlock.valueHex, certificateID.issuerKeyHash.valueBlock.valueHex) === false)
			return false;
		//endregion
		
		//region Check "serialNumber"
		if(!this.serialNumber.isEqual(certificateID.serialNumber))
			return false;
		//endregion
		
		return true;
	}
	//**********************************************************************************
	/**
	 * Making OCSP certificate identifier for specific certificate
	 * @param {Certificate} certificate Certificate making OCSP Request for
	 * @param {Object} parameters Additional parameters
	 * @returns {Promise}
	 */
	createForCertificate(certificate, parameters)
	{
		//region Initial variables
		let sequence = Promise.resolve();
		
		let issuerCertificate;
		//endregion
		
		//region Get a "crypto" extension
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion
		
		//region Check input parameters
		if(("hashAlgorithm" in parameters) === false)
			return Promise.reject("Parameter \"hashAlgorithm\" is mandatory for \"OCSP_REQUEST.createForCertificate\"");
		
		const hashOID = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({ name: parameters.hashAlgorithm });
		if(hashOID === "")
			return Promise.reject(`Incorrect "hashAlgorithm": ${this.hashAlgorithm}`);
		
		this.hashAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
			algorithmId: hashOID,
			algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
		});
		
		if("issuerCertificate" in parameters)
			issuerCertificate = parameters.issuerCertificate;
		else
			return Promise.reject("Parameter \"issuerCertificate\" is mandatory for \"OCSP_REQUEST.createForCertificate\"");
		//endregion
		
		//region Initialize "serialNumber" field
		this.serialNumber = certificate.serialNumber;
		//endregion
		
		//region Create "issuerNameHash"
		sequence = sequence.then(() =>
			crypto.digest({ name: parameters.hashAlgorithm }, issuerCertificate.subject.toSchema().toBER(false)),
		error =>
			Promise.reject(error)
		);
		//endregion
		
		//region Create "issuerKeyHash"
		sequence = sequence.then(result =>
		{
			this.issuerNameHash = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: result });
			
			const issuerKeyBuffer = issuerCertificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex;
			
			return crypto.digest({ name: parameters.hashAlgorithm }, issuerKeyBuffer);
		}, error =>
			Promise.reject(error)
		).then(result =>
		{
			this.issuerKeyHash = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: result });
		}, error =>
			Promise.reject(error)
		);
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/Certificate.js":
/*!***********************************************!*\
  !*** ./node_modules/pkijs/src/Certificate.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Certificate; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");
/* harmony import */ var _Time_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Time.js */ "./node_modules/pkijs/src/Time.js");
/* harmony import */ var _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PublicKeyInfo.js */ "./node_modules/pkijs/src/PublicKeyInfo.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/pkijs/src/Extension.js");
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Extensions.js */ "./node_modules/pkijs/src/Extensions.js");









//**************************************************************************************
function tbsCertificate(parameters = {})
{
	//TBSCertificate  ::=  SEQUENCE  {
	//    version         [0]  EXPLICIT Version DEFAULT v1,
	//    serialNumber         CertificateSerialNumber,
	//    signature            AlgorithmIdentifier,
	//    issuer               Name,
	//    validity             Validity,
	//    subject              Name,
	//    subjectPublicKeyInfo SubjectPublicKeyInfo,
	//    issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
	//                         -- If present, version MUST be v2 or v3
	//    subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
	//                         -- If present, version MUST be v2 or v3
	//    extensions      [3]  EXPLICIT Extensions OPTIONAL
	//    -- If present, version MUST be v3
	//}
	
	/**
	 * @type {Object}
	 * @property {string} [blockName]
	 * @property {string} [tbsCertificateVersion]
	 * @property {string} [tbsCertificateSerialNumber]
	 * @property {string} [signature]
	 * @property {string} [issuer]
	 * @property {string} [tbsCertificateValidity]
	 * @property {string} [notBefore]
	 * @property {string} [notAfter]
	 * @property {string} [subject]
	 * @property {string} [subjectPublicKeyInfo]
	 * @property {string} [tbsCertificateIssuerUniqueID]
	 * @property {string} [tbsCertificateSubjectUniqueID]
	 * @property {string} [extensions]
	 */
	const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
	
	return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
		name: (names.blockName || "tbsCertificate"),
		value: [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.tbsCertificateVersion || "tbsCertificate.version") }) // EXPLICIT integer value
				]
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.tbsCertificateSerialNumber || "tbsCertificate.serialNumber") }),
			_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.signature || {
				names: {
					blockName: "tbsCertificate.signature"
				}
			}),
			_RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.issuer || {
				names: {
					blockName: "tbsCertificate.issuer"
				}
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				name: (names.tbsCertificateValidity || "tbsCertificate.validity"),
				value: [
					_Time_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.notBefore || {
						names: {
							utcTimeName: "tbsCertificate.notBefore",
							generalTimeName: "tbsCertificate.notBefore"
						}
					}),
					_Time_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.notAfter || {
						names: {
							utcTimeName: "tbsCertificate.notAfter",
							generalTimeName: "tbsCertificate.notAfter"
						}
					})
				]
			}),
			_RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.subject || {
				names: {
					blockName: "tbsCertificate.subject"
				}
			}),
			_PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_6__["default"].schema(names.subjectPublicKeyInfo || {
				names: {
					blockName: "tbsCertificate.subjectPublicKeyInfo"
				}
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				name: (names.tbsCertificateIssuerUniqueID || "tbsCertificate.issuerUniqueID"),
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				}
			}), // IMPLICIT bistring value
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				name: (names.tbsCertificateSubjectUniqueID || "tbsCertificate.subjectUniqueID"),
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 2 // [2]
				}
			}), // IMPLICIT bistring value
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 3 // [3]
				},
				value: [_Extensions_js__WEBPACK_IMPORTED_MODULE_8__["default"].schema(names.extensions || {
					names: {
						blockName: "tbsCertificate.extensions"
					}
				})]
			}) // EXPLICIT SEQUENCE value
		]
	}));
}
//**************************************************************************************
/**
 * Class from RFC5280
 */
class Certificate
{
	//**********************************************************************************
	/**
	 * Constructor for Certificate class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {ArrayBuffer}
		 * @desc ToBeSigned (TBS) part of the certificate
		 */
		this.tbs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "tbs", Certificate.defaultValues("tbs"));
		/**
		 * @type {number}
		 * @desc Version number
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", Certificate.defaultValues("version"));
		/**
		 * @type {Integer}
		 * @desc Serial number of the certificate
		 */
		this.serialNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "serialNumber", Certificate.defaultValues("serialNumber"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc This field contains the algorithm identifier for the algorithm used by the CA to sign the certificate
		 */
		this.signature = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signature", Certificate.defaultValues("signature"));
		/**
		 * @type {RelativeDistinguishedNames}
		 * @desc The issuer field identifies the entity that has signed and issued the certificate
		 */
		this.issuer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuer", Certificate.defaultValues("issuer"));
		/**
		 * @type {Time}
		 * @desc The date on which the certificate validity period begins
		 */
		this.notBefore = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "notBefore", Certificate.defaultValues("notBefore"));
		/**
		 * @type {Time}
		 * @desc The date on which the certificate validity period ends
		 */
		this.notAfter = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "notAfter", Certificate.defaultValues("notAfter"));
		/**
		 * @type {RelativeDistinguishedNames}
		 * @desc The subject field identifies the entity associated with the public key stored in the subject public key field
		 */
		this.subject = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subject", Certificate.defaultValues("subject"));
		/**
		 * @type {PublicKeyInfo}
		 * @desc This field is used to carry the public key and identify the algorithm with which the key is used
		 */
		this.subjectPublicKeyInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subjectPublicKeyInfo", Certificate.defaultValues("subjectPublicKeyInfo"));
		
		if("issuerUniqueID" in parameters)
			/**
			 * @type {ArrayBuffer}
			 * @desc The subject and issuer unique identifiers are present in the certificate to handle the possibility of reuse of subject and/or issuer names over time
			 */
			this.issuerUniqueID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuerUniqueID", Certificate.defaultValues("issuerUniqueID"));
		
		if("subjectUniqueID" in parameters)
			/**
			 * @type {ArrayBuffer}
			 * @desc The subject and issuer unique identifiers are present in the certificate to handle the possibility of reuse of subject and/or issuer names over time
			 */
			this.subjectUniqueID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subjectUniqueID", Certificate.defaultValues("subjectUniqueID"));
		
		if("extensions" in parameters)
			/**
			 * @type {Array}
			 * @desc If present, this field is a SEQUENCE of one or more certificate extensions
			 */
			this.extensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "extensions", Certificate.defaultValues("extensions"));
		
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc The signatureAlgorithm field contains the identifier for the cryptographic algorithm used by the CA to sign this certificate
		 */
		this.signatureAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureAlgorithm", Certificate.defaultValues("signatureAlgorithm"));
		/**
		 * @type {BitString}
		 * @desc The signatureValue field contains a digital signature computed upon the ASN.1 DER encoded tbsCertificate
		 */
		this.signatureValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureValue", Certificate.defaultValues("signatureValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "tbs":
				return new ArrayBuffer(0);
			case "version":
				return 0;
			case "serialNumber":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "signature":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "issuer":
				return new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			case "notBefore":
				return new _Time_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			case "notAfter":
				return new _Time_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			case "subject":
				return new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			case "subjectPublicKeyInfo":
				return new _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_6__["default"]();
			case "issuerUniqueID":
				return new ArrayBuffer(0);
			case "subjectUniqueID":
				return new ArrayBuffer(0);
			case "extensions":
				return [];
			case "signatureAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "signatureValue":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for Certificate class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * Certificate  ::=  SEQUENCE  {
	 *    tbsCertificate       TBSCertificate,
	 *    signatureAlgorithm   AlgorithmIdentifier,
	 *    signatureValue       BIT STRING  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [tbsCertificate]
		 * @property {string} [signatureAlgorithm]
		 * @property {string} [signatureValue]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				tbsCertificate(names.tbsCertificate),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.signatureAlgorithm || {
					names: {
						blockName: "signatureAlgorithm"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.signatureValue || "signatureValue") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"tbsCertificate",
			"tbsCertificate.extensions",
			"tbsCertificate.version",
			"tbsCertificate.serialNumber",
			"tbsCertificate.signature",
			"tbsCertificate.issuer",
			"tbsCertificate.notBefore",
			"tbsCertificate.notAfter",
			"tbsCertificate.subject",
			"tbsCertificate.subjectPublicKeyInfo",
			"tbsCertificate.issuerUniqueID",
			"tbsCertificate.subjectUniqueID",
			"signatureAlgorithm",
			"signatureValue"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			Certificate.schema({
				names: {
					tbsCertificate: {
						names: {
							extensions: {
								names: {
									extensions: "tbsCertificate.extensions"
								}
							}
						}
					}
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for Certificate");
		//endregion
		
		//region Get internal properties from parsed schema
		this.tbs = asn1.result.tbsCertificate.valueBeforeDecode;
		
		if("tbsCertificate.version" in asn1.result)
			this.version = asn1.result["tbsCertificate.version"].valueBlock.valueDec;
		this.serialNumber = asn1.result["tbsCertificate.serialNumber"];
		this.signature = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result["tbsCertificate.signature"] });
		this.issuer = new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result["tbsCertificate.issuer"] });
		this.notBefore = new _Time_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result["tbsCertificate.notBefore"] });
		this.notAfter = new _Time_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result["tbsCertificate.notAfter"] });
		this.subject = new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result["tbsCertificate.subject"] });
		this.subjectPublicKeyInfo = new _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_6__["default"]({ schema: asn1.result["tbsCertificate.subjectPublicKeyInfo"] });
		if("tbsCertificate.issuerUniqueID" in asn1.result)
			this.issuerUniqueID = asn1.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex;
		if("tbsCertificate.subjectUniqueID" in asn1.result)
			this.subjectUniqueID = asn1.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex;
		if("tbsCertificate.extensions" in asn1.result)
			this.extensions = Array.from(asn1.result["tbsCertificate.extensions"], element => new _Extension_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: element }));
		
		this.signatureAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.signatureAlgorithm });
		this.signatureValue = asn1.result.signatureValue;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Create ASN.1 schema for existing values of TBS part for the certificate
	 */
	encodeTBS()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if(("version" in this) && (this.version !== Certificate.defaultValues("version")))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }) // EXPLICIT integer value
				]
			}));
		}
		
		outputArray.push(this.serialNumber);
		outputArray.push(this.signature.toSchema());
		outputArray.push(this.issuer.toSchema());
		
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.notBefore.toSchema(),
				this.notAfter.toSchema()
			]
		}));
		
		outputArray.push(this.subject.toSchema());
		outputArray.push(this.subjectPublicKeyInfo.toSchema());
		
		if("issuerUniqueID" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				valueHex: this.issuerUniqueID
			}));
		}
		if("subjectUniqueID" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 2 // [2]
				},
				valueHex: this.subjectUniqueID
			}));
		}
		
		if("extensions" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 3 // [3]
				},
				value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: Array.from(this.extensions, element => element.toSchema())
				})]
			}));
		}
		//endregion
		
		//region Create and return output sequence
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema(encodeFlag = false)
	{
		let tbsSchema = {};
		
		//region Decode stored TBS value
		if(encodeFlag === false)
		{
			if(this.tbs.length === 0) // No stored certificate TBS part
				return Certificate.schema().value[0];
			
			tbsSchema = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.tbs).result;
		}
		//endregion
		//region Create TBS schema via assembling from TBS parts
		else
			tbsSchema = this.encodeTBS();
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				tbsSchema,
				this.signatureAlgorithm.toSchema(),
				this.signatureValue
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			tbs: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["bufferToHexCodes"])(this.tbs, 0, this.tbs.byteLength),
			serialNumber: this.serialNumber.toJSON(),
			signature: this.signature.toJSON(),
			issuer: this.issuer.toJSON(),
			notBefore: this.notBefore.toJSON(),
			notAfter: this.notAfter.toJSON(),
			subject: this.subject.toJSON(),
			subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
			signatureAlgorithm: this.signatureAlgorithm.toJSON(),
			signatureValue: this.signatureValue.toJSON()
		};
		
		if(("version" in this) && (this.version !== Certificate.defaultValues("version")))
			object.version = this.version;
		
		if("issuerUniqueID" in this)
			object.issuerUniqueID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["bufferToHexCodes"])(this.issuerUniqueID, 0, this.issuerUniqueID.byteLength);
		
		if("subjectUniqueID" in this)
			object.subjectUniqueID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["bufferToHexCodes"])(this.subjectUniqueID, 0, this.subjectUniqueID.byteLength);
		
		if("extensions" in this)
			object.extensions = Array.from(this.extensions, element => element.toJSON());
		
		return object;
	}
	//**********************************************************************************
	/**
	 * Importing public key for current certificate
	 */
	getPublicKey(parameters = null)
	{
		return Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])().subtle.getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
	}
	//**********************************************************************************
	/**
	 * Get hash value for subject public key (default SHA-1)
	 * @param {String} [hashAlgorithm=SHA-1] Hashing algorithm name
	 */
	getKeyHash(hashAlgorithm = "SHA-1")
	{
		//region Get a "crypto" extension
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion
		
		return crypto.digest({ name: hashAlgorithm }, new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex));
	}
	//**********************************************************************************
	/**
	 * Make a signature for current value from TBS section
	 * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
	 * @param {string} [hashAlgorithm="SHA-1"] Hashing algorithm
	 */
	sign(privateKey, hashAlgorithm = "SHA-1")
	{
		//region Initial checking
		//region Check private key
		if(typeof privateKey === "undefined")
			return Promise.reject("Need to provide a private key for signing");
		//endregion
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		let parameters;
		
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		//endregion
		
		//region Get a "default parameters" for current algorithm and set correct signature algorithm
		sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
		
		sequence = sequence.then(result =>
		{
			parameters = result.parameters;
			this.signature = result.signatureAlgorithm;
			this.signatureAlgorithm = result.signatureAlgorithm;
		});
		//endregion
		
		//region Create TBS data for signing
		sequence = sequence.then(() =>
		{
			this.tbs = this.encodeTBS().toBER(false);
		});
		//endregion
		
		//region Signing TBS data on provided private key
		sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));
		
		sequence = sequence.then(result =>
		{
			this.signatureValue = new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ valueHex: result });
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	verify(issuerCertificate = null)
	{
		//region Global variables
		let subjectPublicKeyInfo = {};
		//endregion
		
		//region Set correct "subjectPublicKeyInfo" value
		if(issuerCertificate !== null)
			subjectPublicKeyInfo = issuerCertificate.subjectPublicKeyInfo;
		else
		{
			if(this.issuer.isEqual(this.subject)) // Self-signed certificate
				subjectPublicKeyInfo = this.subjectPublicKeyInfo;
		}
		
		if((subjectPublicKeyInfo instanceof _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_6__["default"]) === false)
			return Promise.reject("Please provide issuer certificate as a parameter");
		//endregion
		
		return Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])().subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm);
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CertificateChainValidationEngine.js":
/*!********************************************************************!*\
  !*** ./node_modules/pkijs/src/CertificateChainValidationEngine.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CertificateChainValidationEngine; });
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");


//**************************************************************************************
class CertificateChainValidationEngine
{
	//**********************************************************************************
	/**
	 * Constructor for CertificateChainValidationEngine class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<Certificate>}
		 * @desc Array of pre-defined trusted (by user) certificates
		 */
		this.trustedCerts = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "trustedCerts", this.defaultValues("trustedCerts"));
		/**
		 * @type {Array.<Certificate>}
		 * @desc Array with certificate chain. Could be only one end-user certificate in there!
		 */
		this.certs = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "certs", this.defaultValues("certs"));
		/**
		 * @type {Array.<CertificateRevocationList>}
		 * @desc Array of all CRLs for all certificates from certificate chain
		 */
		this.crls = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "crls", this.defaultValues("crls"));
		/**
		 * @type {Array}
		 * @desc Array of all OCSP responses
		 */
		this.ocsps = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "ocsps", this.defaultValues("ocsps"));
		/**
		 * @type {Date}
		 * @desc The date at which the check would be
		 */
		this.checkDate = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "checkDate", this.defaultValues("checkDate"));
		/**
		 * @type {Function}
		 * @desc The date at which the check would be
		 */
		this.findOrigin = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "findOrigin", this.defaultValues("findOrigin"));
		/**
		 * @type {Function}
		 * @desc The date at which the check would be
		 */
		this.findIssuer = Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["getParametersValue"])(parameters, "findIssuer", this.defaultValues("findIssuer"));
		//endregion
	}
	//**********************************************************************************
	static defaultFindOrigin(certificate, validationEngine)
	{
		//region Firstly encode TBS for certificate
		if(certificate.tbs.byteLength === 0)
			certificate.tbs = certificate.encodeTBS();
		//endregion
		
		//region Search in Intermediate Certificates
		for(const localCert of validationEngine.certs)
		{
			//region Firstly encode TBS for certificate
			if(localCert.tbs.byteLength === 0)
				localCert.tbs = localCert.encodeTBS();
			//endregion
			
			if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["isEqualBuffer"])(certificate.tbs, localCert.tbs))
				return "Intermediate Certificates";
		}
		//endregion
		
		//region Search in Trusted Certificates
		for(const trustedCert of validationEngine.trustedCerts)
		{
			//region Firstly encode TBS for certificate
			if(trustedCert.tbs.byteLength === 0)
				trustedCert.tbs = trustedCert.encodeTBS();
			//endregion
			
			if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["isEqualBuffer"])(certificate.tbs, trustedCert.tbs))
				return "Trusted Certificates";
		}
		//endregion
		
		return "Unknown";
	}
	//**********************************************************************************
	async defaultFindIssuer(certificate, validationEngine)
	{
		//region Initial variables
		let result = [];
		
		let keyIdentifier = null;
		
		let authorityCertIssuer = null;
		let authorityCertSerialNumber = null;
		//endregion
		
		//region Speed-up searching in case of self-signed certificates
		if(certificate.subject.isEqual(certificate.issuer))
		{
			try
			{
				const verificationResult = await certificate.verify();
				if(verificationResult === true)
					return [certificate];
			}
			catch(ex)
			{
			}
		}
		//endregion
		
		//region Find values to speed-up search
		if("extensions" in certificate)
		{
			for(const extension of certificate.extensions)
			{
				if(extension.extnID === "2.5.29.35") // AuthorityKeyIdentifier
				{
					if("keyIdentifier" in extension.parsedValue)
						keyIdentifier = extension.parsedValue.keyIdentifier;
					else
					{
						if("authorityCertIssuer" in extension.parsedValue)
							authorityCertIssuer = extension.parsedValue.authorityCertIssuer;
						
						if("authorityCertSerialNumber" in extension.parsedValue)
							authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
					}
					
					break;
				}
			}
		}
		//endregion
		
		//region Aux function
		function checkCertificate(possibleIssuer)
		{
			//region Firstly search for appropriate extensions
			if(keyIdentifier !== null)
			{
				if("extensions" in possibleIssuer)
				{
					let extensionFound = false;
					
					for(const extension of possibleIssuer.extensions)
					{
						if(extension.extnID === "2.5.29.14") // SubjectKeyIdentifier
						{
							extensionFound = true;
							
							if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["isEqualBuffer"])(extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHex))
								result.push(possibleIssuer);
							
							break;
						}
					}
					
					if(extensionFound)
						return;
				}
			}
			//endregion
			
			//region Now search for authorityCertSerialNumber
			let authorityCertSerialNumberEqual = false;
			
			if(authorityCertSerialNumber !== null)
				authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber);
			//endregion
			
			//region And at least search for Issuer data
			if(authorityCertIssuer !== null)
			{
				if(possibleIssuer.subject.isEqual(authorityCertIssuer))
				{
					if(authorityCertSerialNumberEqual)
						result.push(possibleIssuer);
				}
			}
			else
			{
				if(certificate.issuer.isEqual(possibleIssuer.subject))
					result.push(possibleIssuer);
			}
			//endregion
		}
		//endregion
		
		//region Search in Trusted Certificates
		for(const trustedCert of validationEngine.trustedCerts)
			checkCertificate(trustedCert);
		//endregion
		
		//region Search in Intermediate Certificates
		for(const intermediateCert of validationEngine.certs)
			checkCertificate(intermediateCert);
		//endregion
		
		//region Now perform certificate verification checking
		for(let i = 0; i < result.length; i++)
		{
			try
			{
				const verificationResult = await certificate.verify(result[i]);
				if(verificationResult === false)
					result.splice(i, 1);
			}
			catch(ex)
			{
				result.splice(i, 1); // Something wrong, remove the certificate
			}
		}
		//endregion
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	defaultValues(memberName)
	{
		switch(memberName)
		{
			case "trustedCerts":
				return [];
			case "certs":
				return [];
			case "crls":
				return [];
			case "ocsps":
				return [];
			case "checkDate":
				return new Date();
			case "findOrigin":
				return CertificateChainValidationEngine.defaultFindOrigin;
			case "findIssuer":
				return this.defaultFindIssuer;
			default:
				throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${memberName}`);
		}
	}
	//**********************************************************************************
	async sort(passedWhenNotRevValues = false)
	{
		//region Initial variables
		const localCerts = [];
		const _this = this;
		//endregion
		
		//region Building certificate path
		async function buildPath(certificate)
		{
			const result = [];
			
			//region Aux function checking array for unique elements
			function checkUnique(array)
			{
				let unique = true;
				
				for(let i = 0; i < array.length; i++)
				{
					for(let j = 0; j < array.length; j++)
					{
						if(j === i)
							continue;
						
						if(array[i] === array[j])
						{
							unique = false;
							break;
						}
					}
					
					if(!unique)
						break;
				}
				
				return unique;
			}
			
			//endregion
			
			const findIssuerResult = await _this.findIssuer(certificate, _this);
			if(findIssuerResult.length === 0)
				throw new Error("No valid certificate paths found");
			
			for(let i = 0; i < findIssuerResult.length; i++)
			{
				if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["isEqualBuffer"])(findIssuerResult[i].tbs, certificate.tbs))
				{
					result.push([findIssuerResult[i]]);
					continue;
				}
				
				const buildPathResult = await buildPath(findIssuerResult[i]);
				
				for(let j = 0; j < buildPathResult.length; j++)
				{
					const copy = buildPathResult[j].slice();
					copy.splice(0, 0, findIssuerResult[i]);
					
					if(checkUnique(copy))
						result.push(copy);
					else
						result.push(buildPathResult[j]);
				}
			}
			
			return result;
		}
		//endregion
		
		//region Find CRL for specific certificate
		async function findCRL(certificate)
		{
			//region Initial variables
			const issuerCertificates = [];
			const crls = [];
			const crlsAndCertificates = [];
			//endregion
			
			//region Find all possible CRL issuers
			issuerCertificates.push(...localCerts.filter(element => certificate.issuer.isEqual(element.subject)));
			if(issuerCertificates.length === 0)
			{
				return {
					status: 1,
					statusMessage: "No certificate's issuers"
				};
			}
			//endregion
			
			//region Find all CRLs for certificate's issuer
			crls.push(..._this.crls.filter(element => element.issuer.isEqual(certificate.issuer)));
			if(crls.length === 0)
			{
				return {
					status: 2,
					statusMessage: "No CRLs for specific certificate issuer"
				};
			}
			//endregion
			
			//region Find specific certificate of issuer for each CRL
			for(let i = 0; i < crls.length; i++)
			{
				//region Check "nextUpdate" for the CRL
				// The "nextUpdate" is older than "checkDate".
				// Thus we should do have another, updated CRL.
				// Thus the CRL assumed to be invalid.
				if(crls[i].nextUpdate.value < _this.checkDate)
					continue;
				//endregion
				
				for(let j = 0; j < issuerCertificates.length; j++)
				{
					try
					{
						const result = await crls[i].verify({ issuerCertificate: issuerCertificates[j] });
						if(result)
						{
							crlsAndCertificates.push({
								crl: crls[i],
								certificate: issuerCertificates[j]
							});
							
							break;
						}
					}
					catch(ex)
					{
					}
				}
			}
			//endregion
			
			if(crlsAndCertificates.length)
			{
				return {
					status: 0,
					statusMessage: "",
					result: crlsAndCertificates
				};
			}
			
			return {
				status: 3,
				statusMessage: "No valid CRLs found"
			};
		}
		//endregion
		
		//region Find OCSP for specific certificate
		async function findOCSP(certificate, issuerCertificate)
		{
			//region Get hash algorithm from certificate
			const hashAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_1__["getAlgorithmByOID"])(certificate.signatureAlgorithm.algorithmId);
			if(("name" in hashAlgorithm) === false)
				return 1;
			if(("hash" in hashAlgorithm) === false)
				return 1;
			//endregion
			
			//region Search for OCSP response for the certificate
			for(let i = 0; i < _this.ocsps.length; i++)
			{
				const result = await _this.ocsps[i].getCertificateStatus(certificate, issuerCertificate);
				if(result.isForCertificate)
				{
					if(result.status === 0)
						return 0;
					
					return 1;
				}
			}
			//endregion
			
			return 2;
		}
		//endregion
		
		//region Check for certificate to be CA
		async function checkForCA(certificate, needToCheckCRL = false)
		{
			//region Initial variables
			let isCA = false;
			let mustBeCA = false;
			let keyUsagePresent = false;
			let cRLSign = false;
			//endregion
			
			if("extensions" in certificate)
			{
				for(let j = 0; j < certificate.extensions.length; j++)
				{
					if((certificate.extensions[j].critical === true) &&
						(("parsedValue" in certificate.extensions[j]) === false))
					{
						return {
							result: false,
							resultCode: 6,
							resultMessage: `Unable to parse critical certificate extension: ${certificate.extensions[j].extnID}`
						};
					}
					
					if(certificate.extensions[j].extnID === "2.5.29.15") // KeyUsage
					{
						keyUsagePresent = true;
						
						const view = new Uint8Array(certificate.extensions[j].parsedValue.valueBlock.valueHex);
						
						if((view[0] & 0x04) === 0x04) // Set flag "keyCertSign"
							mustBeCA = true;
						
						if((view[0] & 0x02) === 0x02) // Set flag "cRLSign"
							cRLSign = true;
					}
					
					if(certificate.extensions[j].extnID === "2.5.29.19") // BasicConstraints
					{
						if("cA" in certificate.extensions[j].parsedValue)
						{
							if(certificate.extensions[j].parsedValue.cA === true)
								isCA = true;
						}
					}
				}
				
				if((mustBeCA === true) && (isCA === false))
				{
					return {
						result: false,
						resultCode: 3,
						resultMessage: "Unable to build certificate chain - using \"keyCertSign\" flag set without BasicConstaints"
					};
				}
				
				if((keyUsagePresent === true) && (isCA === true) && (mustBeCA === false))
				{
					return {
						result: false,
						resultCode: 4,
						resultMessage: "Unable to build certificate chain - \"keyCertSign\" flag was not set"
					};
				}
				
				// noinspection OverlyComplexBooleanExpressionJS
				if((isCA === true) && (keyUsagePresent === true) && ((needToCheckCRL) && (cRLSign === false)))
				{
					return {
						result: false,
						resultCode: 5,
						resultMessage: "Unable to build certificate chain - intermediate certificate must have \"cRLSign\" key usage flag"
					};
				}
			}
			
			if(isCA === false)
			{
				return {
					result: false,
					resultCode: 7,
					resultMessage: "Unable to build certificate chain - more than one possible end-user certificate"
				};
			}
			
			return {
				result: true,
				resultCode: 0,
				resultMessage: ""
			};
		}
		//endregion
		
		//region Basic check for certificate path
		async function basicCheck(path, checkDate)
		{
			//region Check that all dates are valid
			for(let i = 0; i < path.length; i++)
			{
				if((path[i].notBefore.value > checkDate) ||
					(path[i].notAfter.value < checkDate))
				{
					return {
						result: false,
						resultCode: 8,
						resultMessage: "The certificate is either not yet valid or expired"
					};
				}
			}
			//endregion
			
			//region Check certificate name chain
			
			// We should have at least two certificates: end entity and trusted root
			if(path.length < 2)
			{
				return {
					result: false,
					resultCode: 9,
					resultMessage: "Too short certificate path"
				};
			}
			
			for(let i = (path.length - 2); i >= 0; i--)
			{
				//region Check that we do not have a "self-signed" certificate
				if(path[i].issuer.isEqual(path[i].subject) === false)
				{
					if(path[i].issuer.isEqual(path[i + 1].subject) === false)
					{
						return {
							result: false,
							resultCode: 10,
							resultMessage: "Incorrect name chaining"
						};
					}
				}
				//endregion
			}
			//endregion
			
			//region Check each certificate (except "trusted root") to be non-revoked
			if((_this.crls.length !== 0) || (_this.ocsps.length !== 0)) // If CRLs and OCSPs are empty then we consider all certificates to be valid
			{
				for(let i = 0; i < (path.length - 1); i++)
				{
					//region Initial variables
					let ocspResult = 2;
					let crlResult = {
						status: 0,
						statusMessage: ""
					};
					//endregion
					
					//region Check OCSPs first
					if(_this.ocsps.length !== 0)
					{
						ocspResult = await findOCSP(path[i], path[i + 1]);
						
						switch(ocspResult)
						{
							case 0:
								continue;
							case 1:
								return {
									result: false,
									resultCode: 12,
									resultMessage: "One of certificates was revoked via OCSP response"
								};
							case 2: // continue to check the certificate with CRL
								break;
							default:
						}
					}
					//endregion
					
					//region Check CRLs
					if(_this.crls.length !== 0)
					{
						crlResult = await findCRL(path[i]);

						if(crlResult.status === 0)
						{
							for(let j = 0; j < crlResult.result.length; j++)
							{
								//region Check that the CRL issuer certificate have not been revoked
								const isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path[i]);
								if(isCertificateRevoked)
								{
									return {
										result: false,
										resultCode: 12,
										resultMessage: "One of certificates had been revoked"
									};
								}
								//endregion

								//region Check that the CRL issuer certificate is a CA certificate
								const isCertificateCA = await checkForCA(crlResult.result[j].certificate, true);
								if(isCertificateCA.result === false)
								{
									return {
										result: false,
										resultCode: 13,
										resultMessage: "CRL issuer certificate is not a CA certificate or does not have crlSign flag"
									};
								}
								//endregion
							}
						}
						else
						{
							if(passedWhenNotRevValues === false)
							{
								throw {
									result: false,
									resultCode: 11,
									resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`
								};
							}
						}
					}
					else
					{
						if(ocspResult === 2)
						{
							return {
								result: false,
								resultCode: 11,
								resultMessage: "No revocation values found for one of certificates"
							};
						}
					}
					//endregion

					//region Check we do have links to revocation values inside issuer's certificate
					if((ocspResult === 2) && (crlResult.status === 2) && passedWhenNotRevValues)
					{
						const issuerCertificate = path[i + 1];
						let extensionFound = false;

						if("extensions" in issuerCertificate)
						{
							for(const extension of issuerCertificate.extensions)
							{
								switch(extension.extnID)
								{
									case "2.5.29.31": // CRLDistributionPoints
									case "2.5.29.46": // FreshestCRL
									case "1.3.6.1.5.5.7.1.1": // AuthorityInfoAccess
										extensionFound = true;
										break;
									default:
								}
							}
						}

						if(extensionFound)
						{
							throw {
								result: false,
								resultCode: 11,
								resultMessage: `No revocation values found for one of certificates: ${crlResult.statusMessage}`
							};
						}
					}
					//endregion
				}
			}
			//endregion
			
			//region Check each certificate (except "end entity") in the path to be a CA certificate
			for(let i = 1; i < path.length; i++)
			{
				const result = await checkForCA(path[i]);
				if(result.result === false)
				{
					return {
						result: false,
						resultCode: 14,
						resultMessage: "One of intermediate certificates is not a CA certificate"
					};
				}
			}
			//endregion
			
			return {
				result: true
			};
		}
		//endregion
		
		//region Do main work
		//region Initialize "localCerts" by value of "_this.certs" + "_this.trustedCerts" arrays
		localCerts.push(..._this.trustedCerts);
		localCerts.push(..._this.certs);
		//endregion
		
		//region Check all certificates for been unique
		for(let i = 0; i < localCerts.length; i++)
		{
			for(let j = 0; j < localCerts.length; j++)
			{
				if(i === j)
					continue;
				
				if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["isEqualBuffer"])(localCerts[i].tbs, localCerts[j].tbs))
				{
					localCerts.splice(j, 1);
					i = 0;
					break;
				}
			}
		}
		//endregion
		
		//region Initial variables
		let result;
		const certificatePath = [localCerts[localCerts.length - 1]]; // The "end entity" certificate must be the least in "certs" array
		//endregion
		
		//region Build path for "end entity" certificate
		result = await buildPath(localCerts[localCerts.length - 1]);
		if(result.length === 0)
		{
			return {
				result: false,
				resultCode: 60,
				resultMessage: "Unable to find certificate path"
			};
		}
		//endregion
		
		//region Exclude certificate paths not ended with "trusted roots"
		for(let i = 0; i < result.length; i++)
		{
			let found = false;
			
			for(let j = 0; j < (result[i]).length; j++)
			{
				const certificate = (result[i])[j];
				
				for(let k = 0; k < _this.trustedCerts.length; k++)
				{
					if(Object(pvutils__WEBPACK_IMPORTED_MODULE_0__["isEqualBuffer"])(certificate.tbs, _this.trustedCerts[k].tbs))
					{
						found = true;
						break;
					}
				}
				
				if(found)
					break;
			}
			
			if(!found)
			{
				result.splice(i, 1);
				i = 0;
			}
		}
		
		if(result.length === 0)
		{
			throw {
				result: false,
				resultCode: 97,
				resultMessage: "No valid certificate paths found"
			};
		}
		//endregion
		
		//region Find shortest certificate path (for the moment it is the only criteria)
		let shortestLength = result[0].length;
		let shortestIndex = 0;
		
		for(let i = 0; i < result.length; i++)
		{
			if(result[i].length < shortestLength)
			{
				shortestLength = result[i].length;
				shortestIndex = i;
			}
		}
		//endregion
		
		//region Create certificate path for basic check
		for(let i = 0; i < result[shortestIndex].length; i++)
			certificatePath.push((result[shortestIndex])[i]);
		//endregion
		
		//region Perform basic checking for all certificates in the path
		result = await basicCheck(certificatePath, _this.checkDate);
		if(result.result === false)
			throw result;
		//endregion
		
		return certificatePath;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Major verification function for certificate chain.
	 * @param {{initialPolicySet, initialExplicitPolicy, initialPolicyMappingInhibit, initialInhibitPolicy, initialPermittedSubtreesSet, initialExcludedSubtreesSet, initialRequiredNameForms}} [parameters]
	 * @returns {Promise}
	 */
	async verify(parameters = {})
	{
		//region Auxiliary functions for name constraints checking
		function compareDNSName(name, constraint)
		{
			/// <summary>Compare two dNSName values</summary>
			/// <param name="name" type="String">DNS from name</param>
			/// <param name="constraint" type="String">Constraint for DNS from name</param>
			/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
			
			//region Make a "string preparation" for both name and constrain
			const namePrepared = Object(_common_js__WEBPACK_IMPORTED_MODULE_1__["stringPrep"])(name);
			const constraintPrepared = Object(_common_js__WEBPACK_IMPORTED_MODULE_1__["stringPrep"])(constraint);
			//endregion
			
			//region Make a "splitted" versions of "constraint" and "name"
			const nameSplitted = namePrepared.split(".");
			const constraintSplitted = constraintPrepared.split(".");
			//endregion
			
			//region Length calculation and additional check
			const nameLen = nameSplitted.length;
			const constrLen = constraintSplitted.length;
			
			if((nameLen === 0) || (constrLen === 0) || (nameLen < constrLen))
				return false;
			//endregion
			
			//region Check that no part of "name" has zero length
			for(let i = 0; i < nameLen; i++)
			{
				if(nameSplitted[i].length === 0)
					return false;
			}
			//endregion
			
			//region Check that no part of "constraint" has zero length
			for(let i = 0; i < constrLen; i++)
			{
				if(constraintSplitted[i].length === 0)
				{
					if(i === 0)
					{
						if(constrLen === 1)
							return false;
						
						continue;
					}
					
					return false;
				}
			}
			//endregion
			
			//region Check that "name" has a tail as "constraint"
			
			for(let i = 0; i < constrLen; i++)
			{
				if(constraintSplitted[constrLen - 1 - i].length === 0)
					continue;
				
				if(nameSplitted[nameLen - 1 - i].localeCompare(constraintSplitted[constrLen - 1 - i]) !== 0)
					return false;
			}
			//endregion
			
			return true;
		}
		
		function compareRFC822Name(name, constraint)
		{
			/// <summary>Compare two rfc822Name values</summary>
			/// <param name="name" type="String">E-mail address from name</param>
			/// <param name="constraint" type="String">Constraint for e-mail address from name</param>
			/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
			
			//region Make a "string preparation" for both name and constrain
			const namePrepared = Object(_common_js__WEBPACK_IMPORTED_MODULE_1__["stringPrep"])(name);
			const constraintPrepared = Object(_common_js__WEBPACK_IMPORTED_MODULE_1__["stringPrep"])(constraint);
			//endregion
			
			//region Make a "splitted" versions of "constraint" and "name"
			const nameSplitted = namePrepared.split("@");
			const constraintSplitted = constraintPrepared.split("@");
			//endregion
			
			//region Splitted array length checking
			if((nameSplitted.length === 0) || (constraintSplitted.length === 0) || (nameSplitted.length < constraintSplitted.length))
				return false;
			//endregion
			
			if(constraintSplitted.length === 1)
			{
				const result = compareDNSName(nameSplitted[1], constraintSplitted[0]);
				
				if(result)
				{
					//region Make a "splitted" versions of domain name from "constraint" and "name"
					const ns = nameSplitted[1].split(".");
					const cs = constraintSplitted[0].split(".");
					//endregion
					
					if(cs[0].length === 0)
						return true;
					
					return ns.length === cs.length;
				}
				
				return false;
			}
			
			return (namePrepared.localeCompare(constraintPrepared) === 0);
		}
		
		function compareUniformResourceIdentifier(name, constraint)
		{
			/// <summary>Compare two uniformResourceIdentifier values</summary>
			/// <param name="name" type="String">uniformResourceIdentifier from name</param>
			/// <param name="constraint" type="String">Constraint for uniformResourceIdentifier from name</param>
			/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
			
			//region Make a "string preparation" for both name and constrain
			let namePrepared = Object(_common_js__WEBPACK_IMPORTED_MODULE_1__["stringPrep"])(name);
			const constraintPrepared = Object(_common_js__WEBPACK_IMPORTED_MODULE_1__["stringPrep"])(constraint);
			//endregion
			
			//region Find out a major URI part to compare with
			const ns = namePrepared.split("/");
			const cs = constraintPrepared.split("/");
			
			if(cs.length > 1) // Malformed constraint
				return false;
			
			if(ns.length > 1) // Full URI string
			{
				for(let i = 0; i < ns.length; i++)
				{
					if((ns[i].length > 0) && (ns[i].charAt(ns[i].length - 1) !== ":"))
					{
						const nsPort = ns[i].split(":");
						namePrepared = nsPort[0];
						break;
					}
				}
			}
			//endregion
			
			const result = compareDNSName(namePrepared, constraintPrepared);
			
			if(result)
			{
				//region Make a "splitted" versions of "constraint" and "name"
				const nameSplitted = namePrepared.split(".");
				const constraintSplitted = constraintPrepared.split(".");
				//endregion
				
				if(constraintSplitted[0].length === 0)
					return true;
				
				return nameSplitted.length === constraintSplitted.length;
			}
			
			return false;
		}
		
		function compareIPAddress(name, constraint)
		{
			/// <summary>Compare two iPAddress values</summary>
			/// <param name="name" type="in_window.org.pkijs.asn1.OCTETSTRING">iPAddress from name</param>
			/// <param name="constraint" type="in_window.org.pkijs.asn1.OCTETSTRING">Constraint for iPAddress from name</param>
			/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
			
			//region Common variables
			const nameView = new Uint8Array(name.valueBlock.valueHex);
			const constraintView = new Uint8Array(constraint.valueBlock.valueHex);
			//endregion
			
			//region Work with IPv4 addresses
			if((nameView.length === 4) && (constraintView.length === 8))
			{
				for(let i = 0; i < 4; i++)
				{
					if((nameView[i] ^ constraintView[i]) & constraintView[i + 4])
						return false;
				}
				
				return true;
			}
			//endregion
			
			//region Work with IPv6 addresses
			if((nameView.length === 16) && (constraintView.length === 32))
			{
				for(let i = 0; i < 16; i++)
				{
					if((nameView[i] ^ constraintView[i]) & constraintView[i + 16])
						return false;
				}
				
				return true;
			}
			//endregion
			
			return false;
		}
		
		function compareDirectoryName(name, constraint)
		{
			/// <summary>Compare two directoryName values</summary>
			/// <param name="name" type="in_window.org.pkijs.simpl.RDN">directoryName from name</param>
			/// <param name="constraint" type="in_window.org.pkijs.simpl.RDN">Constraint for directoryName from name</param>
			/// <param name="any" type="Boolean">Boolean flag - should be comparision interrupted after first match or we need to match all "constraints" parts</param>
			/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>
			
			//region Initial check
			if((name.typesAndValues.length === 0) || (constraint.typesAndValues.length === 0))
				return true;
			
			if(name.typesAndValues.length < constraint.typesAndValues.length)
				return false;
			//endregion
			
			//region Initial variables
			let result = true;
			let nameStart = 0;
			//endregion
			
			for(let i = 0; i < constraint.typesAndValues.length; i++)
			{
				let localResult = false;
				
				for(let j = nameStart; j < name.typesAndValues.length; j++)
				{
					localResult = name.typesAndValues[j].isEqual(constraint.typesAndValues[i]);
					
					if(name.typesAndValues[j].type === constraint.typesAndValues[i].type)
						result = result && localResult;
					
					if(localResult === true)
					{
						if((nameStart === 0) || (nameStart === j))
						{
							nameStart = j + 1;
							break;
						}
						else // Structure of "name" must be the same with "constraint"
							return false;
					}
				}
				
				if(localResult === false)
					return false;
			}
			
			return (nameStart === 0) ? false : result;
		}
		//endregion

		try
		{
			//region Initial checks
			if(this.certs.length === 0)
				throw "Empty certificate array";
			//endregion
			
			//region Get input variables
			let passedWhenNotRevValues = false;

			if("passedWhenNotRevValues" in parameters)
				passedWhenNotRevValues = parameters.passedWhenNotRevValues;

			let initialPolicySet = [];
			initialPolicySet.push("2.5.29.32.0"); // "anyPolicy"
			
			let initialExplicitPolicy = false;
			let initialPolicyMappingInhibit = false;
			let initialInhibitPolicy = false;
			
			let initialPermittedSubtreesSet = []; // Array of "simpl.x509.GeneralSubtree"
			let initialExcludedSubtreesSet = [];  // Array of "simpl.x509.GeneralSubtree"
			let initialRequiredNameForms = [];    // Array of "simpl.x509.GeneralSubtree"
			
			if("initialPolicySet" in parameters)
				initialPolicySet = parameters.initialPolicySet;
			
			if("initialExplicitPolicy" in parameters)
				initialExplicitPolicy = parameters.initialExplicitPolicy;
			
			if("initialPolicyMappingInhibit" in parameters)
				initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit;
			
			if("initialInhibitPolicy" in parameters)
				initialInhibitPolicy = parameters.initialInhibitPolicy;
			
			if("initialPermittedSubtreesSet" in parameters)
				initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet;
			
			if("initialExcludedSubtreesSet" in parameters)
				initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet;
			
			if("initialRequiredNameForms" in parameters)
				initialRequiredNameForms = parameters.initialRequiredNameForms;
			
			let explicitPolicyIndicator = initialExplicitPolicy;
			let policyMappingInhibitIndicator = initialPolicyMappingInhibit;
			let inhibitAnyPolicyIndicator = initialInhibitPolicy;
			
			const pendingConstraints = new Array(3);
			pendingConstraints[0] = false; // For "explicitPolicyPending"
			pendingConstraints[1] = false; // For "policyMappingInhibitPending"
			pendingConstraints[2] = false; // For "inhibitAnyPolicyPending"
			
			let explicitPolicyPending = 0;
			let policyMappingInhibitPending = 0;
			let inhibitAnyPolicyPending = 0;
			
			let permittedSubtrees = initialPermittedSubtreesSet;
			let excludedSubtrees = initialExcludedSubtreesSet;
			const requiredNameForms = initialRequiredNameForms;
			
			let pathDepth = 1;
			//endregion
			
			//region Sorting certificates in the chain array
			this.certs = await this.sort(passedWhenNotRevValues);
			//endregion
			
			//region Work with policies
			//region Support variables
			const allPolicies = []; // Array of all policies (string values)
			allPolicies.push("2.5.29.32.0"); // Put "anyPolicy" at first place
			
			const policiesAndCerts = []; // In fact "array of array" where rows are for each specific policy, column for each certificate and value is "true/false"
			
			const anyPolicyArray = new Array(this.certs.length - 1); // Minus "trusted anchor"
			for(let ii = 0; ii < (this.certs.length - 1); ii++)
				anyPolicyArray[ii] = true;
			
			policiesAndCerts.push(anyPolicyArray);
			
			const policyMappings = new Array(this.certs.length - 1); // Array of "PolicyMappings" for each certificate
			const certPolicies = new Array(this.certs.length - 1); // Array of "CertificatePolicies" for each certificate
			
			let explicitPolicyStart = (explicitPolicyIndicator) ? (this.certs.length - 1) : (-1);
			//endregion
			
			//region Gather all neccessary information from certificate chain
			for(let i = (this.certs.length - 2); i >= 0; i--, pathDepth++)
			{
				if("extensions" in this.certs[i])
				{
					//region Get information about certificate extensions
					for(let j = 0; j < this.certs[i].extensions.length; j++)
					{
						//region CertificatePolicies
						if(this.certs[i].extensions[j].extnID === "2.5.29.32")
						{
							certPolicies[i] = this.certs[i].extensions[j].parsedValue;
							
							//region Remove entry from "anyPolicies" for the certificate
							for(let s = 0; s < allPolicies.length; s++)
							{
								if(allPolicies[s] === "2.5.29.32.0")
								{
									delete (policiesAndCerts[s])[i];
									break;
								}
							}
							//endregion
							
							for(let k = 0; k < this.certs[i].extensions[j].parsedValue.certificatePolicies.length; k++)
							{
								let policyIndex = (-1);
								
								//region Try to find extension in "allPolicies" array
								for(let s = 0; s < allPolicies.length; s++)
								{
									if(this.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier === allPolicies[s])
									{
										policyIndex = s;
										break;
									}
								}
								//endregion
								
								if(policyIndex === (-1))
								{
									allPolicies.push(this.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier);
									
									const certArray = new Array(this.certs.length - 1);
									certArray[i] = true;
									
									policiesAndCerts.push(certArray);
								}
								else
									(policiesAndCerts[policyIndex])[i] = true;
							}
						}
						//endregion
						
						//region PolicyMappings
						if(this.certs[i].extensions[j].extnID === "2.5.29.33")
						{
							if(policyMappingInhibitIndicator)
							{
								return {
									result: false,
									resultCode: 98,
									resultMessage: "Policy mapping prohibited"
								};
							}
							
							policyMappings[i] = this.certs[i].extensions[j].parsedValue;
						}
						//endregion
						
						//region PolicyConstraints
						if(this.certs[i].extensions[j].extnID === "2.5.29.36")
						{
							if(explicitPolicyIndicator === false)
							{
								//region requireExplicitPolicy
								if(this.certs[i].extensions[j].parsedValue.requireExplicitPolicy === 0)
								{
									explicitPolicyIndicator = true;
									explicitPolicyStart = i;
								}
								else
								{
									if(pendingConstraints[0] === false)
									{
										pendingConstraints[0] = true;
										explicitPolicyPending = this.certs[i].extensions[j].parsedValue.requireExplicitPolicy;
									}
									else
										explicitPolicyPending = (explicitPolicyPending > this.certs[i].extensions[j].parsedValue.requireExplicitPolicy) ? this.certs[i].extensions[j].parsedValue.requireExplicitPolicy : explicitPolicyPending;
								}
								//endregion
								
								//region inhibitPolicyMapping
								if(this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping === 0)
									policyMappingInhibitIndicator = true;
								else
								{
									if(pendingConstraints[1] === false)
									{
										pendingConstraints[1] = true;
										policyMappingInhibitPending = this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1;
									}
									else
										policyMappingInhibitPending = (policyMappingInhibitPending > (this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1)) ? (this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1) : policyMappingInhibitPending;
								}
								//endregion
							}
						}
						//endregion
						
						//region InhibitAnyPolicy
						if(this.certs[i].extensions[j].extnID === "2.5.29.54")
						{
							if(inhibitAnyPolicyIndicator === false)
							{
								if(this.certs[i].extensions[j].parsedValue.valueBlock.valueDec === 0)
									inhibitAnyPolicyIndicator = true;
								else
								{
									if(pendingConstraints[2] === false)
									{
										pendingConstraints[2] = true;
										inhibitAnyPolicyPending = this.certs[i].extensions[j].parsedValue.valueBlock.valueDec;
									}
									else
										inhibitAnyPolicyPending = (inhibitAnyPolicyPending > this.certs[i].extensions[j].parsedValue.valueBlock.valueDec) ? this.certs[i].extensions[j].parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
								}
							}
						}
						//endregion
					}
					//endregion
					
					//region Check "inhibitAnyPolicyIndicator"
					if(inhibitAnyPolicyIndicator === true)
					{
						let policyIndex = (-1);
						
						//region Find "anyPolicy" index
						for(let searchAnyPolicy = 0; searchAnyPolicy < allPolicies.length; searchAnyPolicy++)
						{
							if(allPolicies[searchAnyPolicy] === "2.5.29.32.0")
							{
								policyIndex = searchAnyPolicy;
								break;
							}
						}
						//endregion
						
						if(policyIndex !== (-1))
							delete (policiesAndCerts[0])[i]; // Unset value to "undefined" for "anyPolicies" value for current certificate
					}
					//endregion
					
					//region Process with "pending constraints"
					if(explicitPolicyIndicator === false)
					{
						if(pendingConstraints[0] === true)
						{
							explicitPolicyPending--;
							if(explicitPolicyPending === 0)
							{
								explicitPolicyIndicator = true;
								explicitPolicyStart = i;
								
								pendingConstraints[0] = false;
							}
						}
					}
					
					if(policyMappingInhibitIndicator === false)
					{
						if(pendingConstraints[1] === true)
						{
							policyMappingInhibitPending--;
							if(policyMappingInhibitPending === 0)
							{
								policyMappingInhibitIndicator = true;
								pendingConstraints[1] = false;
							}
						}
					}
					
					if(inhibitAnyPolicyIndicator === false)
					{
						if(pendingConstraints[2] === true)
						{
							inhibitAnyPolicyPending--;
							if(inhibitAnyPolicyPending === 0)
							{
								inhibitAnyPolicyIndicator = true;
								pendingConstraints[2] = false;
							}
						}
					}
					//endregion
				}
			}
			//endregion
			
			//region Working with policy mappings
			for(let i = 0; i < (this.certs.length - 1); i++)
			{
				//region Check that there is "policy mapping" for level "i + 1"
				if((i < (this.certs.length - 2)) && (typeof policyMappings[i + 1] !== "undefined"))
				{
					for(let k = 0; k < policyMappings[i + 1].mappings.length; k++)
					{
						//region Check that we do not have "anyPolicy" in current mapping
						if((policyMappings[i + 1].mappings[k].issuerDomainPolicy === "2.5.29.32.0") || (policyMappings[i + 1].mappings[k].subjectDomainPolicy === "2.5.29.32.0"))
						{
							return {
								result: false,
								resultCode: 99,
								resultMessage: "The \"anyPolicy\" should not be a part of policy mapping scheme"
							};
						}
						//endregion
						
						//region Initial variables
						let issuerDomainPolicyIndex = (-1);
						let subjectDomainPolicyIndex = (-1);
						//endregion
						
						//region Search for index of policies indedes
						for(let n = 0; n < allPolicies.length; n++)
						{
							if(allPolicies[n] === policyMappings[i + 1].mappings[k].issuerDomainPolicy)
								issuerDomainPolicyIndex = n;
							
							if(allPolicies[n] === policyMappings[i + 1].mappings[k].subjectDomainPolicy)
								subjectDomainPolicyIndex = n;
						}
						//endregion
						
						//region Delete existing "issuerDomainPolicy" because on the level we mapped the policy to another one
						if(typeof (policiesAndCerts[issuerDomainPolicyIndex])[i] !== "undefined")
							delete (policiesAndCerts[issuerDomainPolicyIndex])[i];
						//endregion
						
						//region Check all policies for the certificate
						for(let j = 0; j < certPolicies[i].certificatePolicies.length; j++)
						{
							if(policyMappings[i + 1].mappings[k].subjectDomainPolicy === certPolicies[i].certificatePolicies[j].policyIdentifier)
							{
								//region Set mapped policy for current certificate
								if((issuerDomainPolicyIndex !== (-1)) && (subjectDomainPolicyIndex !== (-1)))
								{
									for(let m = 0; m <= i; m++)
									{
										if(typeof (policiesAndCerts[subjectDomainPolicyIndex])[m] !== "undefined")
										{
											(policiesAndCerts[issuerDomainPolicyIndex])[m] = true;
											delete (policiesAndCerts[subjectDomainPolicyIndex])[m];
										}
									}
								}
								//endregion
							}
						}
						//endregion
					}
				}
				//endregion
			}
			//endregion
			
			//region Working with "explicitPolicyIndicator" and "anyPolicy"
			for(let i = 0; i < allPolicies.length; i++)
			{
				if(allPolicies[i] === "2.5.29.32.0")
				{
					for(let j = 0; j < explicitPolicyStart; j++)
						delete (policiesAndCerts[i])[j];
				}
			}
			//endregion
			
			//region Create "set of authorities-constrained policies"
			const authConstrPolicies = [];
			
			for(let i = 0; i < policiesAndCerts.length; i++)
			{
				let found = true;
				
				for(let j = 0; j < (this.certs.length - 1); j++)
				{
					let anyPolicyFound = false;
					
					if((j < explicitPolicyStart) && (allPolicies[i] === "2.5.29.32.0") && (allPolicies.length > 1))
					{
						found = false;
						break;
					}
					
					if(typeof (policiesAndCerts[i])[j] === "undefined")
					{
						if(j >= explicitPolicyStart)
						{
							//region Search for "anyPolicy" in the policy set
							for(let k = 0; k < allPolicies.length; k++)
							{
								if(allPolicies[k] === "2.5.29.32.0")
								{
									if((policiesAndCerts[k])[j] === true)
										anyPolicyFound = true;
									
									break;
								}
							}
							//endregion
						}
						
						if(!anyPolicyFound)
						{
							found = false;
							break;
						}
					}
				}
				
				if(found === true)
					authConstrPolicies.push(allPolicies[i]);
			}
			//endregion
			
			//region Create "set of user-constrained policies"
			let userConstrPolicies = [];
			
			if((initialPolicySet.length === 1) && (initialPolicySet[0] === "2.5.29.32.0") && (explicitPolicyIndicator === false))
				userConstrPolicies = initialPolicySet;
			else
			{
				if((authConstrPolicies.length === 1) && (authConstrPolicies[0] === "2.5.29.32.0"))
					userConstrPolicies = initialPolicySet;
				else
				{
					for(let i = 0; i < authConstrPolicies.length; i++)
					{
						for(let j = 0; j < initialPolicySet.length; j++)
						{
							if((initialPolicySet[j] === authConstrPolicies[i]) || (initialPolicySet[j] === "2.5.29.32.0"))
							{
								userConstrPolicies.push(authConstrPolicies[i]);
								break;
							}
						}
					}
				}
			}
			//endregion
			
			//region Combine output object
			const policyResult = {
				result: (userConstrPolicies.length > 0),
				resultCode: 0,
				resultMessage: (userConstrPolicies.length > 0) ? "" : "Zero \"userConstrPolicies\" array, no intersections with \"authConstrPolicies\"",
				authConstrPolicies,
				userConstrPolicies,
				explicitPolicyIndicator,
				policyMappings,
				certificatePath: this.certs
			};
			
			if(userConstrPolicies.length === 0)
				return policyResult;
			//endregion
			//endregion
			
			//region Work with name constraints
			//region Check a result from "policy checking" part
			if(policyResult.result === false)
				return policyResult;
			//endregion
			
			//region Check all certificates, excluding "trust anchor"
			pathDepth = 1;
			
			for(let i = (this.certs.length - 2); i >= 0; i--, pathDepth++)
			{
				//region Support variables
				let subjectAltNames = [];
				
				let certPermittedSubtrees = [];
				let certExcludedSubtrees = [];
				//endregion
				
				if("extensions" in this.certs[i])
				{
					for(let j = 0; j < this.certs[i].extensions.length; j++)
					{
						//region NameConstraints
						if(this.certs[i].extensions[j].extnID === "2.5.29.30")
						{
							if("permittedSubtrees" in this.certs[i].extensions[j].parsedValue)
								certPermittedSubtrees = certPermittedSubtrees.concat(this.certs[i].extensions[j].parsedValue.permittedSubtrees);
							
							if("excludedSubtrees" in this.certs[i].extensions[j].parsedValue)
								certExcludedSubtrees = certExcludedSubtrees.concat(this.certs[i].extensions[j].parsedValue.excludedSubtrees);
						}
						//endregion
						
						//region SubjectAltName
						if(this.certs[i].extensions[j].extnID === "2.5.29.17")
							subjectAltNames = subjectAltNames.concat(this.certs[i].extensions[j].parsedValue.altNames);
						//endregion
					}
				}
				
				//region Checking for "required name forms"
				let formFound = (requiredNameForms.length <= 0);
				
				for(let j = 0; j < requiredNameForms.length; j++)
				{
					switch(requiredNameForms[j].base.type)
					{
						case 4: // directoryName
						{
							if(requiredNameForms[j].base.value.typesAndValues.length !== this.certs[i].subject.typesAndValues.length)
								continue;
							
							formFound = true;
							
							for(let k = 0; k < this.certs[i].subject.typesAndValues.length; k++)
							{
								if(this.certs[i].subject.typesAndValues[k].type !== requiredNameForms[j].base.value.typesAndValues[k].type)
								{
									formFound = false;
									break;
								}
							}
							
							if(formFound === true)
								break;
						}
							break;
						default: // ??? Probably here we should reject the certificate ???
					}
				}
				
				if(formFound === false)
				{
					policyResult.result = false;
					policyResult.resultCode = 21;
					policyResult.resultMessage = "No neccessary name form found";
					
					throw policyResult;
				}
				//endregion
				
				//region Checking for "permited sub-trees"
				//region Make groups for all types of constraints
				const constrGroups = []; // Array of array for groupped constraints
				constrGroups[0] = []; // rfc822Name
				constrGroups[1] = []; // dNSName
				constrGroups[2] = []; // directoryName
				constrGroups[3] = []; // uniformResourceIdentifier
				constrGroups[4] = []; // iPAddress
				
				for(let j = 0; j < permittedSubtrees.length; j++)
				{
					switch(permittedSubtrees[j].base.type)
					{
						//region rfc822Name
						case 1:
							constrGroups[0].push(permittedSubtrees[j]);
							break;
						//endregion
						//region dNSName
						case 2:
							constrGroups[1].push(permittedSubtrees[j]);
							break;
						//endregion
						//region directoryName
						case 4:
							constrGroups[2].push(permittedSubtrees[j]);
							break;
						//endregion
						//region uniformResourceIdentifier
						case 6:
							constrGroups[3].push(permittedSubtrees[j]);
							break;
						//endregion
						//region iPAddress
						case 7:
							constrGroups[4].push(permittedSubtrees[j]);
							break;
						//endregion
						//region default
						default:
						//endregion
					}
				}
				//endregion
				
				//region Check name constraints groupped by type, one-by-one
				for(let p = 0; p < 5; p++)
				{
					let groupPermitted = false;
					let valueExists = false;
					const group = constrGroups[p];
					
					for(let j = 0; j < group.length; j++)
					{
						switch(p)
						{
							//region rfc822Name
							case 0:
								if(subjectAltNames.length > 0)
								{
									for(let k = 0; k < subjectAltNames.length; k++)
									{
										if(subjectAltNames[k].type === 1) // rfc822Name
										{
											valueExists = true;
											groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[k].value, group[j].base.value);
										}
									}
								}
								else // Try to find out "emailAddress" inside "subject"
								{
									for(let k = 0; k < this.certs[i].subject.typesAndValues.length; k++)
									{
										if((this.certs[i].subject.typesAndValues[k].type === "1.2.840.113549.1.9.1") ||    // PKCS#9 e-mail address
											(this.certs[i].subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3")) // RFC1274 "rfc822Mailbox" e-mail address
										{
											valueExists = true;
											groupPermitted = groupPermitted || compareRFC822Name(this.certs[i].subject.typesAndValues[k].value.valueBlock.value, group[j].base.value);
										}
									}
								}
								break;
							//endregion
							//region dNSName
							case 1:
								if(subjectAltNames.length > 0)
								{
									for(let k = 0; k < subjectAltNames.length; k++)
									{
										if(subjectAltNames[k].type === 2) // dNSName
										{
											valueExists = true;
											groupPermitted = groupPermitted || compareDNSName(subjectAltNames[k].value, group[j].base.value);
										}
									}
								}
								break;
							//endregion
							//region directoryName
							case 2:
								valueExists = true;
								groupPermitted = compareDirectoryName(this.certs[i].subject, group[j].base.value);
								break;
							//endregion
							//region uniformResourceIdentifier
							case 3:
								if(subjectAltNames.length > 0)
								{
									for(let k = 0; k < subjectAltNames.length; k++)
									{
										if(subjectAltNames[k].type === 6) // uniformResourceIdentifier
										{
											valueExists = true;
											groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[k].value, group[j].base.value);
										}
									}
								}
								break;
							//endregion
							//region iPAddress
							case 4:
								if(subjectAltNames.length > 0)
								{
									for(let k = 0; k < subjectAltNames.length; k++)
									{
										if(subjectAltNames[k].type === 7) // iPAddress
										{
											valueExists = true;
											groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[k].value, group[j].base.value);
										}
									}
								}
								break;
							//endregion
							//region default
							default:
							//endregion
						}
						
						if(groupPermitted)
							break;
					}
					
					if((groupPermitted === false) && (group.length > 0) && valueExists)
					{
						policyResult.result = false;
						policyResult.resultCode = 41;
						policyResult.resultMessage = "Failed to meet \"permitted sub-trees\" name constraint";
						
						throw policyResult;
					}
				}
				//endregion
				//endregion
				
				//region Checking for "excluded sub-trees"
				let excluded = false;
				
				for(let j = 0; j < excludedSubtrees.length; j++)
				{
					switch(excludedSubtrees[j].base.type)
					{
						//region rfc822Name
						case 1:
							if(subjectAltNames.length >= 0)
							{
								for(let k = 0; k < subjectAltNames.length; k++)
								{
									if(subjectAltNames[k].type === 1) // rfc822Name
										excluded = excluded || compareRFC822Name(subjectAltNames[k].value, excludedSubtrees[j].base.value);
								}
							}
							else // Try to find out "emailAddress" inside "subject"
							{
								for(let k = 0; k < this.certs[i].subject.typesAndValues.length; k++)
								{
									if((this.certs[i].subject.typesAndValues[k].type === "1.2.840.113549.1.9.1") ||    // PKCS#9 e-mail address
										(this.certs[i].subject.typesAndValues[k].type === "0.9.2342.19200300.100.1.3")) // RFC1274 "rfc822Mailbox" e-mail address
										excluded = excluded || compareRFC822Name(this.certs[i].subject.typesAndValues[k].value.valueBlock.value, excludedSubtrees[j].base.value);
								}
							}
							break;
						//endregion
						//region dNSName
						case 2:
							if(subjectAltNames.length > 0)
							{
								for(let k = 0; k < subjectAltNames.length; k++)
								{
									if(subjectAltNames[k].type === 2) // dNSName
										excluded = excluded || compareDNSName(subjectAltNames[k].value, excludedSubtrees[j].base.value);
								}
							}
							break;
						//endregion
						//region directoryName
						case 4:
							excluded = excluded || compareDirectoryName(this.certs[i].subject, excludedSubtrees[j].base.value);
							break;
						//endregion
						//region uniformResourceIdentifier
						case 6:
							if(subjectAltNames.length > 0)
							{
								for(let k = 0; k < subjectAltNames.length; k++)
								{
									if(subjectAltNames[k].type === 6) // uniformResourceIdentifier
										excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[k].value, excludedSubtrees[j].base.value);
								}
							}
							break;
						//endregion
						//region iPAddress
						case 7:
							if(subjectAltNames.length > 0)
							{
								for(let k = 0; k < subjectAltNames.length; k++)
								{
									if(subjectAltNames[k].type === 7) // iPAddress
										excluded = excluded || compareIPAddress(subjectAltNames[k].value, excludedSubtrees[j].base.value);
								}
							}
							break;
						//endregion
						//region default
						default: // No action, but probably here we need to create a warning for "malformed constraint"
						//endregion
					}
					
					if(excluded)
						break;
				}
				
				if(excluded === true)
				{
					policyResult.result = false;
					policyResult.resultCode = 42;
					policyResult.resultMessage = "Failed to meet \"excluded sub-trees\" name constraint";
					
					throw policyResult;
				}
				//endregion
				
				//region Append "cert_..._subtrees" to "..._subtrees"
				permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
				excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees);
				//endregion
			}
			//endregion
			
			return policyResult;
			//endregion
		}
		catch(error)
		{
			if(error instanceof Object)
			{
				if("resultMessage" in error)
					return error;
				
				if("message" in error)
				{
					return {
						result: false,
						resultCode: -1,
						resultMessage: error.message
					};
				}
			}
			
			return {
				result: false,
				resultCode: -1,
				resultMessage: error
			};
		}
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CertificatePolicies.js":
/*!*******************************************************!*\
  !*** ./node_modules/pkijs/src/CertificatePolicies.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CertificatePolicies; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _PolicyInformation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PolicyInformation.js */ "./node_modules/pkijs/src/PolicyInformation.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class CertificatePolicies
{
	//**********************************************************************************
	/**
	 * Constructor for CertificatePolicies class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<PolicyInformation>}
		 * @desc certificatePolicies
		 */
		this.certificatePolicies = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certificatePolicies", CertificatePolicies.defaultValues("certificatePolicies"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "certificatePolicies":
				return [];
			default:
				throw new Error(`Invalid member name for CertificatePolicies class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * certificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [certificatePolicies]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.certificatePolicies || ""),
					value: _PolicyInformation_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"certificatePolicies"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			CertificatePolicies.schema({
				names: {
					certificatePolicies: "certificatePolicies"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for CertificatePolicies");
		//endregion

		//region Get internal properties from parsed schema
		this.certificatePolicies = Array.from(asn1.result.certificatePolicies, element => new _PolicyInformation_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.certificatePolicies, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			certificatePolicies: Array.from(this.certificatePolicies, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CertificateRevocationList.js":
/*!*************************************************************!*\
  !*** ./node_modules/pkijs/src/CertificateRevocationList.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CertificateRevocationList; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");
/* harmony import */ var _Time_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Time.js */ "./node_modules/pkijs/src/Time.js");
/* harmony import */ var _RevokedCertificate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RevokedCertificate.js */ "./node_modules/pkijs/src/RevokedCertificate.js");
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Extensions.js */ "./node_modules/pkijs/src/Extensions.js");








//**************************************************************************************
function tbsCertList(parameters = {})
{
	//TBSCertList  ::=  SEQUENCE  {
	//    version                 Version OPTIONAL,
	//                                 -- if present, MUST be v2
	//    signature               AlgorithmIdentifier,
	//    issuer                  Name,
	//    thisUpdate              Time,
	//    nextUpdate              Time OPTIONAL,
	//    revokedCertificates     SEQUENCE OF SEQUENCE  {
	//        userCertificate         CertificateSerialNumber,
	//        revocationDate          Time,
	//        crlEntryExtensions      Extensions OPTIONAL
	//        -- if present, version MUST be v2
	//    }  OPTIONAL,
	//    crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
	//    -- if present, version MUST be v2
	//}
	
	/**
	 * @type {Object}
	 * @property {string} [blockName]
	 * @property {string} [tbsCertListVersion]
	 * @property {string} [signature]
	 * @property {string} [issuer]
	 * @property {string} [tbsCertListThisUpdate]
	 * @property {string} [tbsCertListNextUpdate]
	 * @property {string} [tbsCertListRevokedCertificates]
	 * @property {string} [crlExtensions]
	 */
	const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
	
	return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
		name: (names.blockName || "tbsCertList"),
		value: [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
				optional: true,
				name: (names.tbsCertListVersion || "tbsCertList.version"),
				value: 2
			}), // EXPLICIT integer value (v2)
			_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.signature || {
				names: {
					blockName: "tbsCertList.signature"
				}
			}),
			_RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.issuer || {
				names: {
					blockName: "tbsCertList.issuer"
				}
			}),
			_Time_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.tbsCertListThisUpdate || {
				names: {
					utcTimeName: "tbsCertList.thisUpdate",
					generalTimeName: "tbsCertList.thisUpdate"
				}
			}),
			_Time_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.tbsCertListNextUpdate || {
				names: {
					utcTimeName: "tbsCertList.nextUpdate",
					generalTimeName: "tbsCertList.nextUpdate"
				}
			}, true),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				optional: true,
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
						name: (names.tbsCertListRevokedCertificates || "tbsCertList.revokedCertificates"),
						value: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
							value: [
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"](),
								_Time_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(),
								_Extensions_js__WEBPACK_IMPORTED_MODULE_7__["default"].schema({}, true)
							]
						})
					})
				]
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [_Extensions_js__WEBPACK_IMPORTED_MODULE_7__["default"].schema(names.crlExtensions || {
					names: {
						blockName: "tbsCertList.extensions"
					}
				})]
			}) // EXPLICIT SEQUENCE value
		]
	}));
}
//**************************************************************************************
/**
 * Class from RFC5280
 */
class CertificateRevocationList {
	//**********************************************************************************
	/**
	 * Constructor for Attribute class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {ArrayBuffer}
		 * @desc tbs
		 */
		this.tbs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "tbs", CertificateRevocationList.defaultValues("tbs"));
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", CertificateRevocationList.defaultValues("version"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc signature
		 */
		this.signature = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signature", CertificateRevocationList.defaultValues("signature"));
		/**
		 * @type {RelativeDistinguishedNames}
		 * @desc issuer
		 */
		this.issuer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuer", CertificateRevocationList.defaultValues("issuer"));
		/**
		 * @type {Time}
		 * @desc thisUpdate
		 */
		this.thisUpdate = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "thisUpdate", CertificateRevocationList.defaultValues("thisUpdate"));
		
		if("nextUpdate" in parameters)
			/**
			 * @type {Time}
			 * @desc nextUpdate
			 */
			this.nextUpdate = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "nextUpdate", CertificateRevocationList.defaultValues("nextUpdate"));
		
		if("revokedCertificates" in parameters)
			/**
			 * @type {Array.<RevokedCertificate>}
			 * @desc revokedCertificates
			 */
			this.revokedCertificates = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "revokedCertificates", CertificateRevocationList.defaultValues("revokedCertificates"));
		
		if("crlExtensions" in parameters)
			/**
			 * @type {Extensions}
			 * @desc crlExtensions
			 */
			this.crlExtensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "crlExtensions", CertificateRevocationList.defaultValues("crlExtensions"));
		
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc signatureAlgorithm
		 */
		this.signatureAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureAlgorithm", CertificateRevocationList.defaultValues("signatureAlgorithm"));
		/**
		 * @type {BitString}
		 * @desc signatureValue
		 */
		this.signatureValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureValue", CertificateRevocationList.defaultValues("signatureValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "tbs":
				return new ArrayBuffer(0);
			case "version":
				return 1;
			case "signature":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "issuer":
				return new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			case "thisUpdate":
				return new _Time_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			case "nextUpdate":
				return new _Time_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			case "revokedCertificates":
				return [];
			case "crlExtensions":
				return new _Extensions_js__WEBPACK_IMPORTED_MODULE_7__["default"]();
			case "signatureAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "signatureValue":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for CertificateRevocationList class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * CertificateList  ::=  SEQUENCE  {
	 *    tbsCertList          TBSCertList,
	 *    signatureAlgorithm   AlgorithmIdentifier,
	 *    signatureValue       BIT STRING  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [signatureAlgorithm]
		 * @property {string} [signatureValue]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "CertificateList"),
			value: [
				tbsCertList(parameters),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.signatureAlgorithm || {
					names: {
						blockName: "signatureAlgorithm"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.signatureValue || "signatureValue") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"tbsCertList",
			"tbsCertList.version",
			"tbsCertList.signature",
			"tbsCertList.issuer",
			"tbsCertList.thisUpdate",
			"tbsCertList.nextUpdate",
			"tbsCertList.revokedCertificates",
			"tbsCertList.extensions",
			"signatureAlgorithm",
			"signatureValue"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			CertificateRevocationList.schema()
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for CertificateRevocationList");
		//endregion
		
		//region Get internal properties from parsed schema
		// noinspection JSUnresolvedVariable
		this.tbs = asn1.result.tbsCertList.valueBeforeDecode;
		
		if("tbsCertList.version" in asn1.result)
			this.version = asn1.result["tbsCertList.version"].valueBlock.valueDec;
		this.signature = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result["tbsCertList.signature"] });
		this.issuer = new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result["tbsCertList.issuer"] });
		this.thisUpdate = new _Time_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result["tbsCertList.thisUpdate"] });
		if("tbsCertList.nextUpdate" in asn1.result)
			this.nextUpdate = new _Time_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result["tbsCertList.nextUpdate"] });
		if("tbsCertList.revokedCertificates" in asn1.result)
			this.revokedCertificates = Array.from(asn1.result["tbsCertList.revokedCertificates"], element => new _RevokedCertificate_js__WEBPACK_IMPORTED_MODULE_6__["default"]({ schema: element }));
		if("tbsCertList.extensions" in asn1.result)
			this.crlExtensions = new _Extensions_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: asn1.result["tbsCertList.extensions"] });
		
		this.signatureAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.signatureAlgorithm });
		this.signatureValue = asn1.result.signatureValue;
		//endregion
	}
	//**********************************************************************************
	encodeTBS()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if(this.version !== CertificateRevocationList.defaultValues("version"))
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
		
		outputArray.push(this.signature.toSchema());
		outputArray.push(this.issuer.toSchema());
		outputArray.push(this.thisUpdate.toSchema());
		
		if("nextUpdate" in this)
			outputArray.push(this.nextUpdate.toSchema());
		
		if("revokedCertificates" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: Array.from(this.revokedCertificates, element => element.toSchema())
			}));
		}
		
		if("crlExtensions" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [
					this.crlExtensions.toSchema()
				]
			}));
		}
		//endregion
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema(encodeFlag = false)
	{
		//region Decode stored TBS value
		let tbsSchema;
		
		if(encodeFlag === false)
		{
			if(this.tbs.length === 0) // No stored TBS part
				return CertificateRevocationList.schema();
			
			tbsSchema = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.tbs).result;
		}
		//endregion
		//region Create TBS schema via assembling from TBS parts
		else
			tbsSchema = this.encodeTBS();
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				tbsSchema,
				this.signatureAlgorithm.toSchema(),
				this.signatureValue
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			tbs: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["bufferToHexCodes"])(this.tbs, 0, this.tbs.byteLength),
			signature: this.signature.toJSON(),
			issuer: this.issuer.toJSON(),
			thisUpdate: this.thisUpdate.toJSON(),
			signatureAlgorithm: this.signatureAlgorithm.toJSON(),
			signatureValue: this.signatureValue.toJSON()
		};
		
		if(this.version !== CertificateRevocationList.defaultValues("version"))
			object.version = this.version;
		
		if("nextUpdate" in this)
			object.nextUpdate = this.nextUpdate.toJSON();
		
		if("revokedCertificates" in this)
			object.revokedCertificates = Array.from(this.revokedCertificates, element => element.toJSON());
		
		if("crlExtensions" in this)
			object.crlExtensions = this.crlExtensions.toJSON();
		
		return object;
	}
	//**********************************************************************************
	isCertificateRevoked(certificate)
	{
		//region Check that issuer of the input certificate is the same with issuer of this CRL
		if(this.issuer.isEqual(certificate.issuer) === false)
			return false;
		//endregion
		
		//region Check that there are revoked certificates in this CRL
		if(("revokedCertificates" in this) === false)
			return false;
		//endregion
		
		//region Search for input certificate in revoked certificates array
		for(const revokedCertificate of this.revokedCertificates)
		{
			if(revokedCertificate.userCertificate.isEqual(certificate.serialNumber))
				return true;
		}
		//endregion
		
		return false;
	}
	//**********************************************************************************
	/**
	 * Make a signature for existing CRL data
	 * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
	 * @param {string} [hashAlgorithm] Hashing algorithm. Default SHA-1
	 */
	sign(privateKey, hashAlgorithm = "SHA-1")
	{
		//region Initial checking
		//region Get a private key from function parameter
		if(typeof privateKey === "undefined")
			return Promise.reject("Need to provide a private key for signing");
		//endregion
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		let parameters;
		
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		//endregion
		
		//region Get a "default parameters" for current algorithm and set correct signature algorithm
		sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
		
		sequence = sequence.then(result =>
		{
			parameters = result.parameters;
			this.signature = result.signatureAlgorithm;
			this.signatureAlgorithm = result.signatureAlgorithm;
		});
		//endregion
		
		//region Create TBS data for signing
		sequence = sequence.then(() =>
		{
			this.tbs = this.encodeTBS().toBER(false);
		});
		//endregion
		
		//region Signing TBS data on provided private key
		sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));
		
		sequence = sequence.then(result =>
		{
			this.signatureValue = new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ valueHex: result });
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Verify existing signature
	 * @param {{[issuerCertificate]: Object, [publicKeyInfo]: Object}} parameters
	 * @returns {*}
	 */
	verify(parameters = {})
	{
		//region Global variables
		let sequence = Promise.resolve();
		
		let subjectPublicKeyInfo = -1;
		
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		//endregion
		
		//region Get information about CRL issuer certificate
		if("issuerCertificate" in parameters) // "issuerCertificate" must be of type "Certificate"
		{
			subjectPublicKeyInfo = parameters.issuerCertificate.subjectPublicKeyInfo;
			
			// The CRL issuer name and "issuerCertificate" subject name are not equal
			if(this.issuer.isEqual(parameters.issuerCertificate.subject) === false)
				return Promise.resolve(false);
		}
		
		//region In case if there is only public key during verification
		if("publicKeyInfo" in parameters)
			subjectPublicKeyInfo = parameters.publicKeyInfo; // Must be of type "PublicKeyInfo"
		//endregion
		
		if(("subjectPublicKey" in subjectPublicKeyInfo) === false)
			return Promise.reject("Issuer's certificate must be provided as an input parameter");
		//endregion
		
		//region Check the CRL for unknown critical extensions
		if("crlExtensions" in this)
		{
			for(const extension of this.crlExtensions.extensions)
			{
				if(extension.critical)
				{
					// We can not be sure that unknown extension has no value for CRL signature
					if(("parsedValue" in extension) === false)
						return Promise.resolve(false);
				}
			}
		}
		//endregion
		
		sequence = sequence.then(() => engine.subtle.verifyWithPublicKey(this.tbs, this.signatureValue, subjectPublicKeyInfo, this.signatureAlgorithm));
		
		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CertificateSet.js":
/*!**************************************************!*\
  !*** ./node_modules/pkijs/src/CertificateSet.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CertificateSet; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Certificate.js */ "./node_modules/pkijs/src/Certificate.js");
/* harmony import */ var _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AttributeCertificateV1.js */ "./node_modules/pkijs/src/AttributeCertificateV1.js");
/* harmony import */ var _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AttributeCertificateV2.js */ "./node_modules/pkijs/src/AttributeCertificateV2.js");
/* harmony import */ var _OtherCertificateFormat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./OtherCertificateFormat.js */ "./node_modules/pkijs/src/OtherCertificateFormat.js");






//**************************************************************************************
/**
 * Class from RFC5652
 */
class CertificateSet
{
	//**********************************************************************************
	/**
	 * Constructor for CertificateSet class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array}
		 * @desc certificates
		 */
		this.certificates = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certificates", CertificateSet.defaultValues("certificates"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "certificates":
				return [];
			default:
				throw new Error(`Invalid member name for Attribute class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * CertificateSet ::= SET OF CertificateChoices
	 *
	 * CertificateChoices ::= CHOICE {
	 *    certificate Certificate,
	 *    extendedCertificate [0] IMPLICIT ExtendedCertificate,  -- Obsolete
	 *    v1AttrCert [1] IMPLICIT AttributeCertificateV1,        -- Obsolete
	 *    v2AttrCert [2] IMPLICIT AttributeCertificateV2,
	 *    other [3] IMPLICIT OtherCertificateFormat }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
				name: (names.blockName || ""),
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
						name: (names.certificates || "certificates"),
						value: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
							value: [
								_Certificate_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(),
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
									idBlock: {
										tagClass: 3, // CONTEXT-SPECIFIC
										tagNumber: 0 // [0]
									},
									value: [
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]()
									]
								}), // JUST A STUB
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
									idBlock: {
										tagClass: 3, // CONTEXT-SPECIFIC
										tagNumber: 1 // [1]
									},
									value: [
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]
									]
								}),
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
									idBlock: {
										tagClass: 3, // CONTEXT-SPECIFIC
										tagNumber: 2 // [2]
									},
									value: _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema().valueBlock.value
								}),
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
									idBlock: {
										tagClass: 3, // CONTEXT-SPECIFIC
										tagNumber: 3 // [3]
									},
									value: _OtherCertificateFormat_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema().valueBlock.value
								})
							]
						})
					})
				]
			})
		);
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"certificates"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			CertificateSet.schema()
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for CertificateSet");
		//endregion
		
		//region Get internal properties from parsed schema
		this.certificates = Array.from(asn1.result.certificates || [], element =>
		{
			const initialTagNumber = element.idBlock.tagNumber;

			if(element.idBlock.tagClass === 1)
				return new _Certificate_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element });
			
			//region Making "Sequence" from "Constructed" value
			const elementSequence = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: element.valueBlock.value
			});
			//endregion

			switch(initialTagNumber)
			{
				case 1:
					// WARN: It's possible that CMS contains AttributeCertificateV2 instead of AttributeCertificateV1
					// Check the certificate version
					if (elementSequence.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec === 1) {
						return new _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: elementSequence });
					} else {
						return new _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: elementSequence });
					}
				case 2:
					return new _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: elementSequence });
				case 3:
					return new _OtherCertificateFormat_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: elementSequence });
				case 0:
				default:
			}
			
			return element;
		});
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
			value: Array.from(this.certificates, element =>
			{
				switch(true)
				{
					case (element instanceof _Certificate_js__WEBPACK_IMPORTED_MODULE_2__["default"]):
						return element.toSchema();
					case (element instanceof _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_3__["default"]):
						return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							idBlock: {
								tagClass: 3,
								tagNumber: 1 // [1]
							},
							value: element.toSchema().valueBlock.value
						});
					case (element instanceof _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_4__["default"]):
						return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							idBlock: {
								tagClass: 3,
								tagNumber: 2 // [2]
							},
							value: element.toSchema().valueBlock.value
						});
					case (element instanceof _OtherCertificateFormat_js__WEBPACK_IMPORTED_MODULE_5__["default"]):
						return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							idBlock: {
								tagClass: 3,
								tagNumber: 3 // [3]
							},
							value: element.toSchema().valueBlock.value
						});
					default:
				}
				
				return element;
			})
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			certificates: Array.from(this.certificates, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CertificateTemplate.js":
/*!*******************************************************!*\
  !*** ./node_modules/pkijs/src/CertificateTemplate.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CertificateTemplate; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from "[MS-WCCE]: Windows Client Certificate Enrollment Protocol"
 */
class CertificateTemplate
{
	//**********************************************************************************
	/**
	 * Constructor for CertificateTemplate class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc templateID
		 */
		this.templateID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "templateID", CertificateTemplate.defaultValues("templateID"));

		if("templateMajorVersion" in parameters)
			/**
			 * @type {number}
			 * @desc templateMajorVersion
			 */
			this.templateMajorVersion = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "templateMajorVersion", CertificateTemplate.defaultValues("templateMajorVersion"));

		if("templateMinorVersion" in parameters)
			/**
			 * @type {number}
			 * @desc templateMinorVersion
			 */
			this.templateMinorVersion = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "templateMinorVersion", CertificateTemplate.defaultValues("templateMinorVersion"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "templateID":
				return "";
			case "templateMajorVersion":
			case "templateMinorVersion":
				return 0;
			default:
				throw new Error(`Invalid member name for CertificateTemplate class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * CertificateTemplateOID ::= SEQUENCE {
     *    templateID              OBJECT IDENTIFIER,
     *    templateMajorVersion    INTEGER (0..4294967295) OPTIONAL,
     *    templateMinorVersion    INTEGER (0..4294967295) OPTIONAL
     * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [templateID]
		 * @property {string} [templateMajorVersion]
		 * @property {string} [templateMinorVersion]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.templateID || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
					name: (names.templateMajorVersion || ""),
					optional: true
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
					name: (names.templateMinorVersion || ""),
					optional: true
				}),
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"templateID",
			"templateMajorVersion",
			"templateMinorVersion"
		]);
		//endregion

		//region Check the schema is valid
		let asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			CertificateTemplate.schema({
				names: {
					templateID: "templateID",
					templateMajorVersion: "templateMajorVersion",
					templateMinorVersion: "templateMinorVersion"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for CertificateTemplate");
		//endregion

		//region Get internal properties from parsed schema
		this.templateID = asn1.result.templateID.valueBlock.toString();

		if("templateMajorVersion" in asn1.result)
			this.templateMajorVersion = asn1.result.templateMajorVersion.valueBlock.valueDec;

		if("templateMinorVersion" in asn1.result)
			this.templateMinorVersion = asn1.result.templateMinorVersion.valueBlock.valueDec;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.templateID }));

		if("templateMajorVersion" in this)
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.templateMajorVersion }));

		if("templateMinorVersion" in this)
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.templateMinorVersion }));
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			extnID: this.templateID
		};

		if("templateMajorVersion" in this)
			object.templateMajorVersion = this.templateMajorVersion;

		if("templateMinorVersion" in this)
			object.templateMinorVersion = this.templateMinorVersion;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CertificationRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/pkijs/src/CertificationRequest.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CertificationRequest; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKeyInfo.js */ "./node_modules/pkijs/src/PublicKeyInfo.js");
/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");







//**************************************************************************************
function CertificationRequestInfo(parameters = {})
{
	//CertificationRequestInfo ::= SEQUENCE {
	//    version       INTEGER { v1(0) } (v1,...),
	//    subject       Name,
	//    subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
	//    attributes    [0] Attributes{{ CRIAttributes }}
	//}
	
	/**
	 * @type {Object}
	 * @property {string} [blockName]
	 * @property {string} [CertificationRequestInfo]
	 * @property {string} [CertificationRequestInfoVersion]
	 * @property {string} [subject]
	 * @property {string} [CertificationRequestInfoAttributes]
	 * @property {string} [attributes]
	 */
	const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
	
	return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
		name: (names.CertificationRequestInfo || "CertificationRequestInfo"),
		value: [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.CertificationRequestInfoVersion || "CertificationRequestInfo.version") }),
			_RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.subject || {
				names: {
					blockName: "CertificationRequestInfo.subject"
				}
			}),
			_PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema({
				names: {
					blockName: "CertificationRequestInfo.subjectPublicKeyInfo"
				}
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
						optional: true, // Because OpenSSL makes wrong "attributes" field
						name: (names.CertificationRequestInfoAttributes || "CertificationRequestInfo.attributes"),
						value: _Attribute_js__WEBPACK_IMPORTED_MODULE_6__["default"].schema(names.attributes || {})
					})
				]
			})
		]
	}));
}
//**************************************************************************************
/**
 * Class from RFC2986
 */
class CertificationRequest
{
	//**********************************************************************************
	/**
	 * Constructor for Attribute class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {ArrayBuffer}
		 * @desc tbs
		 */
		this.tbs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "tbs", CertificationRequest.defaultValues("tbs"));
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", CertificationRequest.defaultValues("version"));
		/**
		 * @type {RelativeDistinguishedNames}
		 * @desc subject
		 */
		this.subject = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subject", CertificationRequest.defaultValues("subject"));
		/**
		 * @type {PublicKeyInfo}
		 * @desc subjectPublicKeyInfo
		 */
		this.subjectPublicKeyInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subjectPublicKeyInfo", CertificationRequest.defaultValues("subjectPublicKeyInfo"));
		
		if("attributes" in parameters)
			/**
			 * @type {Array.<Attribute>}
			 * @desc attributes
			 */
			this.attributes = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "attributes", CertificationRequest.defaultValues("attributes"));
		
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc signatureAlgorithm
		 */
		this.signatureAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureAlgorithm", CertificationRequest.defaultValues("signatureAlgorithm"));
		/**
		 * @type {BitString}
		 * @desc signatureAlgorithm
		 */
		this.signatureValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureValue", CertificationRequest.defaultValues("signatureValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "tbs":
				return new ArrayBuffer(0);
			case "version":
				return 0;
			case "subject":
				return new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			case "subjectPublicKeyInfo":
				return new _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "attributes":
				return [];
			case "signatureAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			case "signatureValue":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for CertificationRequest class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * CertificationRequest ::= SEQUENCE {
	 *    certificationRequestInfo CertificationRequestInfo,
	 *    signatureAlgorithm       AlgorithmIdentifier{{ SignatureAlgorithms }},
	 *    signature                BIT STRING
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [certificationRequestInfo]
		 * @property {string} [signatureAlgorithm]
		 * @property {string} [signatureValue]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				CertificationRequestInfo(names.certificationRequestInfo || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					name: (names.signatureAlgorithm || "signatureAlgorithm"),
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"](),
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ optional: true })
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.signatureValue || "signatureValue") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"CertificationRequestInfo",
			"CertificationRequestInfo.version",
			"CertificationRequestInfo.subject",
			"CertificationRequestInfo.subjectPublicKeyInfo",
			"CertificationRequestInfo.attributes",
			"signatureAlgorithm",
			"signatureValue"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			CertificationRequest.schema()
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for CertificationRequest");
		//endregion
		
		//region Get internal properties from parsed schema
		this.tbs = asn1.result.CertificationRequestInfo.valueBeforeDecode;
		
		this.version = asn1.result["CertificationRequestInfo.version"].valueBlock.valueDec;
		this.subject = new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result["CertificationRequestInfo.subject"] });
		this.subjectPublicKeyInfo = new _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result["CertificationRequestInfo.subjectPublicKeyInfo"] });
		if("CertificationRequestInfo.attributes" in asn1.result)
			this.attributes = Array.from(asn1.result["CertificationRequestInfo.attributes"], element => new _Attribute_js__WEBPACK_IMPORTED_MODULE_6__["default"]({ schema: element }));
		
		this.signatureAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result.signatureAlgorithm });
		this.signatureValue = asn1.result.signatureValue;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Aux function making ASN1js Sequence from current TBS
	 * @returns {Sequence}
	 */
	encodeTBS()
	{
		//region Create array for output sequence
		const outputArray = [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }),
			this.subject.toSchema(),
			this.subjectPublicKeyInfo.toSchema()
		];
		
		if("attributes" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: Array.from(this.attributes, element => element.toSchema())
			}));
		}
		//endregion
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema(encodeFlag = false)
	{
		//region Decode stored TBS value
		let tbsSchema;
		
		if(encodeFlag === false)
		{
			if(this.tbs.byteLength === 0) // No stored TBS part
				return CertificationRequest.schema();
			
			tbsSchema = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.tbs).result;
		}
		//endregion
		//region Create TBS schema via assembling from TBS parts
		else
			tbsSchema = this.encodeTBS();
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				tbsSchema,
				this.signatureAlgorithm.toSchema(),
				this.signatureValue
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			tbs: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["bufferToHexCodes"])(this.tbs, 0, this.tbs.byteLength),
			version: this.version,
			subject: this.subject.toJSON(),
			subjectPublicKeyInfo: this.subjectPublicKeyInfo.toJSON(),
			signatureAlgorithm: this.signatureAlgorithm.toJSON(),
			signatureValue: this.signatureValue.toJSON()
		};
		
		if("attributes" in this)
			object.attributes = Array.from(this.attributes, element => element.toJSON());
		
		return object;
	}
	//**********************************************************************************
	/**
	 * Makes signature for currect certification request
	 * @param {Object} privateKey WebCrypto private key
	 * @param {string} [hashAlgorithm=SHA-1] String representing current hashing algorithm
	 */
	sign(privateKey, hashAlgorithm = "SHA-1")
	{
		//region Initial checking
		//region Get a private key from function parameter
		if(typeof privateKey === "undefined")
			return Promise.reject("Need to provide a private key for signing");
		//endregion
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		let parameters;
		
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		//endregion
		
		//region Get a "default parameters" for current algorithm and set correct signature algorithm
		sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
		
		sequence = sequence.then(result =>
		{
			parameters = result.parameters;
			this.signatureAlgorithm = result.signatureAlgorithm;
		});
		//endregion
		
		//region Create TBS data for signing
		sequence = sequence.then(() =>
		{
			this.tbs = this.encodeTBS().toBER(false);
		});
		//endregion
		
		//region Signing TBS data on provided private key
		sequence = sequence.then(() => engine.subtle.signWithPrivateKey(this.tbs, privateKey, parameters));
		
		sequence = sequence.then(result =>
		{
			this.signatureValue = new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ valueHex: result });
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Verify existing certification request signature
	 * @returns {*}
	 */
	verify()
	{
		return Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])().subtle.verifyWithPublicKey(this.tbs, this.signatureValue, this.subjectPublicKeyInfo, this.signatureAlgorithm);
	}
	//**********************************************************************************
	/**
	 * Importing public key for current certificate request
	 */
	getPublicKey(parameters = null)
	{
		return Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])().getPublicKey(this.subjectPublicKeyInfo, this.signatureAlgorithm, parameters);
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/ContentInfo.js":
/*!***********************************************!*\
  !*** ./node_modules/pkijs/src/ContentInfo.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ContentInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5652
 */
class ContentInfo
{
	//**********************************************************************************
	/**
	 * Constructor for ContentInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc contentType
		 */
		this.contentType = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "contentType", ContentInfo.defaultValues("contentType"));
		/**
		 * @type {Any}
		 * @desc content
		 */
		this.content = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "content", ContentInfo.defaultValues("content"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "contentType":
				return "";
			case "content":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
			default:
				throw new Error(`Invalid member name for ContentInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "contentType":
				return (memberValue === "");
			case "content":
				return (memberValue instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]);
			default:
				throw new Error(`Invalid member name for ContentInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * ContentInfo ::= SEQUENCE {
	 *    contentType ContentType,
	 *    content [0] EXPLICIT ANY DEFINED BY contentType }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [contentType]
		 * @property {string} [content]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		if(("optional" in names) === false)
			names.optional = false;

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "ContentInfo"),
			optional: names.optional,
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.contentType || "contentType") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.content || "content") })] // EXPLICIT ANY value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"contentType",
			"content"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			ContentInfo.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for ContentInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.contentType = asn1.result.contentType.valueBlock.toString();
		this.content = asn1.result.content;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.contentType }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [this.content] // EXPLICIT ANY value
				})
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			contentType: this.contentType
		};

		if(!(this.content instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]))
			object.content = this.content.toJSON();

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/CryptoEngine.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/CryptoEngine.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CryptoEngine; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKeyInfo.js */ "./node_modules/pkijs/src/PublicKeyInfo.js");
/* harmony import */ var _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PrivateKeyInfo.js */ "./node_modules/pkijs/src/PrivateKeyInfo.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EncryptedContentInfo.js */ "./node_modules/pkijs/src/EncryptedContentInfo.js");
/* harmony import */ var _RSASSAPSSParams_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RSASSAPSSParams.js */ "./node_modules/pkijs/src/RSASSAPSSParams.js");
/* harmony import */ var _PBKDF2Params_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PBKDF2Params.js */ "./node_modules/pkijs/src/PBKDF2Params.js");
/* harmony import */ var _PBES2Params_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PBES2Params.js */ "./node_modules/pkijs/src/PBES2Params.js");










//**************************************************************************************
/**
 * Making MAC key using algorithm described in B.2 of PKCS#12 standard.
 */
function makePKCS12B2Key(cryptoEngine, hashAlgorithm, keyLength, password, salt, iterationCount)
{
	//region Initial variables
	let u;
	let v;
	
	const result = [];
	//endregion
	
	//region Get "u" and "v" values
	switch(hashAlgorithm.toUpperCase())
	{
		case "SHA-1":
			u = 20; // 160
			v = 64; // 512
			break;
		case "SHA-256":
			u = 32; // 256
			v = 64; // 512
			break;
		case "SHA-384":
			u = 48; // 384
			v = 128; // 1024
			break;
		case "SHA-512":
			u = 64; // 512
			v = 128; // 1024
			break;
		default:
			throw new Error("Unsupported hashing algorithm");
	}
	//endregion
	
	//region Main algorithm making key
	//region Transform password to UTF-8 like string
	const passwordViewInitial = new Uint8Array(password);
	
	const passwordTransformed = new ArrayBuffer((password.byteLength * 2) + 2);
	const passwordTransformedView = new Uint8Array(passwordTransformed);
	
	for(let i = 0; i < passwordViewInitial.length; i++)
	{
		passwordTransformedView[i * 2] = 0x00;
		passwordTransformedView[i * 2 + 1] = passwordViewInitial[i];
	}
	
	passwordTransformedView[passwordTransformedView.length - 2] = 0x00;
	passwordTransformedView[passwordTransformedView.length - 1] = 0x00;
	
	password = passwordTransformed.slice(0);
	//endregion
	
	//region Construct a string D (the "diversifier") by concatenating v/8 copies of ID
	const D = new ArrayBuffer(v);
	const dView = new Uint8Array(D);
	
	for(let i = 0; i < D.byteLength; i++)
		dView[i] = 3; // The ID value equal to "3" for MACing (see B.3 of standard)
	//endregion
	
	//region Concatenate copies of the salt together to create a string S of length v * ceil(s / v) bytes (the final copy of the salt may be trunacted to create S)
	const saltLength = salt.byteLength;
	
	const sLen = v * Math.ceil(saltLength / v);
	const S = new ArrayBuffer(sLen);
	const sView = new Uint8Array(S);
	
	const saltView = new Uint8Array(salt);
	
	for(let i = 0; i < sLen; i++)
		sView[i] = saltView[i % saltLength];
	//endregion
	
	//region Concatenate copies of the password together to create a string P of length v * ceil(p / v) bytes (the final copy of the password may be truncated to create P)
	const passwordLength = password.byteLength;
	
	const pLen = v * Math.ceil(passwordLength / v);
	const P = new ArrayBuffer(pLen);
	const pView = new Uint8Array(P);
	
	const passwordView = new Uint8Array(password);
	
	for(let i = 0; i < pLen; i++)
		pView[i] = passwordView[i % passwordLength];
	//endregion
	
	//region Set I=S||P to be the concatenation of S and P
	const sPlusPLength = S.byteLength + P.byteLength;
	
	let I = new ArrayBuffer(sPlusPLength);
	let iView = new Uint8Array(I);
	
	iView.set(sView);
	iView.set(pView, sView.length);
	//endregion
	
	//region Set c=ceil(n / u)
	const c = Math.ceil((keyLength >> 3) / u);
	//endregion
	
	//region Initial variables
	let internalSequence = Promise.resolve(I);
	//endregion
	
	//region For i=1, 2, ..., c, do the following:
	for(let i = 0; i <= c; i++)
	{
		internalSequence = internalSequence.then(_I =>
		{
			//region Create contecanetion of D and I
			const dAndI = new ArrayBuffer(D.byteLength + _I.byteLength);
			const dAndIView = new Uint8Array(dAndI);
			
			dAndIView.set(dView);
			dAndIView.set(iView, dView.length);
			//endregion
			
			return dAndI;
		});
		
		//region Make "iterationCount" rounds of hashing
		for(let j = 0; j < iterationCount; j++)
			internalSequence = internalSequence.then(roundBuffer => cryptoEngine.digest({ name: hashAlgorithm }, new Uint8Array(roundBuffer)));
		//endregion
		
		internalSequence = internalSequence.then(roundBuffer =>
		{
			//region Concatenate copies of Ai to create a string B of length v bits (the final copy of Ai may be truncated to create B)
			const B = new ArrayBuffer(v);
			const bView = new Uint8Array(B);
			
			for(let j = 0; j < B.byteLength; j++)
				bView[j] = roundBuffer[j % roundBuffer.length];
			//endregion
			
			//region Make new I value
			const k = Math.ceil(saltLength / v) + Math.ceil(passwordLength / v);
			const iRound = [];
			
			let sliceStart = 0;
			let sliceLength = v;
			
			for(let j = 0; j < k; j++)
			{
				const chunk = Array.from(new Uint8Array(I.slice(sliceStart, sliceStart + sliceLength)));
				sliceStart += v;
				if((sliceStart + v) > I.byteLength)
					sliceLength = I.byteLength - sliceStart;
				
				let x = 0x1ff;
				
				for(let l = (B.byteLength - 1); l >= 0; l--)
				{
					x >>= 8;
					x += bView[l] + chunk[l];
					chunk[l] = (x & 0xff);
				}
				
				iRound.push(...chunk);
			}
			
			I = new ArrayBuffer(iRound.length);
			iView = new Uint8Array(I);
			
			iView.set(iRound);
			//endregion
			
			result.push(...(new Uint8Array(roundBuffer)));
			
			return I;
		});
	}
	//endregion
	
	//region Initialize final key
	internalSequence = internalSequence.then(() =>
	{
		const resultBuffer = new ArrayBuffer(keyLength >> 3);
		const resultView = new Uint8Array(resultBuffer);
		
		resultView.set((new Uint8Array(result)).slice(0, keyLength >> 3));
		
		return resultBuffer;
	});
	//endregion
	//endregion
	
	return internalSequence;
}
//**************************************************************************************
/**
 * Default cryptographic engine for Web Cryptography API
 */
class CryptoEngine
{
	//**********************************************************************************
	/**
	 * Constructor for CryptoEngine class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Object}
		 * @desc Usually here we are expecting "window.crypto" or an equivalent from custom "crypto engine"
		 */
		this.crypto = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "crypto", {});
		/**
		 * @type {Object}
		 * @desc Usually here we are expecting "window.crypto.subtle" or an equivalent from custom "crypto engine"
		 */
		this.subtle = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subtle", {});
		/**
		 * @type {string}
		 * @desc Name of the "crypto engine"
		 */
		this.name = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "name", "");
		//endregion
	}
	//**********************************************************************************
	/**
	 * Import WebCrypto keys from different formats
	 * @param {string} format
	 * @param {ArrayBuffer|Uint8Array} keyData
	 * @param {Object} algorithm
	 * @param {boolean} extractable
	 * @param {Array} keyUsages
	 * @returns {Promise}
	 */
	importKey(format, keyData, algorithm, extractable, keyUsages)
	{
		//region Initial variables
		let jwk = {};
		//endregion
		
		//region Change "keyData" type if needed
		if(keyData instanceof Uint8Array)
			keyData = keyData.buffer;
		//endregion
		
		switch(format.toLowerCase())
		{
			case "raw":
				return this.subtle.importKey("raw", keyData, algorithm, extractable, keyUsages);
			case "spki":
				{
					const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](keyData);
					if(asn1.offset === (-1))
						return Promise.reject("Incorrect keyData");

					const publicKeyInfo = new _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
					try
					{
						publicKeyInfo.fromSchema(asn1.result);
					}
					catch(ex)
					{
						return Promise.reject("Incorrect keyData");
					}


					// noinspection FallThroughInSwitchStatementJS
					switch(algorithm.name.toUpperCase())
					{
						case "RSA-PSS":
							{
								//region Get information about used hash function
								switch(algorithm.hash.name.toUpperCase())
								{
									case "SHA-1":
										jwk.alg = "PS1";
										break;
									case "SHA-256":
										jwk.alg = "PS256";
										break;
									case "SHA-384":
										jwk.alg = "PS384";
										break;
									case "SHA-512":
										jwk.alg = "PS512";
										break;
									default:
										return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
								}
								//endregion
							}
							// break omitted
						case "RSASSA-PKCS1-V1_5":
							{
								keyUsages = ["verify"]; // Override existing keyUsages value since the key is a public key

								jwk.kty = "RSA";
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;

								if(publicKeyInfo.algorithm.algorithmId !== "1.2.840.113549.1.1.1")
									return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);

								//region Get information about used hash function
								if(("alg" in jwk) === false)
								{
									switch(algorithm.hash.name.toUpperCase())
									{
										case "SHA-1":
											jwk.alg = "RS1";
											break;
										case "SHA-256":
											jwk.alg = "RS256";
											break;
										case "SHA-384":
											jwk.alg = "RS384";
											break;
										case "SHA-512":
											jwk.alg = "RS512";
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
								}
								//endregion

								//region Create RSA Public Key elements
								const publicKeyJSON = publicKeyInfo.toJSON();

								for(const key of Object.keys(publicKeyJSON))
									jwk[key] = publicKeyJSON[key];
								//endregion
							}
							break;
						case "ECDSA":
							keyUsages = ["verify"]; // Override existing keyUsages value since the key is a public key
							// break omitted
						case "ECDH":
							{
								//region Initial variables
								jwk = {
									kty: "EC",
									ext: extractable,
									key_ops: keyUsages
								};
								//endregion

								//region Get information about algorithm
								if(publicKeyInfo.algorithm.algorithmId !== "1.2.840.10045.2.1")
									return Promise.reject(`Incorrect public key algorithm: ${publicKeyInfo.algorithm.algorithmId}`);
								//endregion

								//region Create ECDSA Public Key elements
								const publicKeyJSON = publicKeyInfo.toJSON();

								for(const key of Object.keys(publicKeyJSON))
									jwk[key] = publicKeyJSON[key];
								//endregion
							}
							break;
						case "RSA-OAEP":
							{
								jwk.kty = "RSA";
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;
								
								if(this.name.toLowerCase() === "safari")
									jwk.alg = "RSA-OAEP";
								else
								{
									switch(algorithm.hash.name.toUpperCase())
									{
										case "SHA-1":
											jwk.alg = "RSA-OAEP";
											break;
										case "SHA-256":
											jwk.alg = "RSA-OAEP-256";
											break;
										case "SHA-384":
											jwk.alg = "RSA-OAEP-384";
											break;
										case "SHA-512":
											jwk.alg = "RSA-OAEP-512";
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
								}
								
								//region Create ECDSA Public Key elements
								const publicKeyJSON = publicKeyInfo.toJSON();
								
								for(const key of Object.keys(publicKeyJSON))
									jwk[key] = publicKeyJSON[key];
								//endregion
							}
							break;
						case "RSAES-PKCS1-V1_5":
							{
								jwk.kty = "RSA";
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;
								jwk.alg = "PS1";

								const publicKeyJSON = publicKeyInfo.toJSON();

								for(const key of Object.keys(publicKeyJSON))
									jwk[key] = publicKeyJSON[key];
							}
							break;
						default:
							return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
					}
				}
				break;
			case "pkcs8":
				{
					const privateKeyInfo = new _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]();

					//region Parse "PrivateKeyInfo" object
					const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](keyData);
					if(asn1.offset === (-1))
						return Promise.reject("Incorrect keyData");

					try
					{
						privateKeyInfo.fromSchema(asn1.result);
					}
					catch(ex)
					{
						return Promise.reject("Incorrect keyData");
					}
					
					if(("parsedKey" in privateKeyInfo) === false)
						return Promise.reject("Incorrect keyData");
					//endregion

					// noinspection FallThroughInSwitchStatementJS
					// noinspection FallThroughInSwitchStatementJS
					switch(algorithm.name.toUpperCase())
					{
						case "RSA-PSS":
							{
								//region Get information about used hash function
								switch(algorithm.hash.name.toUpperCase())
								{
									case "SHA-1":
										jwk.alg = "PS1";
										break;
									case "SHA-256":
										jwk.alg = "PS256";
										break;
									case "SHA-384":
										jwk.alg = "PS384";
										break;
									case "SHA-512":
										jwk.alg = "PS512";
										break;
									default:
										return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
								}
								//endregion
							}
							// break omitted
						case "RSASSA-PKCS1-V1_5":
							{
								keyUsages = ["sign"]; // Override existing keyUsages value since the key is a private key

								jwk.kty = "RSA";
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;

								//region Get information about used hash function
								if(privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.113549.1.1.1")
									return Promise.reject(`Incorrect private key algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
								//endregion

								//region Get information about used hash function
								if(("alg" in jwk) === false)
								{
									switch(algorithm.hash.name.toUpperCase())
									{
										case "SHA-1":
											jwk.alg = "RS1";
											break;
										case "SHA-256":
											jwk.alg = "RS256";
											break;
										case "SHA-384":
											jwk.alg = "RS384";
											break;
										case "SHA-512":
											jwk.alg = "RS512";
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
								}
								//endregion

								//region Create RSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();

								for(const key of Object.keys(privateKeyJSON))
									jwk[key] = privateKeyJSON[key];
								//endregion
							}
							break;
						case "ECDSA":
							keyUsages = ["sign"]; // Override existing keyUsages value since the key is a private key
							// break omitted
						case "ECDH":
							{
								//region Initial variables
								jwk = {
									kty: "EC",
									ext: extractable,
									key_ops: keyUsages
								};
								//endregion

								//region Get information about used hash function
								if(privateKeyInfo.privateKeyAlgorithm.algorithmId !== "1.2.840.10045.2.1")
									return Promise.reject(`Incorrect algorithm: ${privateKeyInfo.privateKeyAlgorithm.algorithmId}`);
								//endregion

								//region Create ECDSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();

								for(const key of Object.keys(privateKeyJSON))
									jwk[key] = privateKeyJSON[key];
								//endregion
							}
							break;
						case "RSA-OAEP":
							{
								jwk.kty = "RSA";
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;
								
								//region Get information about used hash function
								if(this.name.toLowerCase() === "safari")
									jwk.alg = "RSA-OAEP";
								else
								{
									switch(algorithm.hash.name.toUpperCase())
									{
										case "SHA-1":
											jwk.alg = "RSA-OAEP";
											break;
										case "SHA-256":
											jwk.alg = "RSA-OAEP-256";
											break;
										case "SHA-384":
											jwk.alg = "RSA-OAEP-384";
											break;
										case "SHA-512":
											jwk.alg = "RSA-OAEP-512";
											break;
										default:
											return Promise.reject(`Incorrect hash algorithm: ${algorithm.hash.name.toUpperCase()}`);
									}
								}
								//endregion
								
								//region Create RSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();
								
								for(const key of Object.keys(privateKeyJSON))
									jwk[key] = privateKeyJSON[key];
								//endregion
							}
							break;
						case "RSAES-PKCS1-V1_5":
							{
								keyUsages = ["decrypt"]; // Override existing keyUsages value since the key is a private key

								jwk.kty = "RSA";
								jwk.ext = extractable;
								jwk.key_ops = keyUsages;
								jwk.alg = "PS1";

								//region Create RSA Private Key elements
								const privateKeyJSON = privateKeyInfo.toJSON();

								for(const key of Object.keys(privateKeyJSON))
									jwk[key] = privateKeyJSON[key];
								//endregion
							}
							break;
						default:
							return Promise.reject(`Incorrect algorithm name: ${algorithm.name.toUpperCase()}`);
					}
				}
				break;
			case "jwk":
				jwk = keyData;
				break;
			default:
				return Promise.reject(`Incorrect format: ${format}`);
		}
		
		//region Special case for Safari browser (since its acting not as WebCrypto standard describes)
		if(this.name.toLowerCase() === "safari")
		{
			// Try to use both ways - import using ArrayBuffer and pure JWK (for Safari Technology Preview)
			return Promise.resolve().then(() => this.subtle.importKey("jwk", Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(JSON.stringify(jwk)), algorithm, extractable, keyUsages))
				.then(result => result, () => this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages));
		}
		//endregion
		
		return this.subtle.importKey("jwk", jwk, algorithm, extractable, keyUsages);
	}
	//**********************************************************************************
	/**
	 * Export WebCrypto keys to different formats
	 * @param {string} format
	 * @param {Object} key
	 * @returns {Promise}
	 */
	exportKey(format, key)
	{
		let sequence = this.subtle.exportKey("jwk", key);
		
		//region Currently Safari returns ArrayBuffer as JWK thus we need an additional transformation
		if(this.name.toLowerCase() === "safari")
		{
			sequence = sequence.then(result =>
			{
				// Some additional checks for Safari Technology Preview
				if(result instanceof ArrayBuffer)
					return JSON.parse(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(result));
				
				return result;
			});
		}
		//endregion
		
		switch(format.toLowerCase())
		{
			case "raw":
				return this.subtle.exportKey("raw", key);
			case "spki":
				sequence = sequence.then(result =>
				{
					const publicKeyInfo = new _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]();

					try
					{
						publicKeyInfo.fromJSON(result);
					}
					catch(ex)
					{
						return Promise.reject("Incorrect key data");
					}

					return publicKeyInfo.toSchema().toBER(false);
				});
				break;
			case "pkcs8":
				sequence = sequence.then(result =>
				{
					const privateKeyInfo = new _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]();

					try
					{
						privateKeyInfo.fromJSON(result);
					}
					catch(ex)
					{
						return Promise.reject("Incorrect key data");
					}

					return privateKeyInfo.toSchema().toBER(false);
				});
				break;
			case "jwk":
				break;
			default:
				return Promise.reject(`Incorrect format: ${format}`);
		}

		return sequence;
	}
	//**********************************************************************************
	/**
	 * Convert WebCrypto keys between different export formats
	 * @param {string} inputFormat
	 * @param {string} outputFormat
	 * @param {ArrayBuffer|Object} keyData
	 * @param {Object} algorithm
	 * @param {boolean} extractable
	 * @param {Array} keyUsages
	 * @returns {Promise}
	 */
	convert(inputFormat, outputFormat, keyData, algorithm, extractable, keyUsages)
	{
		switch(inputFormat.toLowerCase())
		{
			case "raw":
				switch(outputFormat.toLowerCase())
				{
					case "raw":
						return Promise.resolve(keyData);
					case "spki":
						return Promise.resolve()
							.then(() => this.importKey("raw", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("spki", result));
					case "pkcs8":
						return Promise.resolve()
							.then(() => this.importKey("raw", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("pkcs8", result));
					case "jwk":
						return Promise.resolve()
							.then(() => this.importKey("raw", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("jwk", result));
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			case "spki":
				switch(outputFormat.toLowerCase())
				{
					case "raw":
						return Promise.resolve()
							.then(() => this.importKey("spki", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("raw", result));
					case "spki":
						return Promise.resolve(keyData);
					case "pkcs8":
						return Promise.reject("Impossible to convert between SPKI/PKCS8");
					case "jwk":
						return Promise.resolve()
							.then(() => this.importKey("spki", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("jwk", result));
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			case "pkcs8":
				switch(outputFormat.toLowerCase())
				{
					case "raw":
						return Promise.resolve()
							.then(() => this.importKey("pkcs8", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("raw", result));
					case "spki":
						return Promise.reject("Impossible to convert between SPKI/PKCS8");
					case "pkcs8":
						return Promise.resolve(keyData);
					case "jwk":
						return Promise.resolve()
							.then(() => this.importKey("pkcs8", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("jwk", result));
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			case "jwk":
				switch(outputFormat.toLowerCase())
				{
					case "raw":
						return Promise.resolve()
							.then(() => this.importKey("jwk", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("raw", result));
					case "spki":
						return Promise.resolve()
							.then(() => this.importKey("jwk", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("spki", result));
					case "pkcs8":
						return Promise.resolve()
							.then(() => this.importKey("jwk", keyData, algorithm, extractable, keyUsages))
							.then(result => this.exportKey("pkcs8", result));
					case "jwk":
						return Promise.resolve(keyData);
					default:
						return Promise.reject(`Incorrect outputFormat: ${outputFormat}`);
				}
			default:
				return Promise.reject(`Incorrect inputFormat: ${inputFormat}`);
		}
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "encrypt"
	 * @param args
	 * @returns {Promise}
	 */
	encrypt(...args)
	{
		return this.subtle.encrypt(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "decrypt"
	 * @param args
	 * @returns {Promise}
	 */
	decrypt(...args)
	{
		return this.subtle.decrypt(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "sign"
	 * @param args
	 * @returns {Promise}
	 */
	sign(...args)
	{
		return this.subtle.sign(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "verify"
	 * @param args
	 * @returns {Promise}
	 */
	verify(...args)
	{
		return this.subtle.verify(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "digest"
	 * @param args
	 * @returns {Promise}
	 */
	digest(...args)
	{
		return this.subtle.digest(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "generateKey"
	 * @param args
	 * @returns {Promise}
	 */
	generateKey(...args)
	{
		return this.subtle.generateKey(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "deriveKey"
	 * @param args
	 * @returns {Promise}
	 */
	deriveKey(...args)
	{
		return this.subtle.deriveKey(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "deriveBits"
	 * @param args
	 * @returns {Promise}
	 */
	deriveBits(...args)
	{
		return this.subtle.deriveBits(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "wrapKey"
	 * @param args
	 * @returns {Promise}
	 */
	wrapKey(...args)
	{
		return this.subtle.wrapKey(...args);
	}
	//**********************************************************************************
	/**
	 * Wrapper for standard function "unwrapKey"
	 * @param args
	 * @returns {Promise}
	 */
	unwrapKey(...args)
	{
		return this.subtle.unwrapKey(...args);
	}
	//**********************************************************************************
	/**
	 * Initialize input Uint8Array by random values (with help from current "crypto engine")
	 * @param {!Uint8Array} view
	 * @returns {*}
	 */
	getRandomValues(view)
	{
		if(("getRandomValues" in this.crypto) === false)
			throw new Error("No support for getRandomValues");
		
		return this.crypto.getRandomValues(view);
	}
	//**********************************************************************************
	/**
	 * Get WebCrypto algorithm by wel-known OID
	 * @param {string} oid well-known OID to search for
	 * @returns {Object}
	 */
	getAlgorithmByOID(oid)
	{
		switch(oid)
		{
			case "1.2.840.113549.1.1.1":
				return {
					name: "RSAES-PKCS1-v1_5"
				};
			case "1.2.840.113549.1.1.5":
				return {
					name: "RSASSA-PKCS1-v1_5",
					hash: {
						name: "SHA-1"
					}
				};
			case "1.2.840.113549.1.1.11":
				return {
					name: "RSASSA-PKCS1-v1_5",
					hash: {
						name: "SHA-256"
					}
				};
			case "1.2.840.113549.1.1.12":
				return {
					name: "RSASSA-PKCS1-v1_5",
					hash: {
						name: "SHA-384"
					}
				};
			case "1.2.840.113549.1.1.13":
				return {
					name: "RSASSA-PKCS1-v1_5",
					hash: {
						name: "SHA-512"
					}
				};
			case "1.2.840.113549.1.1.10":
				return {
					name: "RSA-PSS"
				};
			case "1.2.840.113549.1.1.7":
				return {
					name: "RSA-OAEP"
				};
			case "1.2.840.10045.2.1":
			case "1.2.840.10045.4.1":
				return {
					name: "ECDSA",
					hash: {
						name: "SHA-1"
					}
				};
			case "1.2.840.10045.4.3.2":
				return {
					name: "ECDSA",
					hash: {
						name: "SHA-256"
					}
				};
			case "1.2.840.10045.4.3.3":
				return {
					name: "ECDSA",
					hash: {
						name: "SHA-384"
					}
				};
			case "1.2.840.10045.4.3.4":
				return {
					name: "ECDSA",
					hash: {
						name: "SHA-512"
					}
				};
			case "1.3.133.16.840.63.0.2":
				return {
					name: "ECDH",
					kdf: "SHA-1"
				};
			case "1.3.132.1.11.1":
				return {
					name: "ECDH",
					kdf: "SHA-256"
				};
			case "1.3.132.1.11.2":
				return {
					name: "ECDH",
					kdf: "SHA-384"
				};
			case "1.3.132.1.11.3":
				return {
					name: "ECDH",
					kdf: "SHA-512"
				};
			case "2.16.840.1.101.3.4.1.2":
				return {
					name: "AES-CBC",
					length: 128
				};
			case "2.16.840.1.101.3.4.1.22":
				return {
					name: "AES-CBC",
					length: 192
				};
			case "2.16.840.1.101.3.4.1.42":
				return {
					name: "AES-CBC",
					length: 256
				};
			case "2.16.840.1.101.3.4.1.6":
				return {
					name: "AES-GCM",
					length: 128
				};
			case "2.16.840.1.101.3.4.1.26":
				return {
					name: "AES-GCM",
					length: 192
				};
			case "2.16.840.1.101.3.4.1.46":
				return {
					name: "AES-GCM",
					length: 256
				};
			case "2.16.840.1.101.3.4.1.4":
				return {
					name: "AES-CFB",
					length: 128
				};
			case "2.16.840.1.101.3.4.1.24":
				return {
					name: "AES-CFB",
					length: 192
				};
			case "2.16.840.1.101.3.4.1.44":
				return {
					name: "AES-CFB",
					length: 256
				};
			case "2.16.840.1.101.3.4.1.5":
				return {
					name: "AES-KW",
					length: 128
				};
			case "2.16.840.1.101.3.4.1.25":
				return {
					name: "AES-KW",
					length: 192
				};
			case "2.16.840.1.101.3.4.1.45":
				return {
					name: "AES-KW",
					length: 256
				};
			case "1.2.840.113549.2.7":
				return {
					name: "HMAC",
					hash: {
						name: "SHA-1"
					}
				};
			case "1.2.840.113549.2.9":
				return {
					name: "HMAC",
					hash: {
						name: "SHA-256"
					}
				};
			case "1.2.840.113549.2.10":
				return {
					name: "HMAC",
					hash: {
						name: "SHA-384"
					}
				};
			case "1.2.840.113549.2.11":
				return {
					name: "HMAC",
					hash: {
						name: "SHA-512"
					}
				};
			case "1.2.840.113549.1.9.16.3.5":
				return {
					name: "DH"
				};
			case "1.3.14.3.2.26":
				return {
					name: "SHA-1"
				};
			case "2.16.840.1.101.3.4.2.1":
				return {
					name: "SHA-256"
				};
			case "2.16.840.1.101.3.4.2.2":
				return {
					name: "SHA-384"
				};
			case "2.16.840.1.101.3.4.2.3":
				return {
					name: "SHA-512"
				};
			case "1.2.840.113549.1.5.12":
				return {
					name: "PBKDF2"
				};
			//region Special case - OIDs for ECC curves
			case "1.2.840.10045.3.1.7":
				return {
					name: "P-256"
				};
			case "1.3.132.0.34":
				return {
					name: "P-384"
				};
			case "1.3.132.0.35":
				return {
					name: "P-521"
				};
			//endregion
			default:
		}
		
		return {};
	}
	//**********************************************************************************
	/**
	 * Get OID for each specific algorithm
	 * @param {Object} algorithm
	 * @returns {string}
	 */
	getOIDByAlgorithm(algorithm)
	{
		let result = "";
		
		switch(algorithm.name.toUpperCase())
		{
			case "RSAES-PKCS1-V1_5":
				result = "1.2.840.113549.1.1.1";
				break;
			case "RSASSA-PKCS1-V1_5":
				switch(algorithm.hash.name.toUpperCase())
				{
					case "SHA-1":
						result = "1.2.840.113549.1.1.5";
						break;
					case "SHA-256":
						result = "1.2.840.113549.1.1.11";
						break;
					case "SHA-384":
						result = "1.2.840.113549.1.1.12";
						break;
					case "SHA-512":
						result = "1.2.840.113549.1.1.13";
						break;
					default:
				}
				break;
			case "RSA-PSS":
				result = "1.2.840.113549.1.1.10";
				break;
			case "RSA-OAEP":
				result = "1.2.840.113549.1.1.7";
				break;
			case "ECDSA":
				switch(algorithm.hash.name.toUpperCase())
				{
					case "SHA-1":
						result = "1.2.840.10045.4.1";
						break;
					case "SHA-256":
						result = "1.2.840.10045.4.3.2";
						break;
					case "SHA-384":
						result = "1.2.840.10045.4.3.3";
						break;
					case "SHA-512":
						result = "1.2.840.10045.4.3.4";
						break;
					default:
				}
				break;
			case "ECDH":
				switch(algorithm.kdf.toUpperCase()) // Non-standard addition - hash algorithm of KDF function
				{
					case "SHA-1":
						result = "1.3.133.16.840.63.0.2"; // dhSinglePass-stdDH-sha1kdf-scheme
						break;
					case "SHA-256":
						result = "1.3.132.1.11.1"; // dhSinglePass-stdDH-sha256kdf-scheme
						break;
					case "SHA-384":
						result = "1.3.132.1.11.2"; // dhSinglePass-stdDH-sha384kdf-scheme
						break;
					case "SHA-512":
						result = "1.3.132.1.11.3"; // dhSinglePass-stdDH-sha512kdf-scheme
						break;
					default:
				}
				break;
			case "AES-CTR":
				break;
			case "AES-CBC":
				switch(algorithm.length)
				{
					case 128:
						result = "2.16.840.1.101.3.4.1.2";
						break;
					case 192:
						result = "2.16.840.1.101.3.4.1.22";
						break;
					case 256:
						result = "2.16.840.1.101.3.4.1.42";
						break;
					default:
				}
				break;
			case "AES-CMAC":
				break;
			case "AES-GCM":
				switch(algorithm.length)
				{
					case 128:
						result = "2.16.840.1.101.3.4.1.6";
						break;
					case 192:
						result = "2.16.840.1.101.3.4.1.26";
						break;
					case 256:
						result = "2.16.840.1.101.3.4.1.46";
						break;
					default:
				}
				break;
			case "AES-CFB":
				switch(algorithm.length)
				{
					case 128:
						result = "2.16.840.1.101.3.4.1.4";
						break;
					case 192:
						result = "2.16.840.1.101.3.4.1.24";
						break;
					case 256:
						result = "2.16.840.1.101.3.4.1.44";
						break;
					default:
				}
				break;
			case "AES-KW":
				switch(algorithm.length)
				{
					case 128:
						result = "2.16.840.1.101.3.4.1.5";
						break;
					case 192:
						result = "2.16.840.1.101.3.4.1.25";
						break;
					case 256:
						result = "2.16.840.1.101.3.4.1.45";
						break;
					default:
				}
				break;
			case "HMAC":
				switch(algorithm.hash.name.toUpperCase())
				{
					case "SHA-1":
						result = "1.2.840.113549.2.7";
						break;
					case "SHA-256":
						result = "1.2.840.113549.2.9";
						break;
					case "SHA-384":
						result = "1.2.840.113549.2.10";
						break;
					case "SHA-512":
						result = "1.2.840.113549.2.11";
						break;
					default:
				}
				break;
			case "DH":
				result = "1.2.840.113549.1.9.16.3.5";
				break;
			case "SHA-1":
				result = "1.3.14.3.2.26";
				break;
			case "SHA-256":
				result = "2.16.840.1.101.3.4.2.1";
				break;
			case "SHA-384":
				result = "2.16.840.1.101.3.4.2.2";
				break;
			case "SHA-512":
				result = "2.16.840.1.101.3.4.2.3";
				break;
			case "CONCAT":
				break;
			case "HKDF":
				break;
			case "PBKDF2":
				result = "1.2.840.113549.1.5.12";
				break;
			//region Special case - OIDs for ECC curves
			case "P-256":
				result = "1.2.840.10045.3.1.7";
				break;
			case "P-384":
				result = "1.3.132.0.34";
				break;
			case "P-521":
				result = "1.3.132.0.35";
				break;
			//endregion
			default:
		}
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Get default algorithm parameters for each kind of operation
	 * @param {string} algorithmName Algorithm name to get common parameters for
	 * @param {string} operation Kind of operation: "sign", "encrypt", "generatekey", "importkey", "exportkey", "verify"
	 * @returns {*}
	 */
	getAlgorithmParameters(algorithmName, operation)
	{
		let result = {
			algorithm: {},
			usages: []
		};
		
		switch(algorithmName.toUpperCase())
		{
			case "RSAES-PKCS1-V1_5":
			case "RSASSA-PKCS1-V1_5":
				switch(operation.toLowerCase())
				{
					case "generatekey":
						result = {
							algorithm: {
								name: "RSASSA-PKCS1-v1_5",
								modulusLength: 2048,
								publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
								hash: {
									name: "SHA-256"
								}
							},
							usages: ["sign", "verify"]
						};
						break;
					case "verify":
					case "sign":
					case "importkey":
						result = {
							algorithm: {
								name: "RSASSA-PKCS1-v1_5",
								hash: {
									name: "SHA-256"
								}
							},
							usages: ["verify"] // For importKey("pkcs8") usage must be "sign" only
						};
						break;
					case "exportkey":
					default:
						return {
							algorithm: {
								name: "RSASSA-PKCS1-v1_5"
							},
							usages: []
						};
				}
				break;
			case "RSA-PSS":
				switch(operation.toLowerCase())
				{
					case "sign":
					case "verify":
						result = {
							algorithm: {
								name: "RSA-PSS",
								hash: {
									name: "SHA-1"
								},
								saltLength: 20
							},
							usages: ["sign", "verify"]
						};
						break;
					case "generatekey":
						result = {
							algorithm: {
								name: "RSA-PSS",
								modulusLength: 2048,
								publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
								hash: {
									name: "SHA-1"
								}
							},
							usages: ["sign", "verify"]
						};
						break;
					case "importkey":
						result = {
							algorithm: {
								name: "RSA-PSS",
								hash: {
									name: "SHA-1"
								}
							},
							usages: ["verify"] // For importKey("pkcs8") usage must be "sign" only
						};
						break;
					case "exportkey":
					default:
						return {
							algorithm: {
								name: "RSA-PSS"
							},
							usages: []
						};
				}
				break;
			case "RSA-OAEP":
				switch(operation.toLowerCase())
				{
					case "encrypt":
					case "decrypt":
						result = {
							algorithm: {
								name: "RSA-OAEP"
							},
							usages: ["encrypt", "decrypt"]
						};
						break;
					case "generatekey":
						result = {
							algorithm: {
								name: "RSA-OAEP",
								modulusLength: 2048,
								publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
								hash: {
									name: "SHA-256"
								}
							},
							usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
						};
						break;
					case "importkey":
						result = {
							algorithm: {
								name: "RSA-OAEP",
								hash: {
									name: "SHA-256"
								}
							},
							usages: ["encrypt"] // encrypt for "spki" and decrypt for "pkcs8"
						};
						break;
					case "exportkey":
					default:
						return {
							algorithm: {
								name: "RSA-OAEP"
							},
							usages: []
						};
				}
				break;
			case "ECDSA":
				switch(operation.toLowerCase())
				{
					case "generatekey":
						result = {
							algorithm: {
								name: "ECDSA",
								namedCurve: "P-256"
							},
							usages: ["sign", "verify"]
						};
						break;
					case "importkey":
						result = {
							algorithm: {
								name: "ECDSA",
								namedCurve: "P-256"
							},
							usages: ["verify"] // "sign" for "pkcs8"
						};
						break;
					case "verify":
					case "sign":
						result = {
							algorithm: {
								name: "ECDSA",
								hash: {
									name: "SHA-256"
								}
							},
							usages: ["sign"]
						};
						break;
					default:
						return {
							algorithm: {
								name: "ECDSA"
							},
							usages: []
						};
				}
				break;
			case "ECDH":
				switch(operation.toLowerCase())
				{
					case "exportkey":
					case "importkey":
					case "generatekey":
						result = {
							algorithm: {
								name: "ECDH",
								namedCurve: "P-256"
							},
							usages: ["deriveKey", "deriveBits"]
						};
						break;
					case "derivekey":
					case "derivebits":
						result = {
							algorithm: {
								name: "ECDH",
								namedCurve: "P-256",
								public: [] // Must be a "publicKey"
							},
							usages: ["encrypt", "decrypt"]
						};
						break;
					default:
						return {
							algorithm: {
								name: "ECDH"
							},
							usages: []
						};
				}
				break;
			case "AES-CTR":
				switch(operation.toLowerCase())
				{
					case "importkey":
					case "exportkey":
					case "generatekey":
						result = {
							algorithm: {
								name: "AES-CTR",
								length: 256
							},
							usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
						};
						break;
					case "decrypt":
					case "encrypt":
						result = {
							algorithm: {
								name: "AES-CTR",
								counter: new Uint8Array(16),
								length: 10
							},
							usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
						};
						break;
					default:
						return {
							algorithm: {
								name: "AES-CTR"
							},
							usages: []
						};
				}
				break;
			case "AES-CBC":
				switch(operation.toLowerCase())
				{
					case "importkey":
					case "exportkey":
					case "generatekey":
						result = {
							algorithm: {
								name: "AES-CBC",
								length: 256
							},
							usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
						};
						break;
					case "decrypt":
					case "encrypt":
						result = {
							algorithm: {
								name: "AES-CBC",
								iv: this.getRandomValues(new Uint8Array(16)) // For "decrypt" the value should be replaced with value got on "encrypt" step
							},
							usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
						};
						break;
					default:
						return {
							algorithm: {
								name: "AES-CBC"
							},
							usages: []
						};
				}
				break;
			case "AES-GCM":
				switch(operation.toLowerCase())
				{
					case "importkey":
					case "exportkey":
					case "generatekey":
						result = {
							algorithm: {
								name: "AES-GCM",
								length: 256
							},
							usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
						};
						break;
					case "decrypt":
					case "encrypt":
						result = {
							algorithm: {
								name: "AES-GCM",
								iv: this.getRandomValues(new Uint8Array(16)) // For "decrypt" the value should be replaced with value got on "encrypt" step
							},
							usages: ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
						};
						break;
					default:
						return {
							algorithm: {
								name: "AES-GCM"
							},
							usages: []
						};
				}
				break;
			case "AES-KW":
				switch(operation.toLowerCase())
				{
					case "importkey":
					case "exportkey":
					case "generatekey":
					case "wrapkey":
					case "unwrapkey":
						result = {
							algorithm: {
								name: "AES-KW",
								length: 256
							},
							usages: ["wrapKey", "unwrapKey"]
						};
						break;
					default:
						return {
							algorithm: {
								name: "AES-KW"
							},
							usages: []
						};
				}
				break;
			case "HMAC":
				switch(operation.toLowerCase())
				{
					case "sign":
					case "verify":
						result = {
							algorithm: {
								name: "HMAC"
							},
							usages: ["sign", "verify"]
						};
						break;
					case "importkey":
					case "exportkey":
					case "generatekey":
						result = {
							algorithm: {
								name: "HMAC",
								length: 32,
								hash: {
									name: "SHA-256"
								}
							},
							usages: ["sign", "verify"]
						};
						break;
					default:
						return {
							algorithm: {
								name: "HMAC"
							},
							usages: []
						};
				}
				break;
			case "HKDF":
				switch(operation.toLowerCase())
				{
					case "derivekey":
						result = {
							algorithm: {
								name: "HKDF",
								hash: "SHA-256",
								salt: new Uint8Array([]),
								info: new Uint8Array([])
							},
							usages: ["encrypt", "decrypt"]
						};
						break;
					default:
						return {
							algorithm: {
								name: "HKDF"
							},
							usages: []
						};
				}
				break;
			case "PBKDF2":
				switch(operation.toLowerCase())
				{
					case "derivekey":
						result = {
							algorithm: {
								name: "PBKDF2",
								hash: { name: "SHA-256" },
								salt: new Uint8Array([]),
								iterations: 10000
							},
							usages: ["encrypt", "decrypt"]
						};
						break;
					default:
						return {
							algorithm: {
								name: "PBKDF2"
							},
							usages: []
						};
				}
				break;
			default:
		}
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Getting hash algorithm by signature algorithm
	 * @param {AlgorithmIdentifier} signatureAlgorithm Signature algorithm
	 * @returns {string}
	 */
	getHashAlgorithm(signatureAlgorithm)
	{
		let result = "";
		
		switch(signatureAlgorithm.algorithmId)
		{
			case "1.2.840.10045.4.1": // ecdsa-with-SHA1
			case "1.2.840.113549.1.1.5":
				result = "SHA-1";
				break;
			case "1.2.840.10045.4.3.2": // ecdsa-with-SHA256
			case "1.2.840.113549.1.1.11":
				result = "SHA-256";
				break;
			case "1.2.840.10045.4.3.3": // ecdsa-with-SHA384
			case "1.2.840.113549.1.1.12":
				result = "SHA-384";
				break;
			case "1.2.840.10045.4.3.4": // ecdsa-with-SHA512
			case "1.2.840.113549.1.1.13":
				result = "SHA-512";
				break;
			case "1.2.840.113549.1.1.10": // RSA-PSS
				{
					try
					{
						const params = new _RSASSAPSSParams_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: signatureAlgorithm.algorithmParams });
						if("hashAlgorithm" in params)
						{
							const algorithm = this.getAlgorithmByOID(params.hashAlgorithm.algorithmId);
							if(("name" in algorithm) === false)
								return "";
							
							result = algorithm.name;
						}
						else
							result = "SHA-1";
					}
					catch(ex)
					{
					}
				}
				break;
			default:
		}
		
		return result;
	}
	//**********************************************************************************
	/**
	 * Specialized function encrypting "EncryptedContentInfo" object using parameters
	 * @param {Object} parameters
	 * @returns {Promise}
	 */
	encryptEncryptedContentInfo(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject("Parameters must have type \"Object\"");
		
		if(("password" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"password\"");
		
		if(("contentEncryptionAlgorithm" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"contentEncryptionAlgorithm\"");
		
		if(("hmacHashAlgorithm" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"hmacHashAlgorithm\"");
		
		if(("iterationCount" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"iterationCount\"");
		
		if(("contentToEncrypt" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"contentToEncrypt\"");
		
		if(("contentType" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"contentType\"");

		const contentEncryptionOID = this.getOIDByAlgorithm(parameters.contentEncryptionAlgorithm);
		if(contentEncryptionOID === "")
			return Promise.reject("Wrong \"contentEncryptionAlgorithm\" value");
		
		const pbkdf2OID = this.getOIDByAlgorithm({
			name: "PBKDF2"
		});
		if(pbkdf2OID === "")
			return Promise.reject("Can not find OID for PBKDF2");
		
		const hmacOID = this.getOIDByAlgorithm({
			name: "HMAC",
			hash: {
				name: parameters.hmacHashAlgorithm
			}
		});
		if(hmacOID === "")
			return Promise.reject(`Incorrect value for "hmacHashAlgorithm": ${parameters.hmacHashAlgorithm}`);
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		
		const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long
		const ivView = new Uint8Array(ivBuffer);
		this.getRandomValues(ivView);
		
		const saltBuffer = new ArrayBuffer(64);
		const saltView = new Uint8Array(saltBuffer);
		this.getRandomValues(saltView);
		
		const contentView = new Uint8Array(parameters.contentToEncrypt);
		
		const pbkdf2Params = new _PBKDF2Params_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
			salt: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: saltBuffer }),
			iterationCount: parameters.iterationCount,
			prf: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
				algorithmId: hmacOID,
				algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
			})
		});
		//endregion
		
		//region Derive PBKDF2 key from "password" buffer
		sequence = sequence.then(() =>
		{
			const passwordView = new Uint8Array(parameters.password);
			
			return this.importKey("raw",
				passwordView,
				"PBKDF2",
				false,
				["deriveKey"]);
		}, error =>
			Promise.reject(error)
		);
		//endregion
		
		//region Derive key for "contentEncryptionAlgorithm"
		sequence = sequence.then(result =>
			this.deriveKey({
				name: "PBKDF2",
				hash: {
					name: parameters.hmacHashAlgorithm
				},
				salt: saltView,
				iterations: parameters.iterationCount
			},
			result,
			parameters.contentEncryptionAlgorithm,
			false,
			["encrypt"]),
		error =>
			Promise.reject(error)
		);
		//endregion
		
		//region Encrypt content
		sequence = sequence.then(result =>
			this.encrypt({
				name: parameters.contentEncryptionAlgorithm.name,
				iv: ivView
			},
			result,
			contentView),
		error =>
			Promise.reject(error)
		);
		//endregion
		
		//region Store all parameters in EncryptedData object
		sequence = sequence.then(result =>
		{
			const pbes2Parameters = new _PBES2Params_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
				keyDerivationFunc: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
					algorithmId: pbkdf2OID,
					algorithmParams: pbkdf2Params.toSchema()
				}),
				encryptionScheme: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
					algorithmId: contentEncryptionOID,
					algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: ivBuffer })
				})
			});
			
			return new _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
				contentType: parameters.contentType,
				contentEncryptionAlgorithm: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
					algorithmId: "1.2.840.113549.1.5.13", // pkcs5PBES2
					algorithmParams: pbes2Parameters.toSchema()
				}),
				encryptedContent: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: result })
			});
		}, error =>
			Promise.reject(error)
		);
		//endregion

		return sequence;
	}
	//**********************************************************************************
	/**
	 * Decrypt data stored in "EncryptedContentInfo" object using parameters
	 * @param parameters
	 * @return {Promise}
	 */
	decryptEncryptedContentInfo(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject("Parameters must have type \"Object\"");
		
		if(("password" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"password\"");
		
		if(("encryptedContentInfo" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"encryptedContentInfo\"");

		if(parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId !== "1.2.840.113549.1.5.13") // pkcs5PBES2
			return Promise.reject(`Unknown "contentEncryptionAlgorithm": ${parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		
		let pbes2Parameters;
		
		try
		{
			pbes2Parameters = new _PBES2Params_js__WEBPACK_IMPORTED_MODULE_9__["default"]({ schema: parameters.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams });
		}
		catch(ex)
		{
			return Promise.reject("Incorrectly encoded \"pbes2Parameters\"");
		}
		
		let pbkdf2Params;
		
		try
		{
			pbkdf2Params = new _PBKDF2Params_js__WEBPACK_IMPORTED_MODULE_8__["default"]({ schema: pbes2Parameters.keyDerivationFunc.algorithmParams });
		}
		catch(ex)
		{
			return Promise.reject("Incorrectly encoded \"pbkdf2Params\"");
		}
		
		const contentEncryptionAlgorithm = this.getAlgorithmByOID(pbes2Parameters.encryptionScheme.algorithmId);
		if(("name" in contentEncryptionAlgorithm) === false)
			return Promise.reject(`Incorrect OID for "contentEncryptionAlgorithm": ${pbes2Parameters.encryptionScheme.algorithmId}`);
		
		const ivBuffer = pbes2Parameters.encryptionScheme.algorithmParams.valueBlock.valueHex;
		const ivView = new Uint8Array(ivBuffer);
		
		const saltBuffer = pbkdf2Params.salt.valueBlock.valueHex;
		const saltView = new Uint8Array(saltBuffer);
		
		const iterationCount = pbkdf2Params.iterationCount;
		
		let hmacHashAlgorithm = "SHA-1";
		
		if("prf" in pbkdf2Params)
		{
			const algorithm = this.getAlgorithmByOID(pbkdf2Params.prf.algorithmId);
			if(("name" in algorithm) === false)
				return Promise.reject("Incorrect OID for HMAC hash algorithm");
			
			hmacHashAlgorithm = algorithm.hash.name;
		}
		//endregion
		
		//region Derive PBKDF2 key from "password" buffer
		sequence = sequence.then(() =>
			this.importKey("raw",
				parameters.password,
				"PBKDF2",
				false,
				["deriveKey"]),
		error =>
			Promise.reject(error)
		);
		//endregion
		
		//region Derive key for "contentEncryptionAlgorithm"
		sequence = sequence.then(result =>
			this.deriveKey({
				name: "PBKDF2",
				hash: {
					name: hmacHashAlgorithm
				},
				salt: saltView,
				iterations: iterationCount
			},
			result,
			contentEncryptionAlgorithm,
			false,
			["decrypt"]),
		error =>
			Promise.reject(error)
		);
		//endregion
		
		//region Decrypt internal content using derived key
		sequence = sequence.then(result =>
		{
			//region Create correct data block for decryption
			let dataBuffer = new ArrayBuffer(0);
			
			if(parameters.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false)
				dataBuffer = parameters.encryptedContentInfo.encryptedContent.valueBlock.valueHex;
			else
			{
				for(const content of parameters.encryptedContentInfo.encryptedContent.valueBlock.value)
					dataBuffer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(dataBuffer, content.valueBlock.valueHex);
			}
			//endregion
			
			return this.decrypt({
				name: contentEncryptionAlgorithm.name,
				iv: ivView
			},
			result,
			dataBuffer);
		}, error =>
			Promise.reject(error)
		);
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Stamping (signing) data using algorithm simular to HMAC
	 * @param {Object} parameters
	 * @return {Promise.<T>|Promise}
	 */
	stampDataWithPassword(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject("Parameters must have type \"Object\"");
		
		if(("password" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"password\"");
		
		if(("hashAlgorithm" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
		
		if(("salt" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"iterationCount\"");
		
		if(("iterationCount" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"salt\"");
		
		if(("contentToStamp" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"contentToStamp\"");
		//endregion
		
		//region Choose correct length for HMAC key
		let length;
		
		switch(parameters.hashAlgorithm.toLowerCase())
		{
			case "sha-1":
				length = 160;
				break;
			case "sha-256":
				length = 256;
				break;
			case "sha-384":
				length = 384;
				break;
			case "sha-512":
				length = 512;
				break;
			default:
				return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
		}
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		
		const hmacAlgorithm = {
			name: "HMAC",
			length,
			hash: {
				name: parameters.hashAlgorithm
			}
		};
		//endregion

		//region Create PKCS#12 key for integrity checking
		sequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));
		//endregion
		
		//region Import HMAC key
		// noinspection JSCheckFunctionSignatures
		sequence = sequence.then(
			result =>
				this.importKey("raw",
					new Uint8Array(result),
					hmacAlgorithm,
					false,
					["sign"])
		);
		//endregion
		
		//region Make signed HMAC value
		sequence = sequence.then(
			result =>
				this.sign(hmacAlgorithm, result, new Uint8Array(parameters.contentToStamp)),
			error => Promise.reject(error)
		);
		//endregion

		return sequence;
	}
	//**********************************************************************************
	verifyDataStampedWithPassword(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject("Parameters must have type \"Object\"");
		
		if(("password" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"password\"");
		
		if(("hashAlgorithm" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
		
		if(("salt" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"iterationCount\"");
		
		if(("iterationCount" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"salt\"");
		
		if(("contentToVerify" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"contentToVerify\"");
		
		if(("signatureToVerify" in parameters) === false)
			return Promise.reject("Absent mandatory parameter \"signatureToVerify\"");
		//endregion
		
		//region Choose correct length for HMAC key
		let length;
		
		switch(parameters.hashAlgorithm.toLowerCase())
		{
			case "sha-1":
				length = 160;
				break;
			case "sha-256":
				length = 256;
				break;
			case "sha-384":
				length = 384;
				break;
			case "sha-512":
				length = 512;
				break;
			default:
				return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${parameters.hashAlgorithm}`);
		}
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		
		const hmacAlgorithm = {
			name: "HMAC",
			length,
			hash: {
				name: parameters.hashAlgorithm
			}
		};
		//endregion
		
		//region Create PKCS#12 key for integrity checking
		sequence = sequence.then(() => makePKCS12B2Key(this, parameters.hashAlgorithm, length, parameters.password, parameters.salt, parameters.iterationCount));
		//endregion
		
		//region Import HMAC key
		// noinspection JSCheckFunctionSignatures
		sequence = sequence.then(result =>
			this.importKey("raw",
				new Uint8Array(result),
				hmacAlgorithm,
				false,
				["verify"])
		);
		//endregion
		
		//region Make signed HMAC value
		sequence = sequence.then(
			result =>
				this.verify(hmacAlgorithm, result, new Uint8Array(parameters.signatureToVerify), new Uint8Array(parameters.contentToVerify)),
			error => Promise.reject(error)
		);
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Get signature parameters by analyzing private key algorithm
	 * @param {Object} privateKey The private key user would like to use
	 * @param {string} [hashAlgorithm="SHA-1"] Hash algorithm user would like to use
	 * @return {Promise.<T>|Promise}
	 */
	getSignatureParameters(privateKey, hashAlgorithm = "SHA-1")
	{
		//region Check hashing algorithm
		const oid = this.getOIDByAlgorithm({ name: hashAlgorithm });
		if(oid === "")
			return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
		//endregion
		
		//region Initial variables
		const signatureAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
		//endregion
		
		//region Get a "default parameters" for current algorithm
		const parameters = this.getAlgorithmParameters(privateKey.algorithm.name, "sign");
		parameters.algorithm.hash.name = hashAlgorithm;
		//endregion
		
		//region Fill internal structures base on "privateKey" and "hashAlgorithm"
		switch(privateKey.algorithm.name.toUpperCase())
		{
			case "RSASSA-PKCS1-V1_5":
			case "ECDSA":
				signatureAlgorithm.algorithmId = this.getOIDByAlgorithm(parameters.algorithm);
				break;
			case "RSA-PSS":
				{
					//region Set "saltLength" as a length (in octets) of hash function result
					switch(hashAlgorithm.toUpperCase())
					{
						case "SHA-256":
							parameters.algorithm.saltLength = 32;
							break;
						case "SHA-384":
							parameters.algorithm.saltLength = 48;
							break;
						case "SHA-512":
							parameters.algorithm.saltLength = 64;
							break;
						default:
					}
					//endregion
					
					//region Fill "RSASSA_PSS_params" object
					const paramsObject = {};
					
					if(hashAlgorithm.toUpperCase() !== "SHA-1")
					{
						const hashAlgorithmOID = this.getOIDByAlgorithm({ name: hashAlgorithm });
						if(hashAlgorithmOID === "")
							return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
						
						paramsObject.hashAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
							algorithmId: hashAlgorithmOID,
							algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
						});
						
						paramsObject.maskGenAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
							algorithmId: "1.2.840.113549.1.1.8", // MGF1
							algorithmParams: paramsObject.hashAlgorithm.toSchema()
						});
					}
					
					if(parameters.algorithm.saltLength !== 20)
						paramsObject.saltLength = parameters.algorithm.saltLength;
					
					const pssParameters = new _RSASSAPSSParams_js__WEBPACK_IMPORTED_MODULE_7__["default"](paramsObject);
					//endregion
					
					//region Automatically set signature algorithm
					signatureAlgorithm.algorithmId = "1.2.840.113549.1.1.10";
					signatureAlgorithm.algorithmParams = pssParameters.toSchema();
					//endregion
				}
				break;
			default:
				return Promise.reject(`Unsupported signature algorithm: ${privateKey.algorithm.name}`);
		}
		//endregion

		return Promise.resolve().then(() => ({
			signatureAlgorithm,
			parameters
		}));
	}
	//**********************************************************************************
	/**
	 * Sign data with pre-defined private key
	 * @param {ArrayBuffer} data Data to be signed
	 * @param {Object} privateKey Private key to use
	 * @param {Object} parameters Parameters for used algorithm
	 * @return {Promise.<T>|Promise}
	 */
	signWithPrivateKey(data, privateKey, parameters)
	{
		return this.sign(parameters.algorithm,
			privateKey,
			new Uint8Array(data))
			.then(result =>
			{
				//region Special case for ECDSA algorithm
				if(parameters.algorithm.name === "ECDSA")
					result = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["createCMSECDSASignature"])(result);
				//endregion
				
				return result;
			}, error =>
				Promise.reject(`Signing error: ${error}`)
			);
	}
	//**********************************************************************************
	fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm)
	{
		const parameters = {};
		
		//region Find signer's hashing algorithm
		const shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
		if(shaAlgorithm === "")
			return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
		//endregion
		
		//region Get information about public key algorithm and default parameters for import
		let algorithmId;
		if(signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
			algorithmId = signatureAlgorithm.algorithmId;
		else
			algorithmId = publicKeyInfo.algorithm.algorithmId;
		
		const algorithmObject = this.getAlgorithmByOID(algorithmId);
		if(("name" in algorithmObject) === "")
			return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);
		
		parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importkey");
		if("hash" in parameters.algorithm.algorithm)
			parameters.algorithm.algorithm.hash.name = shaAlgorithm;
		
		//region Special case for ECDSA
		if(algorithmObject.name === "ECDSA")
		{
			//region Get information about named curve
			let algorithmParamsChecked = false;
			
			if(("algorithmParams" in publicKeyInfo.algorithm) === true)
			{
				if("idBlock" in publicKeyInfo.algorithm.algorithmParams)
				{
					if((publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1) && (publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6))
						algorithmParamsChecked = true;
				}
			}
			
			if(algorithmParamsChecked === false)
				return Promise.reject("Incorrect type for ECDSA public key parameters");
			
			const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
			if(("name" in curveObject) === false)
				return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
			//endregion
			
			parameters.algorithm.algorithm.namedCurve = curveObject.name;
		}
		//endregion
		//endregion
		
		return parameters;
	}
	//**********************************************************************************
	getPublicKey(publicKeyInfo, signatureAlgorithm, parameters = null)
	{
		if(parameters === null)
			parameters = this.fillPublicKeyParameters(publicKeyInfo, signatureAlgorithm);
		
		const publicKeyInfoSchema = publicKeyInfo.toSchema();
		const publicKeyInfoBuffer = publicKeyInfoSchema.toBER(false);
		const publicKeyInfoView = new Uint8Array(publicKeyInfoBuffer);
		
		return this.importKey("spki",
			publicKeyInfoView,
			parameters.algorithm.algorithm,
			true,
			parameters.algorithm.usages
		);
	}
	//**********************************************************************************
	verifyWithPublicKey(data, signature, publicKeyInfo, signatureAlgorithm, shaAlgorithm = null)
	{
		//region Initial variables
		let sequence = Promise.resolve();
		//endregion
		
		//region Find signer's hashing algorithm
		if(shaAlgorithm === null)
		{
			shaAlgorithm = this.getHashAlgorithm(signatureAlgorithm);
			if(shaAlgorithm === "")
				return Promise.reject(`Unsupported signature algorithm: ${signatureAlgorithm.algorithmId}`);
			
			//region Import public key
			sequence = sequence.then(() =>
				this.getPublicKey(publicKeyInfo, signatureAlgorithm));
			//endregion
		}
		else
		{
			const parameters = {};
			
			//region Get information about public key algorithm and default parameters for import
			let algorithmId;
			if(signatureAlgorithm.algorithmId === "1.2.840.113549.1.1.10")
				algorithmId = signatureAlgorithm.algorithmId;
			else
				algorithmId = publicKeyInfo.algorithm.algorithmId;
			
			const algorithmObject = this.getAlgorithmByOID(algorithmId);
			if(("name" in algorithmObject) === "")
				return Promise.reject(`Unsupported public key algorithm: ${signatureAlgorithm.algorithmId}`);
			
			parameters.algorithm = this.getAlgorithmParameters(algorithmObject.name, "importkey");
			if("hash" in parameters.algorithm.algorithm)
				parameters.algorithm.algorithm.hash.name = shaAlgorithm;
			
			//region Special case for ECDSA
			if(algorithmObject.name === "ECDSA")
			{
				//region Get information about named curve
				let algorithmParamsChecked = false;
				
				if(("algorithmParams" in publicKeyInfo.algorithm) === true)
				{
					if("idBlock" in publicKeyInfo.algorithm.algorithmParams)
					{
						if((publicKeyInfo.algorithm.algorithmParams.idBlock.tagClass === 1) && (publicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber === 6))
							algorithmParamsChecked = true;
					}
				}
				
				if(algorithmParamsChecked === false)
					return Promise.reject("Incorrect type for ECDSA public key parameters");
				
				const curveObject = this.getAlgorithmByOID(publicKeyInfo.algorithm.algorithmParams.valueBlock.toString());
				if(("name" in curveObject) === false)
					return Promise.reject(`Unsupported named curve algorithm: ${publicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);
				//endregion
				
				parameters.algorithm.algorithm.namedCurve = curveObject.name;
			}
			//endregion
			//endregion

			//region Import public key
			sequence = sequence.then(() =>
				this.getPublicKey(publicKeyInfo, null, parameters));
			//endregion
		}
		//endregion
		
		//region Verify signature
		sequence = sequence.then(publicKey =>
		{
			//region Get default algorithm parameters for verification
			const algorithm = this.getAlgorithmParameters(publicKey.algorithm.name, "verify");
			if("hash" in algorithm.algorithm)
				algorithm.algorithm.hash.name = shaAlgorithm;
			//endregion
			
			//region Special case for ECDSA signatures
			let signatureValue = signature.valueBlock.valueHex;
			
			if(publicKey.algorithm.name === "ECDSA")
			{
				const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](signatureValue);
				// noinspection JSCheckFunctionSignatures
				signatureValue = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["createECDSASignatureFromCMS"])(asn1.result);
			}
			//endregion
			
			//region Special case for RSA-PSS
			if(publicKey.algorithm.name === "RSA-PSS")
			{
				let pssParameters;
				
				try
				{
					pssParameters = new _RSASSAPSSParams_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: signatureAlgorithm.algorithmParams });
				}
				catch(ex)
				{
					return Promise.reject(ex);
				}
				
				if("saltLength" in pssParameters)
					algorithm.algorithm.saltLength = pssParameters.saltLength;
				else
					algorithm.algorithm.saltLength = 20;
				
				let hashAlgo = "SHA-1";
				
				if("hashAlgorithm" in pssParameters)
				{
					const hashAlgorithm = this.getAlgorithmByOID(pssParameters.hashAlgorithm.algorithmId);
					if(("name" in hashAlgorithm) === false)
						return Promise.reject(`Unrecognized hash algorithm: ${pssParameters.hashAlgorithm.algorithmId}`);
					
					hashAlgo = hashAlgorithm.name;
				}
				
				algorithm.algorithm.hash.name = hashAlgo;
			}
			//endregion
			
			return this.verify(algorithm.algorithm,
				publicKey,
				new Uint8Array(signatureValue),
				new Uint8Array(data)
			);
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/DigestInfo.js":
/*!**********************************************!*\
  !*** ./node_modules/pkijs/src/DigestInfo.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DigestInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC3447
 */
class DigestInfo 
{
	//**********************************************************************************
	/**
	 * Constructor for DigestInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc digestAlgorithm
		 */
		this.digestAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "digestAlgorithm", DigestInfo.defaultValues("digestAlgorithm"));
		/**
		 * @type {OctetString}
		 * @desc digest
		 */
		this.digest = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "digest", DigestInfo.defaultValues("digest"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "digestAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "digest":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			default:
				throw new Error(`Invalid member name for DigestInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "digestAlgorithm":
				return ((_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("algorithmId", memberValue.algorithmId)) &&
				(("algorithmParams" in memberValue) === false));
			case "digest":
				return (memberValue.isEqual(DigestInfo.defaultValues(memberName)));
			default:
				throw new Error(`Invalid member name for DigestInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * DigestInfo ::= SEQUENCE {
	 *    digestAlgorithm DigestAlgorithmIdentifier,
	 *    digest Digest }
	 *
	 * Digest ::= OCTET STRING
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [type]
		 * @property {string} [setName]
		 * @property {string} [values]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.digestAlgorithm || {
					names: {
						blockName: "digestAlgorithm"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.digest || "digest") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"digestAlgorithm",
			"digest"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			DigestInfo.schema({
				names: {
					digestAlgorithm: {
						names: {
							blockName: "digestAlgorithm"
						}
					},
					digest: "digest"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for DigestInfo");
		//endregion
		
		//region Get internal properties from parsed schema
		this.digestAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.digestAlgorithm });
		this.digest = asn1.result.digest;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.digestAlgorithm.toSchema(),
				this.digest
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			digestAlgorithm: this.digestAlgorithm.toJSON(),
			digest: this.digest.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/DistributionPoint.js":
/*!*****************************************************!*\
  !*** ./node_modules/pkijs/src/DistributionPoint.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DistributionPoint; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");
/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");




//**************************************************************************************
/**
 * Class from RFC5280
 */
class DistributionPoint
{
	//**********************************************************************************
	/**
	 * Constructor for DistributionPoint class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 * @property {Object} [distributionPoint]
	 * @property {Object} [reasons]
	 * @property {Object} [cRLIssuer]
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("distributionPoint" in parameters)
			/**
			 * @type {Array.<GeneralName>}
			 * @desc distributionPoint
			 */
			this.distributionPoint = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "distributionPoint", DistributionPoint.defaultValues("distributionPoint"));

		if("reasons" in parameters)
			/**
			 * @type {BitString}
			 * @desc values
			 */
			this.reasons = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "reasons", DistributionPoint.defaultValues("reasons"));

		if("cRLIssuer" in parameters)
			/**
			 * @type {Array.<GeneralName>}
			 * @desc cRLIssuer
			 */
			this.cRLIssuer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "cRLIssuer", DistributionPoint.defaultValues("cRLIssuer"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "distributionPoint":
				return [];
			case "reasons":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			case "cRLIssuer":
				return [];
			default:
				throw new Error(`Invalid member name for DistributionPoint class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * DistributionPoint ::= SEQUENCE {
	 *    distributionPoint       [0]     DistributionPointName OPTIONAL,
	 *    reasons                 [1]     ReasonFlags OPTIONAL,
	 *    cRLIssuer               [2]     GeneralNames OPTIONAL }
	 *
	 * DistributionPointName ::= CHOICE {
	 *    fullName                [0]     GeneralNames,
	 *    nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }
	 *
	 * ReasonFlags ::= BIT STRING {
	 *    unused                  (0),
	 *    keyCompromise           (1),
	 *    cACompromise            (2),
	 *    affiliationChanged      (3),
	 *    superseded              (4),
	 *    cessationOfOperation    (5),
	 *    certificateHold         (6),
	 *    privilegeWithdrawn      (7),
	 *    aACompromise            (8) }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [distributionPoint]
		 * @property {string} [distributionPointNames]
		 * @property {string} [reasons]
		 * @property {string} [cRLIssuer]
		 * @property {string} [cRLIssuerNames]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
							value: [
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
									name: (names.distributionPoint || ""),
									optional: true,
									idBlock: {
										tagClass: 3, // CONTEXT-SPECIFIC
										tagNumber: 0 // [0]
									},
									value: [
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
											name: (names.distributionPointNames || ""),
											value: _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
										})
									]
								}),
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
									name: (names.distributionPoint || ""),
									optional: true,
									idBlock: {
										tagClass: 3, // CONTEXT-SPECIFIC
										tagNumber: 1 // [1]
									},
									value: _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema().valueBlock.value
								})
							]
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.reasons || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					}
				}), // IMPLICIT bitstring value
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.cRLIssuer || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.cRLIssuerNames || ""),
							value: _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
						})
					]
				}) // IMPLICIT bitstring value
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"distributionPoint",
			"distributionPointNames",
			"reasons",
			"cRLIssuer",
			"cRLIssuerNames"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			DistributionPoint.schema({
				names: {
					distributionPoint: "distributionPoint",
					distributionPointNames: "distributionPointNames",
					reasons: "reasons",
					cRLIssuer: "cRLIssuer",
					cRLIssuerNames: "cRLIssuerNames"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for DistributionPoint");
		//endregion

		//region Get internal properties from parsed schema
		if("distributionPoint" in asn1.result)
		{
			if(asn1.result.distributionPoint.idBlock.tagNumber === 0) // GENERAL_NAMES variant
				this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));

			if(asn1.result.distributionPoint.idBlock.tagNumber === 1) // RDN variant
			{
				this.distributionPoint = new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
					schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
						value: asn1.result.distributionPoint.valueBlock.value
					})
				});
			}
		}

		if("reasons" in asn1.result)
			this.reasons = new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ valueHex: asn1.result.reasons.valueBlock.valueHex });

		if("cRLIssuer" in asn1.result)
			this.cRLIssuer = Array.from(asn1.result.cRLIssuerNames, element => new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if("distributionPoint" in this)
		{
			let internalValue;
			
			if(this.distributionPoint instanceof Array)
			{
				internalValue = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: Array.from(this.distributionPoint, element => element.toSchema())
				});
			}
			else
			{
				internalValue = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [this.distributionPoint.toSchema()]
				});
			}
			
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [internalValue]
			}));
		}
		
		if("reasons" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				valueHex: this.reasons.valueBlock.valueHex
			}));
		}
		
		if("cRLIssuer" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 2 // [2]
				},
				value: Array.from(this.cRLIssuer, element => element.toSchema())
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};

		if("distributionPoint" in this)
		{
			if(this.distributionPoint instanceof Array)
				object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());
			else
				object.distributionPoint = this.distributionPoint.toJSON();
		}

		if("reasons" in this)
			object.reasons = this.reasons.toJSON();

		if("cRLIssuer" in this)
			object.cRLIssuer = Array.from(this.cRLIssuer, element => element.toJSON());

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/ECCCMSSharedInfo.js":
/*!****************************************************!*\
  !*** ./node_modules/pkijs/src/ECCCMSSharedInfo.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ECCCMSSharedInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC6318
 */
class ECCCMSSharedInfo
{
	//**********************************************************************************
	/**
	 * Constructor for ECCCMSSharedInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc keyInfo
		 */
		this.keyInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyInfo", ECCCMSSharedInfo.defaultValues("keyInfo"));

		if("entityUInfo" in parameters)
			/**
			 * @type {OctetString}
			 * @desc entityUInfo
			 */
			this.entityUInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "entityUInfo", ECCCMSSharedInfo.defaultValues("entityUInfo"));

		/**
		 * @type {OctetString}
		 * @desc suppPubInfo
		 */
		this.suppPubInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "suppPubInfo", ECCCMSSharedInfo.defaultValues("suppPubInfo"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "keyInfo":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "entityUInfo":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "suppPubInfo":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			default:
				throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "keyInfo":
			case "entityUInfo":
			case "suppPubInfo":
				return (memberValue.isEqual(ECCCMSSharedInfo.defaultValues(memberName)));
			default:
				throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * ECC-CMS-SharedInfo  ::=  SEQUENCE {
	 *    keyInfo      AlgorithmIdentifier,
	 *    entityUInfo  [0] EXPLICIT OCTET STRING OPTIONAL,
	 *    suppPubInfo  [2] EXPLICIT OCTET STRING }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [keyInfo]
		 * @property {string} [entityUInfo]
		 * @property {string} [suppPubInfo]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.keyInfo || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.entityUInfo || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					optional: true,
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]()]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.suppPubInfo || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]()]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"keyInfo",
			"entityUInfo",
			"suppPubInfo"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			ECCCMSSharedInfo.schema({
				names: {
					keyInfo: {
						names: {
							blockName: "keyInfo"
						}
					},
					entityUInfo: "entityUInfo",
					suppPubInfo: "suppPubInfo"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for ECCCMSSharedInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.keyInfo = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.keyInfo });

		if("entityUInfo" in asn1.result)
			this.entityUInfo = asn1.result.entityUInfo.valueBlock.value[0];

		this.suppPubInfo = asn1.result.suppPubInfo.valueBlock.value[0];
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create output array for sequence 
		const outputArray = [];
		
		outputArray.push(this.keyInfo.toSchema());
		
		if("entityUInfo" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [this.entityUInfo]
			}));
		}
		
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
			idBlock: {
				tagClass: 3, // CONTEXT-SPECIFIC
				tagNumber: 2 // [2]
			},
			value: [this.suppPubInfo]
		}));
		//endregion 
		
		//region Construct and return new ASN.1 schema for this object 
		return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		});
		//endregion 
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			keyInfo: this.keyInfo.toJSON()
		};

		if("entityUInfo" in this)
			_object.entityUInfo = this.entityUInfo.toJSON();

		_object.suppPubInfo = this.suppPubInfo.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/ECNamedCurves.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/ECNamedCurves.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ECNamedCurves; });

class ECNamedCurves {

	/**
	 * Registers an ECC named curve
	 * @param {string} name The name o the curve
	 * @param {string} id The curve ASN.1 object identifier
	 * @param {number} size The coordinate length in bytes
	 */
	static register(name, id, size) {
		this.namedCurves[name.toLowerCase()] = this.namedCurves[id] = { name, id, size };
	}

	/**
	* Returns an ECC named curve object
	* @param {string} nameOrId Name or identifier of the named curve
	* @returns {Object | null}
	*/
	static find(nameOrId) {
		return this.namedCurves[nameOrId.toLowerCase()] || null;
	}

}

ECNamedCurves.namedCurves = {};

// NIST
ECNamedCurves.register("P-256", "1.2.840.10045.3.1.7", 32);
ECNamedCurves.register("P-384", "1.3.132.0.34", 48);
ECNamedCurves.register("P-521", "1.3.132.0.35", 66);

// Brainpool
ECNamedCurves.register("brainpoolP256r1", "1.3.36.3.3.2.8.1.1.7", 32);
ECNamedCurves.register("brainpoolP384r1", "1.3.36.3.3.2.8.1.1.11", 48);
ECNamedCurves.register("brainpoolP512r1", "1.3.36.3.3.2.8.1.1.13", 64);


/***/ }),

/***/ "./node_modules/pkijs/src/ECPrivateKey.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/ECPrivateKey.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ECPrivateKey; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _ECPublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ECPublicKey.js */ "./node_modules/pkijs/src/ECPublicKey.js");



//**************************************************************************************
/**
 * Class from RFC5915
 */
class ECPrivateKey
{
	//**********************************************************************************
	/**
	 * Constructor for ECPrivateKey class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", ECPrivateKey.defaultValues("version"));
		/**
		 * @type {OctetString}
		 * @desc privateKey
		 */
		this.privateKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "privateKey", ECPrivateKey.defaultValues("privateKey"));

		if("namedCurve" in parameters)
			/**
			 * @type {string}
			 * @desc namedCurve
			 */
			this.namedCurve = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "namedCurve", ECPrivateKey.defaultValues("namedCurve"));

		if("publicKey" in parameters)
			/**
			 * @type {ECPublicKey}
			 * @desc publicKey
			 */
			this.publicKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "publicKey", ECPrivateKey.defaultValues("publicKey"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
		//region If input argument array contains "json" for this object
		if("json" in parameters)
			this.fromJSON(parameters.json);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 1;
			case "privateKey":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "namedCurve":
				return "";
			case "publicKey":
				return new _ECPublicKey_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			default:
				throw new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
				return (memberValue === ECPrivateKey.defaultValues(memberName));
			case "privateKey":
				return (memberValue.isEqual(ECPrivateKey.defaultValues(memberName)));
			case "namedCurve":
				return (memberValue === "");
			case "publicKey":
				return ((_ECPublicKey_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("namedCurve", memberValue.namedCurve)) &&
						(_ECPublicKey_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("x", memberValue.x)) &&
						(_ECPublicKey_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("y", memberValue.y)));
			default:
				throw new Error(`Invalid member name for ECCPrivateKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * ECPrivateKey ::= SEQUENCE {
	 * version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
	 * privateKey     OCTET STRING,
	 * parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
	 * publicKey  [1] BIT STRING OPTIONAL
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [privateKey]
		 * @property {string} [namedCurve]
		 * @property {string} [publicKey]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.privateKey || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.namedCurve || "") })
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.publicKey || "") })
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"privateKey",
			"namedCurve",
			"publicKey"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			ECPrivateKey.schema({
				names: {
					version: "version",
					privateKey: "privateKey",
					namedCurve: "namedCurve",
					publicKey: "publicKey"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for ECPrivateKey");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.privateKey = asn1.result.privateKey;

		if("namedCurve" in asn1.result)
			this.namedCurve = asn1.result.namedCurve.valueBlock.toString();

		if("publicKey" in asn1.result)
		{
			const publicKeyData = { schema: asn1.result.publicKey.valueBlock.valueHex };
			if("namedCurve" in this)
				publicKeyData.namedCurve = this.namedCurve;

			this.publicKey = new _ECPublicKey_js__WEBPACK_IMPORTED_MODULE_2__["default"](publicKeyData);
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const outputArray = [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }),
			this.privateKey
		];

		if("namedCurve" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.namedCurve })
				]
			}));
		}

		if("publicKey" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ valueHex: this.publicKey.toSchema().toBER(false) })
				]
			}));
		}

		return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		});
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		if((("namedCurve" in this) === false) || (ECPrivateKey.compareWithDefault("namedCurve", this.namedCurve)))
			throw new Error("Not enough information for making JSON: absent \"namedCurve\" value");

		let crvName = "";

		switch(this.namedCurve)
		{
			case "1.2.840.10045.3.1.7": // P-256
				crvName = "P-256";
				break;
			case "1.3.132.0.34": // P-384
				crvName = "P-384";
				break;
			case "1.3.132.0.35": // P-521
				crvName = "P-521";
				break;
			default:
		}

		const privateKeyJSON = {
			crv: crvName,
			d: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.privateKey.valueBlock.valueHex), true, true, false)
		};

		if("publicKey" in this)
		{
			const publicKeyJSON = this.publicKey.toJSON();

			privateKeyJSON.x = publicKeyJSON.x;
			privateKeyJSON.y = publicKeyJSON.y;
		}

		return privateKeyJSON;
	}
	//**********************************************************************************
	/**
	 * Convert JSON value into current object
	 * @param {Object} json
	 */
	fromJSON(json)
	{
		let coodinateLength = 0;

		if("crv" in json)
		{
			switch(json.crv.toUpperCase())
			{
				case "P-256":
					this.namedCurve = "1.2.840.10045.3.1.7";
					coodinateLength = 32;
					break;
				case "P-384":
					this.namedCurve = "1.3.132.0.34";
					coodinateLength = 48;
					break;
				case "P-521":
					this.namedCurve = "1.3.132.0.35";
					coodinateLength = 66;
					break;
				default:
			}
		}
		else
			throw new Error("Absent mandatory parameter \"crv\"");

		if("d" in json)
		{
			const convertBuffer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.d, true));
			
			if(convertBuffer.byteLength < coodinateLength)
			{
				const buffer = new ArrayBuffer(coodinateLength);
				const view = new Uint8Array(buffer);
				const convertBufferView = new Uint8Array(convertBuffer);
				view.set(convertBufferView, 1);
				
				this.privateKey = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: buffer });
			}
			else
				this.privateKey = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: convertBuffer.slice(0, coodinateLength) });
		}
		else
			throw new Error("Absent mandatory parameter \"d\"");

		if(("x" in json) && ("y" in json))
			this.publicKey = new _ECPublicKey_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ json });
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/ECPublicKey.js":
/*!***********************************************!*\
  !*** ./node_modules/pkijs/src/ECPublicKey.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ECPublicKey; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _ECNamedCurves__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ECNamedCurves */ "./node_modules/pkijs/src/ECNamedCurves.js");



//**************************************************************************************

/**
 * Class from RFC5480
 */
class ECPublicKey
{

	//**********************************************************************************
	/**
	 * Constructor for ECCPublicKey class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {ArrayBuffer}
		 * @desc type
		 */
		this.x = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "x", ECPublicKey.defaultValues("x"));
		/**
		 * @type {ArrayBuffer}
		 * @desc values
		 */
		this.y = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "y", ECPublicKey.defaultValues("y"));
		/**
		 * @type {string}
		 * @desc namedCurve
		 */
		this.namedCurve = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "namedCurve", ECPublicKey.defaultValues("namedCurve"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
		//region If input argument array contains "json" for this object
		if("json" in parameters)
			this.fromJSON(parameters.json);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "x":
			case "y":
				return new ArrayBuffer(0);
			case "namedCurve":
				return "";
			default:
				throw new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "x":
			case "y":
				return (Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(memberValue, ECPublicKey.defaultValues(memberName)));
			case "namedCurve":
				return (memberValue === "");
			default:
				throw new Error(`Invalid member name for ECCPublicKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		return new asn1js__WEBPACK_IMPORTED_MODULE_0__["RawData"]();
	}
	//**********************************************************************************
	/**
	 * Convert ArrayBuffer into current class
	 * @param {!ArrayBuffer} schema Special case: schema is an ArrayBuffer
	 */
	fromSchema(schema)
	{
		//region Check the schema is valid
		if((schema instanceof ArrayBuffer) === false)
			throw new Error("Object's schema was not verified against input data for ECPublicKey");

		const view = new Uint8Array(schema);
		if(view[0] !== 0x04)
			throw new Error("Object's schema was not verified against input data for ECPublicKey");
		//endregion

		//region Get internal properties from parsed schema
		const namedCurve = _ECNamedCurves__WEBPACK_IMPORTED_MODULE_2__["default"].find(this.namedCurve);
		if (!namedCurve) {
			throw new Error(`Incorrect curve OID: ${this.namedCurve}`);
		}
		const coordinateLength = namedCurve.size;

		if(schema.byteLength !== (coordinateLength * 2 + 1))
			throw new Error("Object's schema was not verified against input data for ECPublicKey");

		this.x = schema.slice(1, coordinateLength + 1);
		this.y = schema.slice(1 + coordinateLength, coordinateLength * 2 + 1);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		return new asn1js__WEBPACK_IMPORTED_MODULE_0__["RawData"]({ data: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(
			(new Uint8Array([0x04])).buffer,
			this.x,
			this.y
		)
		});
	}
	//**********************************************************************************
	/**
	 * Conversion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const namedCurve = _ECNamedCurves__WEBPACK_IMPORTED_MODULE_2__["default"].find(this.namedCurve);

		return {
			crv: namedCurve ? namedCurve.name : this.namedCurve,
			x: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.x), true, true, false),
			y: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.y), true, true, false)
		};
	}
	//**********************************************************************************
	/**
	 * Convert JSON value into current object
	 * @param {Object} json
	 */
	fromJSON(json)
	{
		let coordinateLength = 0;

		if("crv" in json)
		{
			const namedCurve = _ECNamedCurves__WEBPACK_IMPORTED_MODULE_2__["default"].find(json.crv);
			if (namedCurve) {
				this.namedCurve = namedCurve.id;
				coordinateLength = namedCurve.size;
			}
		}
		else
			throw new Error("Absent mandatory parameter \"crv\"");

		if("x" in json)
		{
			const convertBuffer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.x, true));

			if(convertBuffer.byteLength < coordinateLength)
			{
				this.x = new ArrayBuffer(coordinateLength);
				const view = new Uint8Array(this.x);
				const convertBufferView = new Uint8Array(convertBuffer);
				view.set(convertBufferView, 1);
			}
			else
				this.x = convertBuffer.slice(0, coordinateLength);
		}
		else
			throw new Error("Absent mandatory parameter \"x\"");

		if("y" in json)
		{
			const convertBuffer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.y, true));

			if(convertBuffer.byteLength < coordinateLength)
			{
				this.y = new ArrayBuffer(coordinateLength);
				const view = new Uint8Array(this.y);
				const convertBufferView = new Uint8Array(convertBuffer);
				view.set(convertBufferView, 1);
			}
			else
				this.y = convertBuffer.slice(0, coordinateLength);
		}
		else
			throw new Error("Absent mandatory parameter \"y\"");
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/EncapsulatedContentInfo.js":
/*!***********************************************************!*\
  !*** ./node_modules/pkijs/src/EncapsulatedContentInfo.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EncapsulatedContentInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5652
 */
class EncapsulatedContentInfo
{
	//**********************************************************************************
	/**
	 * Constructor for EncapsulatedContentInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc eContentType
		 */
		this.eContentType = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "eContentType", EncapsulatedContentInfo.defaultValues("eContentType"));

		if("eContent" in parameters)
		{
			/**
			 * @type {OctetString}
			 * @desc eContent
			 */
			this.eContent = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "eContent", EncapsulatedContentInfo.defaultValues("eContent"));
			if((this.eContent.idBlock.tagClass === 1) &&
				(this.eContent.idBlock.tagNumber === 4))
			{
				//region Divide OCTETSTRING value down to small pieces
				if(this.eContent.idBlock.isConstructed === false)
				{
					const constrString = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({
						idBlock: { isConstructed: true },
						isConstructed: true
					});
					
					let offset = 0;
					let length = this.eContent.valueBlock.valueHex.byteLength;
					
					while(length > 0)
					{
						const pieceView = new Uint8Array(this.eContent.valueBlock.valueHex, offset, ((offset + 65536) > this.eContent.valueBlock.valueHex.byteLength) ? (this.eContent.valueBlock.valueHex.byteLength - offset) : 65536);
						const _array = new ArrayBuffer(pieceView.length);
						const _view = new Uint8Array(_array);
						
						for(let i = 0; i < _view.length; i++)
							_view[i] = pieceView[i];
						
						constrString.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: _array }));
						
						length -= pieceView.length;
						offset += pieceView.length;
					}
					
					this.eContent = constrString;
				}
				//endregion
			}
		}
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "eContentType":
				return "";
			case "eContent":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			default:
				throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "eContentType":
				return (memberValue === "");
			case "eContent":
				{
					if((memberValue.idBlock.tagClass === 1) && (memberValue.idBlock.tagNumber === 4))
						return (memberValue.isEqual(EncapsulatedContentInfo.defaultValues("eContent")));
					
					return false;
				}
			default:
				throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * EncapsulatedContentInfo ::= SEQUENCE {
	 *    eContentType ContentType,
	 *    eContent [0] EXPLICIT OCTET STRING OPTIONAL } * Changed it to ANY, as in PKCS#7
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [type]
		 * @property {string} [setName]
		 * @property {string} [values]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.eContentType || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.eContent || "") }) // In order to aling this with PKCS#7 and CMS as well
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"eContentType",
			"eContent"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			EncapsulatedContentInfo.schema({
				names: {
					eContentType: "eContentType",
					eContent: "eContent"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for EncapsulatedContentInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.eContentType = asn1.result.eContentType.valueBlock.toString();
		if("eContent" in asn1.result)
			this.eContent = asn1.result.eContent;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence 
		const outputArray = [];
		
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.eContentType }));
		if("eContent" in this)
		{
			if(EncapsulatedContentInfo.compareWithDefault("eContent", this.eContent) === false)
			{
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [this.eContent]
				}));
			}
		}
		//endregion 
		
		//region Construct and return new ASN.1 schema for this object 
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion 
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			eContentType: this.eContentType
		};

		if("eContent" in this)
		{
			if(EncapsulatedContentInfo.compareWithDefault("eContent", this.eContent) === false)
				_object.eContent = this.eContent.toJSON();
		}

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/EncryptedContentInfo.js":
/*!********************************************************!*\
  !*** ./node_modules/pkijs/src/EncryptedContentInfo.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EncryptedContentInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class EncryptedContentInfo
{
	//**********************************************************************************
	/**
	 * Constructor for EncryptedContentInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc contentType
		 */
		this.contentType = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "contentType", EncryptedContentInfo.defaultValues("contentType"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc contentEncryptionAlgorithm
		 */
		this.contentEncryptionAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "contentEncryptionAlgorithm", EncryptedContentInfo.defaultValues("contentEncryptionAlgorithm"));

		if("encryptedContent" in parameters)
		{
			/**
			 * @type {OctetString}
			 * @desc encryptedContent (!!!) could be contructive or primitive value (!!!)
			 */
			this.encryptedContent = parameters.encryptedContent;
			
			if((this.encryptedContent.idBlock.tagClass === 1) &&
				(this.encryptedContent.idBlock.tagNumber === 4))
			{
				//region Divide OCTETSTRING value down to small pieces
				if(this.encryptedContent.idBlock.isConstructed === false)
				{
					const constrString = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({
						idBlock: { isConstructed: true },
						isConstructed: true
					});
					
					let offset = 0;
					let length = this.encryptedContent.valueBlock.valueHex.byteLength;
					
					while(length > 0)
					{
						const pieceView = new Uint8Array(this.encryptedContent.valueBlock.valueHex, offset, ((offset + 1024) > this.encryptedContent.valueBlock.valueHex.byteLength) ? (this.encryptedContent.valueBlock.valueHex.byteLength - offset) : 1024);
						const _array = new ArrayBuffer(pieceView.length);
						const _view = new Uint8Array(_array);
						
						for(let i = 0; i < _view.length; i++)
							_view[i] = pieceView[i];
						
						constrString.valueBlock.value.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: _array }));
						
						length -= pieceView.length;
						offset += pieceView.length;
					}
					
					this.encryptedContent = constrString;
				}
				//endregion
			}
		}
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "contentType":
				return "";
			case "contentEncryptionAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "encryptedContent":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			default:
				throw new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "contentType":
				return (memberValue === "");
			case "contentEncryptionAlgorithm":
				return ((memberValue.algorithmId === "") && (("algorithmParams" in memberValue) === false));
			case "encryptedContent":
				return (memberValue.isEqual(EncryptedContentInfo.defaultValues(memberName)));
			default:
				throw new Error(`Invalid member name for EncryptedContentInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * EncryptedContentInfo ::= SEQUENCE {
	 *    contentType ContentType,
	 *    contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
	 *    encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }
	 *
	 * Comment: Strange, but modern crypto engines create "encryptedContent" as "[0] EXPLICIT EncryptedContent"
	 *
	 * EncryptedContent ::= OCTET STRING
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [contentType]
		 * @property {string} [contentEncryptionAlgorithm]
		 * @property {string} [encryptedContent]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.contentType || "") }),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.contentEncryptionAlgorithm || {}),
				// The CHOICE we need because "EncryptedContent" could have either "constructive"
				// or "primitive" form of encoding and we need to handle both variants
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							name: (names.encryptedContent || ""),
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 0 // [0]
							},
							value: [
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
									value: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]()
								})
							]
						}),
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
							name: (names.encryptedContent || ""),
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 0 // [0]
							}
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"contentType",
			"contentEncryptionAlgorithm",
			"encryptedContent"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			EncryptedContentInfo.schema({
				names: {
					contentType: "contentType",
					contentEncryptionAlgorithm: {
						names: {
							blockName: "contentEncryptionAlgorithm"
						}
					},
					encryptedContent: "encryptedContent"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.contentType = asn1.result.contentType.valueBlock.toString();
		this.contentEncryptionAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.contentEncryptionAlgorithm });

		if("encryptedContent" in asn1.result)
		{
			this.encryptedContent = asn1.result.encryptedContent;

			this.encryptedContent.idBlock.tagClass = 1; // UNIVERSAL
			this.encryptedContent.idBlock.tagNumber = 4; // OCTETSTRING (!!!) The value still has instance of "in_window.org.pkijs.asn1.ASN1_CONSTRUCTED / ASN1_PRIMITIVE"
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const sequenceLengthBlock = {
			isIndefiniteForm: false
		};

		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.contentType }));
		outputArray.push(this.contentEncryptionAlgorithm.toSchema());

		if("encryptedContent" in this)
		{
			sequenceLengthBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;

			const encryptedValue = this.encryptedContent;

			encryptedValue.idBlock.tagClass = 3; // CONTEXT-SPECIFIC
			encryptedValue.idBlock.tagNumber = 0; // [0]

			encryptedValue.lenBlock.isIndefiniteForm = this.encryptedContent.idBlock.isConstructed;

			outputArray.push(encryptedValue);
		}
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			lenBlock: sequenceLengthBlock,
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			contentType: this.contentType,
			contentEncryptionAlgorithm: this.contentEncryptionAlgorithm.toJSON()
		};

		if("encryptedContent" in this)
			_object.encryptedContent = this.encryptedContent.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/EncryptedData.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/EncryptedData.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EncryptedData; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EncryptedContentInfo.js */ "./node_modules/pkijs/src/EncryptedContentInfo.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");





//**************************************************************************************
/**
 * Class from RFC5652
 */
class EncryptedData
{
	//**********************************************************************************
	/**
	 * Constructor for EncryptedData class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", EncryptedData.defaultValues("version"));
		/**
		 * @type {EncryptedContentInfo}
		 * @desc encryptedContentInfo
		 */
		this.encryptedContentInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptedContentInfo", EncryptedData.defaultValues("encryptedContentInfo"));
		
		if("unprotectedAttrs" in parameters)
			/**
			 * @type {Array.<Attribute>}
			 * @desc unprotectedAttrs
			 */
			this.unprotectedAttrs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "unprotectedAttrs", EncryptedData.defaultValues("unprotectedAttrs"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "encryptedContentInfo":
				return new _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "unprotectedAttrs":
				return [];
			default:
				throw new Error(`Invalid member name for EncryptedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
				return (memberValue === 0);
			case "encryptedContentInfo":
				return ((_EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("contentType", memberValue.contentType)) &&
				(_EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm)) &&
				(_EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("encryptedContent", memberValue.encryptedContent)));
			case "unprotectedAttrs":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for EncryptedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * EncryptedData ::= SEQUENCE {
	 *    version CMSVersion,
	 *    encryptedContentInfo EncryptedContentInfo,
	 *    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [encryptedContentInfo]
		 * @property {string} [unprotectedAttrs]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				_EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.encryptedContentInfo || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.unprotectedAttrs || ""),
							value: _Attribute_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"encryptedContentInfo",
			"unprotectedAttrs"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			EncryptedData.schema({
				names: {
					version: "version",
					encryptedContentInfo: {
						names: {
							blockName: "encryptedContentInfo"
						}
					},
					unprotectedAttrs: "unprotectedAttrs"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for EncryptedData");
		//endregion
		
		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.encryptedContentInfo = new _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.encryptedContentInfo });
		
		if("unprotectedAttrs" in asn1.result)
			this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element => new _Attribute_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
		outputArray.push(this.encryptedContentInfo.toSchema());
		
		if("unprotectedAttrs" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.unprotectedAttrs, element => element.toSchema())
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			version: this.version,
			encryptedContentInfo: this.encryptedContentInfo.toJSON()
		};
		
		if("unprotectedAttrs" in this)
			_object.unprotectedAttrs = Array.from(this.unprotectedAttrs, element => element.toJSON());
		
		return _object;
	}
	//**********************************************************************************
	/**
	 * Create a new CMS Encrypted Data content
	 * @param {Object} parameters Parameters neccessary for encryption
	 * @returns {Promise}
	 */
	encrypt(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject("Parameters must have type \"Object\"");
		//endregion
		
		//region Get cryptographic engine
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		if(typeof engine === "undefined")
			return Promise.reject("Unable to initialize cryptographic engine");
		//endregion
		
		//region Set "contentType" parameter
		parameters.contentType = "1.2.840.113549.1.7.1"; // "data"
		//endregion
		
		if("encryptEncryptedContentInfo" in engine.subtle)
		{
			return engine.subtle.encryptEncryptedContentInfo(parameters).then(result =>
			{
				this.encryptedContentInfo = result;
			});
		}
		
		return Promise.reject(`No support for "encryptEncryptedContentInfo" in current crypto engine ${engine.name}`);
	}
	//**********************************************************************************
	/**
	 * Create a new CMS Encrypted Data content
	 * @param {Object} parameters Parameters neccessary for encryption
	 */
	decrypt(parameters)
	{
		//region Check for input parameters
		if((parameters instanceof Object) === false)
			return Promise.reject("Parameters must have type \"Object\"");
		//endregion
		
		//region Get cryptographic engine
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		if(typeof engine === "undefined")
			return Promise.reject("Unable to initialize cryptographic engine");
		//endregion
		
		//region Set "encryptedContentInfo" value
		parameters.encryptedContentInfo = this.encryptedContentInfo;
		//endregion
		
		if("decryptEncryptedContentInfo" in engine.subtle)
			return engine.subtle.decryptEncryptedContentInfo(parameters);
		
		return Promise.reject(`No support for "decryptEncryptedContentInfo" in current crypto engine ${engine.name}`);
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/EnvelopedData.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/EnvelopedData.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EnvelopedData; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _OriginatorInfo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OriginatorInfo.js */ "./node_modules/pkijs/src/OriginatorInfo.js");
/* harmony import */ var _RecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RecipientInfo.js */ "./node_modules/pkijs/src/RecipientInfo.js");
/* harmony import */ var _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EncryptedContentInfo.js */ "./node_modules/pkijs/src/EncryptedContentInfo.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _RSAESOAEPParams_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./RSAESOAEPParams.js */ "./node_modules/pkijs/src/RSAESOAEPParams.js");
/* harmony import */ var _KeyTransRecipientInfo_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./KeyTransRecipientInfo.js */ "./node_modules/pkijs/src/KeyTransRecipientInfo.js");
/* harmony import */ var _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./IssuerAndSerialNumber.js */ "./node_modules/pkijs/src/IssuerAndSerialNumber.js");
/* harmony import */ var _RecipientKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./RecipientKeyIdentifier.js */ "./node_modules/pkijs/src/RecipientKeyIdentifier.js");
/* harmony import */ var _RecipientEncryptedKey_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./RecipientEncryptedKey.js */ "./node_modules/pkijs/src/RecipientEncryptedKey.js");
/* harmony import */ var _KeyAgreeRecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./KeyAgreeRecipientIdentifier.js */ "./node_modules/pkijs/src/KeyAgreeRecipientIdentifier.js");
/* harmony import */ var _KeyAgreeRecipientInfo_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./KeyAgreeRecipientInfo.js */ "./node_modules/pkijs/src/KeyAgreeRecipientInfo.js");
/* harmony import */ var _RecipientEncryptedKeys_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./RecipientEncryptedKeys.js */ "./node_modules/pkijs/src/RecipientEncryptedKeys.js");
/* harmony import */ var _KEKRecipientInfo_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./KEKRecipientInfo.js */ "./node_modules/pkijs/src/KEKRecipientInfo.js");
/* harmony import */ var _KEKIdentifier_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./KEKIdentifier.js */ "./node_modules/pkijs/src/KEKIdentifier.js");
/* harmony import */ var _PBKDF2Params_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./PBKDF2Params.js */ "./node_modules/pkijs/src/PBKDF2Params.js");
/* harmony import */ var _PasswordRecipientinfo_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./PasswordRecipientinfo.js */ "./node_modules/pkijs/src/PasswordRecipientinfo.js");
/* harmony import */ var _ECCCMSSharedInfo_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./ECCCMSSharedInfo.js */ "./node_modules/pkijs/src/ECCCMSSharedInfo.js");
/* harmony import */ var _OriginatorIdentifierOrKey_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./OriginatorIdentifierOrKey.js */ "./node_modules/pkijs/src/OriginatorIdentifierOrKey.js");
/* harmony import */ var _OriginatorPublicKey_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./OriginatorPublicKey.js */ "./node_modules/pkijs/src/OriginatorPublicKey.js");























//**************************************************************************************
const defaultEncryptionParams = {
	kdfAlgorithm: "SHA-512",
	kekEncryptionLength: 256
};
const curveLengthByName = {
	"P-256": 256,
	"P-384": 384,
	"P-521": 528
};
//**************************************************************************************
/**
 * Class from RFC5652
 */
class EnvelopedData
{
	//**********************************************************************************
	/**
	 * Constructor for EnvelopedData class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", EnvelopedData.defaultValues("version"));

		if("originatorInfo" in parameters)
			/**
			 * @type {OriginatorInfo}
			 * @desc originatorInfo
			 */
			this.originatorInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "originatorInfo", EnvelopedData.defaultValues("originatorInfo"));

		/**
		 * @type {Array.<RecipientInfo>}
		 * @desc recipientInfos
		 */
		this.recipientInfos = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "recipientInfos", EnvelopedData.defaultValues("recipientInfos"));
		/**
		 * @type {EncryptedContentInfo}
		 * @desc encryptedContentInfo
		 */
		this.encryptedContentInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptedContentInfo", EnvelopedData.defaultValues("encryptedContentInfo"));

		if("unprotectedAttrs" in parameters)
			/**
			 * @type {Array.<Attribute>}
			 * @desc unprotectedAttrs
			 */
			this.unprotectedAttrs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "unprotectedAttrs", EnvelopedData.defaultValues("unprotectedAttrs"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "originatorInfo":
				return new _OriginatorInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "recipientInfos":
				return [];
			case "encryptedContentInfo":
				return new _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			case "unprotectedAttrs":
				return [];
			default:
				throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
				return (memberValue === EnvelopedData.defaultValues(memberName));
			case "originatorInfo":
				return ((memberValue.certs.certificates.length === 0) && (memberValue.crls.crls.length === 0));
			case "recipientInfos":
			case "unprotectedAttrs":
				return (memberValue.length === 0);
			case "encryptedContentInfo":
				return ((_EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"].compareWithDefault("contentType", memberValue.contentType)) &&
				(_EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"].compareWithDefault("contentEncryptionAlgorithm", memberValue.contentEncryptionAlgorithm) &&
				(_EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"].compareWithDefault("encryptedContent", memberValue.encryptedContent))));
			default:
				throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * EnvelopedData ::= SEQUENCE {
	 *    version CMSVersion,
	 *    originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
	 *    recipientInfos RecipientInfos,
	 *    encryptedContentInfo EncryptedContentInfo,
	 *    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [originatorInfo]
		 * @property {string} [recipientInfos]
		 * @property {string} [encryptedContentInfo]
		 * @property {string} [unprotectedAttrs]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.originatorInfo || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: _OriginatorInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema().valueBlock.value
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.recipientInfos || ""),
							value: _RecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema()
						})
					]
				}),
				_EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.encryptedContentInfo || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.unprotectedAttrs || ""),
							value: _Attribute_js__WEBPACK_IMPORTED_MODULE_6__["default"].schema()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"originatorInfo",
			"recipientInfos",
			"encryptedContentInfo",
			"unprotectedAttrs"
		]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			EnvelopedData.schema({
				names: {
					version: "version",
					originatorInfo: "originatorInfo",
					recipientInfos: "recipientInfos",
					encryptedContentInfo: {
						names: {
							blockName: "encryptedContentInfo"
						}
					},
					unprotectedAttrs: "unprotectedAttrs"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for EnvelopedData");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;

		if("originatorInfo" in asn1.result)
		{
			this.originatorInfo = new _OriginatorInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.originatorInfo.valueBlock.value
				})
			});
		}

		this.recipientInfos = Array.from(asn1.result.recipientInfos, element => new _RecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: element }));
		this.encryptedContentInfo = new _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result.encryptedContentInfo });

		if("unprotectedAttrs" in asn1.result)
			this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element => new _Attribute_js__WEBPACK_IMPORTED_MODULE_6__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));

		if("originatorInfo" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: this.originatorInfo.toSchema().valueBlock.value
			}));
		}

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
			value: Array.from(this.recipientInfos, element => element.toSchema())
		}));

		outputArray.push(this.encryptedContentInfo.toSchema());

		if("unprotectedAttrs" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.unprotectedAttrs, element => element.toSchema())
			}));
		}
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			version: this.version
		};

		if("originatorInfo" in this)
			_object.originatorInfo = this.originatorInfo.toJSON();

		_object.recipientInfos = Array.from(this.recipientInfos, element => element.toJSON());
		_object.encryptedContentInfo = this.encryptedContentInfo.toJSON();

		if("unprotectedAttrs" in this)
			_object.unprotectedAttrs = Array.from(this.unprotectedAttrs, element => element.toJSON());

		return _object;
	}
	//**********************************************************************************
	/**
	 * Helpers function for filling "RecipientInfo" based on recipient's certificate.
	 * Problem with WebCrypto is that for RSA certificates we have only one option - "key transport" and
	 * for ECC certificates we also have one option - "key agreement". As soon as Google will implement
	 * DH algorithm it would be possible to use "key agreement" also for RSA certificates.
	 * @param {Certificate} [certificate] Recipient's certificate
	 * @param {Object} [parameters] Additional parameters neccessary for "fine tunning" of encryption process
	 * @param {number} [variant] Variant = 1 is for "key transport", variant = 2 is for "key agreement". In fact the "variant" is unneccessary now because Google has no DH algorithm implementation. Thus key encryption scheme would be choosen by certificate type only: "key transport" for RSA and "key agreement" for ECC certificates.
	 */
	addRecipientByCertificate(certificate, parameters, variant)
	{
		//region Initialize encryption parameters
		const encryptionParameters = Object.assign(
			{ useOAEP: true, oaepHashAlgorithm: "SHA-512" },
			defaultEncryptionParams,
			parameters || {}
		);
		//endregion

		//region Check type of certificate
		if(certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549") !== (-1))
			variant = 1; // For the moment it is the only variant for RSA-based certificates
		else
		{
			if(certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045") !== (-1))
				variant = 2; // For the moment it is the only variant for ECC-based certificates
			else
				throw new Error(`Unknown type of certificate's public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);
		}
		//endregion

		//region Add new "recipient" depends on "variant" and certificate type
		switch(variant)
		{
			case 1: // Key transport scheme
				{
					let algorithmId;
					let algorithmParams;

					if(encryptionParameters.useOAEP === true)
					{
						//region keyEncryptionAlgorithm
						algorithmId = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({
							name: "RSA-OAEP"
						});
						if(algorithmId === "")
							throw new Error("Can not find OID for RSA-OAEP");
						//endregion

						//region RSAES-OAEP-params
						const hashOID = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({
							name: encryptionParameters.oaepHashAlgorithm
						});
						if(hashOID === "")
							throw new Error(`Unknown OAEP hash algorithm: ${encryptionParameters.oaepHashAlgorithm}`);

						const hashAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
							algorithmId: hashOID,
							algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
						});

						const rsaOAEPParams = new _RSAESOAEPParams_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
							hashAlgorithm,
							maskGenAlgorithm: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
								algorithmId: "1.2.840.113549.1.1.8", // id-mgf1
								algorithmParams: hashAlgorithm.toSchema()
							})
						});

						algorithmParams = rsaOAEPParams.toSchema();
						//endregion
					}
					else // Use old RSAES-PKCS1-v1_5 schema instead
					{
						//region keyEncryptionAlgorithm
						algorithmId = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({
							name: "RSAES-PKCS1-v1_5"
						});
						if(algorithmId === "")
							throw new Error("Can not find OID for RSAES-PKCS1-v1_5");
						//endregion

						algorithmParams = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]();
					}

					//region KeyTransRecipientInfo
					const keyInfo = new _KeyTransRecipientInfo_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
						version: 0,
						rid: new _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
							issuer: certificate.issuer,
							serialNumber: certificate.serialNumber
						}),
						keyEncryptionAlgorithm: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
							algorithmId,
							algorithmParams
						}),
						recipientCertificate: certificate
						// "encryptedKey" will be calculated in "encrypt" function
					});
					//endregion

					//region Final values for "CMS_ENVELOPED_DATA"
					this.recipientInfos.push(new _RecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
						variant: 1,
						value: keyInfo
					}));
					//endregion
				}
				break;
			case 2: // Key agreement scheme
				{
					const recipientIdentifier = new _KeyAgreeRecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
						variant: 1,
						value: new _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
							issuer: certificate.issuer,
							serialNumber: certificate.serialNumber
						})
					});
					this._addKeyAgreeRecipientInfo(
						recipientIdentifier,
						encryptionParameters,
						{recipientCertificate: certificate}
					);
				}
				break;
			default:
				throw new Error(`Unknown "variant" value: ${variant}`);
		}
		//endregion

		return true;
	}
	//**********************************************************************************
	/**
	 * Add recipient based on pre-defined data like password or KEK
	 * @param {ArrayBuffer} preDefinedData ArrayBuffer with pre-defined data
	 * @param {Object} parameters Additional parameters neccessary for "fine tunning" of encryption process
	 * @param {number} variant Variant = 1 for pre-defined "key encryption key" (KEK). Variant = 2 for password-based encryption.
	 */
	addRecipientByPreDefinedData(preDefinedData, parameters, variant)
	{
		//region Initial variables
		const encryptionParameters = parameters || {};
		//endregion

		//region Check initial parameters
		if((preDefinedData instanceof ArrayBuffer) === false)
			throw new Error("Please pass \"preDefinedData\" in ArrayBuffer type");

		if(preDefinedData.byteLength === 0)
			throw new Error("Pre-defined data could have zero length");
		//endregion

		//region Initialize encryption parameters
		if(("keyIdentifier" in encryptionParameters) === false)
		{
			const keyIdentifierBuffer = new ArrayBuffer(16);
			const keyIdentifierView = new Uint8Array(keyIdentifierBuffer);
			Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getRandomValues"])(keyIdentifierView);

			encryptionParameters.keyIdentifier = keyIdentifierBuffer;
		}

		if(("hmacHashAlgorithm" in encryptionParameters) === false)
			encryptionParameters.hmacHashAlgorithm = "SHA-512";

		if(("iterationCount" in encryptionParameters) === false)
			encryptionParameters.iterationCount = 2048;

		if(("keyEncryptionAlgorithm" in encryptionParameters) === false)
		{
			encryptionParameters.keyEncryptionAlgorithm = {
				name: "AES-KW",
				length: 256
			};
		}

		if(("keyEncryptionAlgorithmParams" in encryptionParameters) === false)
			encryptionParameters.keyEncryptionAlgorithmParams = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]();
		//endregion

		//region Add new recipient based on passed variant
		switch(variant)
		{
			case 1: // KEKRecipientInfo
				{
					//region keyEncryptionAlgorithm
					const kekOID = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])(encryptionParameters.keyEncryptionAlgorithm);
					if(kekOID === "")
						throw new Error("Incorrect value for \"keyEncryptionAlgorithm\"");
					//endregion

					//region KEKRecipientInfo
					const keyInfo = new _KEKRecipientInfo_js__WEBPACK_IMPORTED_MODULE_16__["default"]({
						version: 4,
						kekid: new _KEKIdentifier_js__WEBPACK_IMPORTED_MODULE_17__["default"]({
							keyIdentifier: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: encryptionParameters.keyIdentifier })
						}),
						keyEncryptionAlgorithm: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
							algorithmId: kekOID,
							/*
							 For AES-KW params are NULL, but for other algorithm could another situation.
							 */
							algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams
						}),
						preDefinedKEK: preDefinedData
					// "encryptedKey" would be set in "ecrypt" function
					});
					//endregion

					//region Final values for "CMS_ENVELOPED_DATA"
					this.recipientInfos.push(new _RecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
						variant: 3,
						value: keyInfo
					}));
					//endregion
				}
				break;
			case 2: // PasswordRecipientinfo
				{
					//region keyDerivationAlgorithm
					const pbkdf2OID = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({
						name: "PBKDF2"
					});
					if(pbkdf2OID === "")
						throw new Error("Can not find OID for PBKDF2");
					//endregion

					//region Salt
					const saltBuffer = new ArrayBuffer(64);
					const saltView = new Uint8Array(saltBuffer);
					Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getRandomValues"])(saltView);
					//endregion

					//region HMAC-based algorithm
					const hmacOID = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({
						name: "HMAC",
						hash: {
							name: encryptionParameters.hmacHashAlgorithm
						}
					});
					if(hmacOID === "")
						throw new Error(`Incorrect value for "hmacHashAlgorithm": ${encryptionParameters.hmacHashAlgorithm}`);
					//endregion

					//region PBKDF2-params
					const pbkdf2Params = new _PBKDF2Params_js__WEBPACK_IMPORTED_MODULE_18__["default"]({
						salt: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: saltBuffer }),
						iterationCount: encryptionParameters.iterationCount,
						prf: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
							algorithmId: hmacOID,
							algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
						})
					});
					//endregion

					//region keyEncryptionAlgorithm
					const kekOID = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])(encryptionParameters.keyEncryptionAlgorithm);
					if(kekOID === "")
						throw new Error("Incorrect value for \"keyEncryptionAlgorithm\"");
					//endregion

					//region PasswordRecipientinfo
					const keyInfo = new _PasswordRecipientinfo_js__WEBPACK_IMPORTED_MODULE_19__["default"]({
						version: 0,
						keyDerivationAlgorithm: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
							algorithmId: pbkdf2OID,
							algorithmParams: pbkdf2Params.toSchema()
						}),
						keyEncryptionAlgorithm: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
							algorithmId: kekOID,
							/*
							 For AES-KW params are NULL, but for other algorithm could be another situation.
							 */
							algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams
						}),
						password: preDefinedData
					// "encryptedKey" would be set in "ecrypt" function
					});
					//endregion

					//region Final values for "CMS_ENVELOPED_DATA"
					this.recipientInfos.push(new _RecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
						variant: 4,
						value: keyInfo
					}));
					//endregion
				}
				break;
			default:
				throw new Error(`Unknown value for "variant": ${variant}`);
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Add a "RecipientInfo" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.
	 * @param {CryptoKey} [key] Recipient's public key
	 * @param {ArrayBuffer} [keyId] The id for the recipient's public key
	 * @param {Object} [parameters] Additional parameters for "fine tuning" the encryption process
	 */
	addRecipientByKeyIdentifier(key, keyId, parameters)
	{
		//region Initialize encryption parameters
		const encryptionParameters = Object.assign({}, defaultEncryptionParams, parameters || {});
		//endregion

		const recipientIdentifier = new _KeyAgreeRecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
			variant: 2,
			value: new _RecipientKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
				subjectKeyIdentifier: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({valueHex: keyId}),
			})
		});
		this._addKeyAgreeRecipientInfo(
			recipientIdentifier,
			encryptionParameters,
			{recipientPublicKey: key}
		);
	}
	//**********************************************************************************
	/**
	 * Add a "RecipientInfo" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.
	 * @param {KeyAgreeRecipientIdentifier} [recipientIdentifier] Recipient identifier
	 * @param {Object} [encryptionParameters] Additional parameters for "fine tuning" the encryption process
	 * @param {Object} [extraRecipientInfoParams] Additional params for KeyAgreeRecipientInfo
	 */
	_addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, extraRecipientInfoParams)
	{
		//region RecipientEncryptedKey
		const encryptedKey = new _RecipientEncryptedKey_js__WEBPACK_IMPORTED_MODULE_12__["default"]({
			rid: recipientIdentifier
			// "encryptedKey" will be calculated in "encrypt" function
		});
		//endregion

		//region keyEncryptionAlgorithm
		const aesKWoid = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({
			name: "AES-KW",
			length: encryptionParameters.kekEncryptionLength
		});
		if (aesKWoid === "")
			throw new Error(`Unknown length for key encryption algorithm: ${encryptionParameters.kekEncryptionLength}`);

		const aesKW = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
			algorithmId: aesKWoid,
		});
		//endregion

		//region KeyAgreeRecipientInfo
		const ecdhOID = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({
			name: "ECDH",
			kdf: encryptionParameters.kdfAlgorithm
		});
		if (ecdhOID === "")
			throw new Error(`Unknown KDF algorithm: ${encryptionParameters.kdfAlgorithm}`);

		// In fact there is no need in so long UKM, but RFC2631
		// has requirement that "UserKeyMaterial" must be 512 bits long
		const ukmBuffer = new ArrayBuffer(64);
		const ukmView = new Uint8Array(ukmBuffer);
		Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getRandomValues"])(ukmView); // Generate random values in 64 bytes long buffer

		const recipientInfoParams = {
			version: 3,
			// "originator" will be calculated in "encrypt" function because ephemeral key would be generated there
			ukm: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({valueHex: ukmBuffer}),
			keyEncryptionAlgorithm: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
				algorithmId: ecdhOID,
				algorithmParams: aesKW.toSchema()
			}),
			recipientEncryptedKeys: new _RecipientEncryptedKeys_js__WEBPACK_IMPORTED_MODULE_15__["default"]({
				encryptedKeys: [encryptedKey]
			})
		};
		const keyInfo = new _KeyAgreeRecipientInfo_js__WEBPACK_IMPORTED_MODULE_14__["default"](Object.assign(recipientInfoParams, extraRecipientInfoParams));
		//endregion

		//region Final values for "CMS_ENVELOPED_DATA"
		this.recipientInfos.push(new _RecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
			variant: 2,
			value: keyInfo
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Create a new CMS Enveloped Data content with encrypted data
	 * @param {Object} contentEncryptionAlgorithm WebCrypto algorithm. For the moment here could be only "AES-CBC" or "AES-GCM" algorithms.
	 * @param {ArrayBuffer} contentToEncrypt Content to encrypt
	 * @returns {Promise}
	 */
	encrypt(contentEncryptionAlgorithm, contentToEncrypt)
	{
		//region Initial variables
		let sequence = Promise.resolve();

		const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long
		const ivView = new Uint8Array(ivBuffer);
		Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getRandomValues"])(ivView);

		const contentView = new Uint8Array(contentToEncrypt);

		let sessionKey;
		let encryptedContent;
		let exportedSessionKey;

		const recipientsPromises = [];

		const _this = this;
		//endregion

		//region Check for input parameters
		const contentEncryptionOID = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])(contentEncryptionAlgorithm);
		if(contentEncryptionOID === "")
			return Promise.reject("Wrong \"contentEncryptionAlgorithm\" value");
		//endregion

		//region Get a "crypto" extension
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion

		//region Generate new content encryption key
		sequence = sequence.then(() =>
			crypto.generateKey(contentEncryptionAlgorithm, true, ["encrypt"]));
		//endregion
		//region Encrypt content
		sequence = sequence.then(result =>
		{
			sessionKey = result;

			return crypto.encrypt({
				name: contentEncryptionAlgorithm.name,
				iv: ivView
			},
			sessionKey,
			contentView);
		}, error =>
			Promise.reject(error));
		//endregion
		//region Export raw content of content encryption key
		sequence = sequence.then(result =>
		{
			//region Create output OCTETSTRING with encrypted content
			encryptedContent = result;
			//endregion

			return crypto.exportKey("raw", sessionKey);
		}, error =>
			Promise.reject(error)
		).then(result =>
		{
			exportedSessionKey = result;

			return true;
		}, error =>
			Promise.reject(error));
		//endregion
		//region Append common information to CMS_ENVELOPED_DATA
		sequence = sequence.then(() =>
		{
			this.version = 2;
			this.encryptedContentInfo = new _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
				contentType: "1.2.840.113549.1.7.1", // "data"
				contentEncryptionAlgorithm: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
					algorithmId: contentEncryptionOID,
					algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: ivBuffer })
				}),
				encryptedContent: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: encryptedContent })
			});
		}, error =>
			Promise.reject(error));
		//endregion

		//region Special sub-functions to work with each recipient's type
		function SubKeyAgreeRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();

			const recipientInfo = _this.recipientInfos[index];

			let ecdhPublicKey;
			let ecdhPrivateKey;

			let recipientPublicKey;
			let recipientCurve;
			let recipientCurveLength;

			let exportedECDHPublicKey;
			//endregion

			//region Get public key and named curve from recipient's certificate or public key
			currentSequence = currentSequence.then(() =>
			{
				if (recipientInfo.value.recipientPublicKey) {
					recipientCurve = recipientInfo.value.recipientPublicKey.algorithm.namedCurve;
					return recipientInfo.value.recipientPublicKey;

				} else {
					const curveObject = recipientInfo.value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;

					if (curveObject.constructor.blockName() !== asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"].blockName())
						return Promise.reject(`Incorrect "recipientCertificate" for index ${index}`);

					const curveOID = curveObject.valueBlock.toString();

					switch (curveOID) {
						case "1.2.840.10045.3.1.7":
							recipientCurve = "P-256";
							break;
						case "1.3.132.0.34":
							recipientCurve = "P-384";
							break;
						case "1.3.132.0.35":
							recipientCurve = "P-521";
							break;
						default:
							return Promise.reject(`Incorrect curve OID for index ${index}`);
					}

					return recipientInfo.value.recipientCertificate.getPublicKey({
						algorithm: {
							algorithm: {
								name: "ECDH",
								namedCurve: recipientCurve
							},
							usages: []
						}
					});
				}
			}, error =>
				Promise.reject(error));
			//endregion

			//region Generate ephemeral ECDH key
			currentSequence = currentSequence.then(result => {
				recipientPublicKey = result;
				recipientCurveLength = curveLengthByName[recipientCurve];

				return crypto.generateKey(
					{name: "ECDH", namedCurve: recipientCurve},
					true,
					["deriveBits"]
				);
			},
			error =>
				Promise.reject(error)
			);
			//endregion
			//region Export public key of ephemeral ECDH key pair
			currentSequence = currentSequence.then(result =>
			{
				ecdhPublicKey = result.publicKey;
				ecdhPrivateKey = result.privateKey;

				return crypto.exportKey("spki", ecdhPublicKey);
			},
			error =>
				Promise.reject(error));
			//endregion

			//region Save public key of ephemeral ECDH key pair
			currentSequence = currentSequence.then(result =>
			{
				exportedECDHPublicKey = result;
			}, error =>
				Promise.reject(error));
			//endregion
			//region Create shared secret
			currentSequence = currentSequence.then(() => crypto.deriveBits({
				name: "ECDH",
				public: recipientPublicKey
			},
			ecdhPrivateKey,
			recipientCurveLength),
			error =>
				Promise.reject(error));
			//endregion

			//region Apply KDF function to shared secret
			currentSequence = currentSequence.then(
				/**
				 * @param {ArrayBuffer} result
				 */
				result =>
				{
					//region Get length of used AES-KW algorithm
					const aesKWAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: recipientInfo.value.keyEncryptionAlgorithm.algorithmParams });

					const KWalgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(aesKWAlgorithm.algorithmId);
					if(("name" in KWalgorithm) === false)
						return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);
					//endregion

					//region Translate AES-KW length to ArrayBuffer
					let kwLength = KWalgorithm.length;

					const kwLengthBuffer = new ArrayBuffer(4);
					const kwLengthView = new Uint8Array(kwLengthBuffer);

					for(let j = 3; j >= 0; j--)
					{
						kwLengthView[j] = kwLength;
						kwLength >>= 8;
					}
					//endregion

					//region Create and encode "ECC-CMS-SharedInfo" structure
					const eccInfo = new _ECCCMSSharedInfo_js__WEBPACK_IMPORTED_MODULE_20__["default"]({
						keyInfo: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
							algorithmId: aesKWAlgorithm.algorithmId
						}),
						entityUInfo: recipientInfo.value.ukm,
						suppPubInfo: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: kwLengthBuffer })
					});

					const encodedInfo = eccInfo.toSchema().toBER(false);
					//endregion

					//region Get SHA algorithm used together with ECDH
					const ecdhAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(recipientInfo.value.keyEncryptionAlgorithm.algorithmId);
					if(("name" in ecdhAlgorithm) === false)
						return Promise.reject(`Incorrect OID for key encryption algorithm: ${recipientInfo.value.keyEncryptionAlgorithm.algorithmId}`);
					//endregion

					return Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["kdf"])(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);
				},
				error =>
					Promise.reject(error));
			//endregion
			//region Import AES-KW key from result of KDF function
			currentSequence = currentSequence.then(result =>
				crypto.importKey("raw", result, { name: "AES-KW" }, true, ["wrapKey"]),
			error =>
				Promise.reject(error)
			);
			//endregion
			//region Finally wrap session key by using AES-KW algorithm
			currentSequence = currentSequence.then(result => crypto.wrapKey("raw", sessionKey, result, { name: "AES-KW" }),
				error =>
					Promise.reject(error)
			);
			//endregion
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =>
			{
				//region OriginatorIdentifierOrKey
				const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](exportedECDHPublicKey);

				const originator = new _OriginatorIdentifierOrKey_js__WEBPACK_IMPORTED_MODULE_21__["default"]();
				originator.variant = 3;
				originator.value = new _OriginatorPublicKey_js__WEBPACK_IMPORTED_MODULE_22__["default"]({ schema: asn1.result });

				recipientInfo.value.originator = originator;
				//endregion

				//region RecipientEncryptedKey
				/*
				 We will not support using of same ephemeral key for many recipients
				 */
				recipientInfo.value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: result });
				//endregion

				return {ecdhPrivateKey};
			}, error =>
				Promise.reject(error)
			);
			//endregion

			return currentSequence;
		}

		async function SubKeyTransRecipientInfo(index)
		{
			const algorithmParameters = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
			if("name" in algorithmParameters === false)
				throw new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);

			//region RSA-OAEP case
			if(algorithmParameters.name === "RSA-OAEP")
			{
				const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;
				const rsaOAEPParams = new _RSAESOAEPParams_js__WEBPACK_IMPORTED_MODULE_8__["default"]({ schema });

				algorithmParameters.hash = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(rsaOAEPParams.hashAlgorithm.algorithmId);
				if(("name" in algorithmParameters.hash) === false)
					throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
			}
			//endregion

			try
			{
				const publicKey = await _this.recipientInfos[index].value.recipientCertificate.getPublicKey({
					algorithm: {
						algorithm: algorithmParameters,
						usages: ["encrypt", "wrapKey"]
					}
				});

				const encryptedKey = await crypto.encrypt(publicKey.algorithm, publicKey, exportedSessionKey);

				//region RecipientEncryptedKey
				_this.recipientInfos[index].value.encryptedKey = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({valueHex: encryptedKey});
				//endregion
			}
			catch(ex)
			{
				const jjj = 0;
			}
		}

		function SubKEKRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			let kekAlgorithm;
			//endregion

			//region Import KEK from pre-defined data
			currentSequence = currentSequence.then(() =>
			{
				//region Get WebCrypto form of "keyEncryptionAlgorithm"
				kekAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if(("name" in kekAlgorithm) === false)
					return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
					//endregion

				return crypto.importKey("raw",
					new Uint8Array(_this.recipientInfos[index].value.preDefinedKEK),
					kekAlgorithm,
					true,
					["wrapKey"]); // Too specific for AES-KW
			}, error =>
				Promise.reject(error)
			);
			//endregion

			//region Wrap previously exported session key
			currentSequence = currentSequence.then(result =>
				crypto.wrapKey("raw", sessionKey, result, kekAlgorithm),
			error =>
				Promise.reject(error)
			);
			//endregion
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =>
			{
				//region RecipientEncryptedKey
				_this.recipientInfos[index].value.encryptedKey = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: result });
				//endregion
			}, error =>
				Promise.reject(error)
			);
			//endregion

			return currentSequence;
		}

		function SubPasswordRecipientinfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			let pbkdf2Params;
			let kekAlgorithm;
			//endregion

			//region Check that we have encoded "keyDerivationAlgorithm" plus "PBKDF2_params" in there
			currentSequence = currentSequence.then(() =>
			{
				if(("keyDerivationAlgorithm" in _this.recipientInfos[index].value) === false)
					return Promise.reject("Please append encoded \"keyDerivationAlgorithm\"");

				if(("algorithmParams" in _this.recipientInfos[index].value.keyDerivationAlgorithm) === false)
					return Promise.reject("Incorrectly encoded \"keyDerivationAlgorithm\"");

				try
				{
					pbkdf2Params = new _PBKDF2Params_js__WEBPACK_IMPORTED_MODULE_18__["default"]({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });
				}
				catch(ex)
				{
					return Promise.reject("Incorrectly encoded \"keyDerivationAlgorithm\"");
				}

				return Promise.resolve();
			}, error =>
				Promise.reject(error)
			);
			//endregion
			//region Derive PBKDF2 key from "password" buffer
			currentSequence = currentSequence.then(() =>
			{
				const passwordView = new Uint8Array(_this.recipientInfos[index].value.password);

				return crypto.importKey("raw",
					passwordView,
					"PBKDF2",
					false,
					["deriveKey"]);
			}, error =>
				Promise.reject(error)
			);
			//endregion
			//region Derive key for "keyEncryptionAlgorithm"
			currentSequence = currentSequence.then(result =>
			{
				//region Get WebCrypto form of "keyEncryptionAlgorithm"
				kekAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if(("name" in kekAlgorithm) === false)
					return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				//region Get HMAC hash algorithm
				let hmacHashAlgorithm = "SHA-1";

				if("prf" in pbkdf2Params)
				{
					const algorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(pbkdf2Params.prf.algorithmId);
					if(("name" in algorithm) === false)
						return Promise.reject("Incorrect OID for HMAC hash algorithm");

					hmacHashAlgorithm = algorithm.hash.name;
				}
				//endregion

				//region Get PBKDF2 "salt" value
				const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
				//endregion

				//region Get PBKDF2 iterations count
				const iterations = pbkdf2Params.iterationCount;
				//endregion

				return crypto.deriveKey({
					name: "PBKDF2",
					hash: {
						name: hmacHashAlgorithm
					},
					salt: saltView,
					iterations
				},
				result,
				kekAlgorithm,
				true,
				["wrapKey"]); // Usages are too specific for KEK algorithm
			}, error =>
				Promise.reject(error)
			);
			//endregion
			//region Wrap previously exported session key (Also too specific for KEK algorithm)
			currentSequence = currentSequence.then(result =>
				crypto.wrapKey("raw", sessionKey, result, kekAlgorithm),
			error =>
				Promise.reject(error)
			);
			//endregion
			//region Append all neccessary data to current CMS_RECIPIENT_INFO object
			currentSequence = currentSequence.then(result =>
			{
				//region RecipientEncryptedKey
				_this.recipientInfos[index].value.encryptedKey = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: result });
				//endregion
			}, error =>
				Promise.reject(error)
			);
			//endregion

			return currentSequence;
		}

		//endregion

		//region Create special routines for each "recipient"
		sequence = sequence.then(() =>
		{
			for(let i = 0; i < this.recipientInfos.length; i++)
			{
				//region Initial variables
				let currentSequence = Promise.resolve();
				//endregion

				switch(this.recipientInfos[i].variant)
				{
					case 1: // KeyTransRecipientInfo
						currentSequence = SubKeyTransRecipientInfo(i);
						break;
					case 2: // KeyAgreeRecipientInfo
						currentSequence = SubKeyAgreeRecipientInfo(i);
						break;
					case 3: // KEKRecipientInfo
						currentSequence = SubKEKRecipientInfo(i);
						break;
					case 4: // PasswordRecipientinfo
						currentSequence = SubPasswordRecipientinfo(i);
						break;
					default:
						return Promise.reject(`Uknown recipient type in array with index ${i}`);
				}

				recipientsPromises.push(currentSequence);
			}

			return Promise.all(recipientsPromises);
		}, error =>
			Promise.reject(error)
		);
		//endregion

		return sequence;
	}
	//**********************************************************************************
	/**
	 * Decrypt existing CMS Enveloped Data content
	 * @param {number} recipientIndex Index of recipient
	 * @param {Object} parameters Additional parameters
	 * @returns {Promise}
	 */
	decrypt(recipientIndex, parameters)
	{
		//region Initial variables
		let sequence = Promise.resolve();

		const decryptionParameters = parameters || {};

		const _this = this;
		//endregion

		//region Check for input parameters
		if((recipientIndex + 1) > this.recipientInfos.length)
			return Promise.reject(`Maximum value for "index" is: ${this.recipientInfos.length - 1}`);
		//endregion

		//region Get a "crypto" extension
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion

		//region Special sub-functions to work with each recipient's type
		function SubKeyAgreeRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();

			let recipientCurve;
			let recipientCurveLength;

			let curveOID;

			let ecdhPrivateKey;
			//endregion

			const originator = _this.recipientInfos[index].value.originator;

			//region Get "namedCurve" parameter from recipient's certificate
			currentSequence = currentSequence.then(() =>
			{
				if ("recipientCertificate" in decryptionParameters) {
					const curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;
					if(curveObject.constructor.blockName() !== asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"].blockName()) {
						return Promise.reject(`Incorrect "recipientCertificate" for index ${index}`);
					}
					curveOID = curveObject.valueBlock.toString();
				} else if ("algorithmParams" in originator.value.algorithm) {
					const curveObject = originator.value.algorithm.algorithmParams;
					if(curveObject.constructor.blockName() !== asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"].blockName()) {
						return Promise.reject(`Incorrect originator for index ${index}`);
					}
					curveOID = curveObject.valueBlock.toString();
				} else {
					return Promise.reject("Parameter \"recipientCertificate\" is mandatory for \"KeyAgreeRecipientInfo\" if algorithm params are missing from originator");
				}

				if(("recipientPrivateKey" in decryptionParameters) === false)
					return Promise.reject("Parameter \"recipientPrivateKey\" is mandatory for \"KeyAgreeRecipientInfo\"");

				switch(curveOID)
				{
					case "1.2.840.10045.3.1.7":
						recipientCurve = "P-256";
						recipientCurveLength = 256;
						break;
					case "1.3.132.0.34":
						recipientCurve = "P-384";
						recipientCurveLength = 384;
						break;
					case "1.3.132.0.35":
						recipientCurve = "P-521";
						recipientCurveLength = 528;
						break;
					default:
						return Promise.reject(`Incorrect curve OID for index ${index}`);
				}

				return crypto.importKey("pkcs8",
					decryptionParameters.recipientPrivateKey,
					{
						name: "ECDH",
						namedCurve: recipientCurve
					},
					true,
					["deriveBits"]
				);
			}, error =>
				Promise.reject(error)
			);
			//endregion
			//region Import sender's ephemeral public key
			currentSequence = currentSequence.then(result =>
			{
				ecdhPrivateKey = result;

				//region Change "OriginatorPublicKey" if "curve" parameter absent
				if(("algorithmParams" in originator.value.algorithm) === false)
					originator.value.algorithm.algorithmParams = new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: curveOID });
				//endregion

				//region Create ArrayBuffer with sender's public key
				const buffer = originator.value.toSchema().toBER(false);
				//endregion

				return crypto.importKey("spki",
					buffer,
					{
						name: "ECDH",
						namedCurve: recipientCurve
					},
					true,
					[]);
			}, error =>
				Promise.reject(error)
			);
			//endregion
			//region Create shared secret
			currentSequence = currentSequence.then(result =>
				crypto.deriveBits({
					name: "ECDH",
					public: result
				},
				ecdhPrivateKey,
				recipientCurveLength),
			error =>
				Promise.reject(error)
			);
			//endregion
			//region Apply KDF function to shared secret
			function applyKDF(includeAlgorithmParams) {
				includeAlgorithmParams = includeAlgorithmParams || false;

				//region Get length of used AES-KW algorithm
				const aesKWAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams });

				const KWalgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(aesKWAlgorithm.algorithmId);
				if(("name" in KWalgorithm) === false)
					return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);
				//endregion

				//region Translate AES-KW length to ArrayBuffer
				let kwLength = KWalgorithm.length;

				const kwLengthBuffer = new ArrayBuffer(4);
				const kwLengthView = new Uint8Array(kwLengthBuffer);

				for(let j = 3; j >= 0; j--)
				{
					kwLengthView[j] = kwLength;
					kwLength >>= 8;
				}
				//endregion

				//region Create and encode "ECC-CMS-SharedInfo" structure
				const keyInfoAlgorithm = {
					algorithmId: aesKWAlgorithm.algorithmId
				};
				if (includeAlgorithmParams) {
					keyInfoAlgorithm.algorithmParams = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]();
				}
				const eccInfo = new _ECCCMSSharedInfo_js__WEBPACK_IMPORTED_MODULE_20__["default"]({
					keyInfo: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_7__["default"](keyInfoAlgorithm),
					entityUInfo: _this.recipientInfos[index].value.ukm,
					suppPubInfo: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: kwLengthBuffer })
				});

				const encodedInfo = eccInfo.toSchema().toBER(false);
				//endregion

				//region Get SHA algorithm used together with ECDH
				const ecdhAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if(("name" in ecdhAlgorithm) === false)
					return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				return Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["kdf"])(ecdhAlgorithm.kdf, sharedSecret, KWalgorithm.length, encodedInfo);
			}
			let sharedSecret;
			currentSequence = currentSequence.then(
				/**
				 * @param {ArrayBuffer} result
				 */
				result =>
				{
					sharedSecret = result;
					return applyKDF();
				},
				error =>
					Promise.reject(error)
			);
			//endregion
			//region Import AES-KW key from result of KDF function
			function importAesKwKey(kdfResult) {
				return crypto.importKey("raw",
					kdfResult,
					{ name: "AES-KW" },
					true,
					["unwrapKey"]
				);
			}
			currentSequence = currentSequence.then(
				importAesKwKey,
				error => Promise.reject(error)
			);
			//endregion
			//region Finally unwrap session key
			function unwrapSessionKey(aesKwKey) {
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if(("name" in contentEncryptionAlgorithm) === false)
					return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
					//endregion

				return crypto.unwrapKey("raw",
					_this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex,
					aesKwKey,
					{ name: "AES-KW" },
					contentEncryptionAlgorithm,
					true,
					["decrypt"]);
			}
			currentSequence = currentSequence.then(
				result => unwrapSessionKey(result).catch(() => applyKDF(true).then(importAesKwKey).then(unwrapSessionKey)),
				error => Promise.reject(error)
			);
			//endregion

			return currentSequence;
		}

		async function SubKeyTransRecipientInfo(index)
		{
			if(("recipientPrivateKey" in decryptionParameters) === false)
				throw new Error("Parameter \"recipientPrivateKey\" is mandatory for \"KeyTransRecipientInfo\"");

			const algorithmParameters = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
			if("name" in algorithmParameters === false)
				throw new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);

			//region RSA-OAEP case
			if(algorithmParameters.name === "RSA-OAEP")
			{
				const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;
				const rsaOAEPParams = new _RSAESOAEPParams_js__WEBPACK_IMPORTED_MODULE_8__["default"]({ schema });

				algorithmParameters.hash = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(rsaOAEPParams.hashAlgorithm.algorithmId);
				if(("name" in algorithmParameters.hash) === false)
					throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);
			}
			//endregion

			const privateKey = await crypto.importKey(
				"pkcs8",
				decryptionParameters.recipientPrivateKey,
				algorithmParameters,
				true,
				["decrypt"]
			);

			const sessionKey = await crypto.decrypt(
				privateKey.algorithm,
				privateKey,
				_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex
			);

			//region Get WebCrypto form of content encryption algorithm
			const contentEncryptionAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
			if(("name" in contentEncryptionAlgorithm) === false)
				throw new Error(`Incorrect "contentEncryptionAlgorithm": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
			//endregion

			return crypto.importKey("raw",
				sessionKey,
				contentEncryptionAlgorithm,
				true,
				["decrypt"]
			);
		}

		function SubKEKRecipientInfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			let kekAlgorithm;
			//endregion

			//region Import KEK from pre-defined data
			currentSequence = currentSequence.then(() =>
			{
				if(("preDefinedData" in decryptionParameters) === false)
					return Promise.reject("Parameter \"preDefinedData\" is mandatory for \"KEKRecipientInfo\"");

				//region Get WebCrypto form of "keyEncryptionAlgorithm"
				kekAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if(("name" in kekAlgorithm) === false)
					return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				return crypto.importKey("raw",
					decryptionParameters.preDefinedData,
					kekAlgorithm,
					true,
					["unwrapKey"]); // Too specific for AES-KW
			}, error =>
				Promise.reject(error)
			);
			//endregion
			//region Unwrap previously exported session key
			currentSequence = currentSequence.then(result =>
			{
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if(("name" in contentEncryptionAlgorithm) === false)
					return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
				//endregion

				return crypto.unwrapKey("raw",
					_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex,
					result,
					kekAlgorithm,
					contentEncryptionAlgorithm,
					true,
					["decrypt"]);
			}, error =>
				Promise.reject(error)
			);
			//endregion

			return currentSequence;
		}

		function SubPasswordRecipientinfo(index)
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			let pbkdf2Params;
			let kekAlgorithm;
			//endregion

			//region Derive PBKDF2 key from "password" buffer
			currentSequence = currentSequence.then(() =>
			{
				if(("preDefinedData" in decryptionParameters) === false)
					return Promise.reject("Parameter \"preDefinedData\" is mandatory for \"KEKRecipientInfo\"");

				if(("keyDerivationAlgorithm" in _this.recipientInfos[index].value) === false)
					return Promise.reject("Please append encoded \"keyDerivationAlgorithm\"");

				if(("algorithmParams" in _this.recipientInfos[index].value.keyDerivationAlgorithm) === false)
					return Promise.reject("Incorrectly encoded \"keyDerivationAlgorithm\"");

				try
				{
					pbkdf2Params = new _PBKDF2Params_js__WEBPACK_IMPORTED_MODULE_18__["default"]({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });
				}
				catch(ex)
				{
					return Promise.reject("Incorrectly encoded \"keyDerivationAlgorithm\"");
				}

				return crypto.importKey("raw",
					decryptionParameters.preDefinedData,
					"PBKDF2",
					false,
					["deriveKey"]);
			}, error =>
				Promise.reject(error)
			);
			//endregion
			//region Derive key for "keyEncryptionAlgorithm"
			currentSequence = currentSequence.then(result =>
			{
				//region Get WebCrypto form of "keyEncryptionAlgorithm"
				kekAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);
				if(("name" in kekAlgorithm) === false)
					return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);
				//endregion

				//region Get HMAC hash algorithm
				let hmacHashAlgorithm = "SHA-1";

				if("prf" in pbkdf2Params)
				{
					const algorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(pbkdf2Params.prf.algorithmId);
					if(("name" in algorithm) === false)
						return Promise.reject("Incorrect OID for HMAC hash algorithm");

					hmacHashAlgorithm = algorithm.hash.name;
				}
				//endregion

				//region Get PBKDF2 "salt" value
				const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);
				//endregion

				//region Get PBKDF2 iterations count
				const iterations = pbkdf2Params.iterationCount;
				//endregion

				return crypto.deriveKey({
					name: "PBKDF2",
					hash: {
						name: hmacHashAlgorithm
					},
					salt: saltView,
					iterations
				},
				result,
				kekAlgorithm,
				true,
				["unwrapKey"]); // Usages are too specific for KEK algorithm
			}, error =>
				Promise.reject(error)
			);
			//endregion
			//region Unwrap previously exported session key
			currentSequence = currentSequence.then(result =>
			{
				//region Get WebCrypto form of content encryption algorithm
				const contentEncryptionAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
				if(("name" in contentEncryptionAlgorithm) === false)
					return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
					//endregion

				return crypto.unwrapKey("raw",
					_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex,
					result,
					kekAlgorithm,
					contentEncryptionAlgorithm,
					true,
					["decrypt"]);
			}, error =>
				Promise.reject(error)
			);
			//endregion

			return currentSequence;
		}

		//endregion

		//region Perform steps, specific to each type of session key encryption
		sequence = sequence.then(() =>
		{
			//region Initial variables
			let currentSequence = Promise.resolve();
			//endregion

			switch(this.recipientInfos[recipientIndex].variant)
			{
				case 1: // KeyTransRecipientInfo
					currentSequence = SubKeyTransRecipientInfo(recipientIndex);
					break;
				case 2: // KeyAgreeRecipientInfo
					currentSequence = SubKeyAgreeRecipientInfo(recipientIndex);
					break;
				case 3: // KEKRecipientInfo
					currentSequence = SubKEKRecipientInfo(recipientIndex);
					break;
				case 4: // PasswordRecipientinfo
					currentSequence = SubPasswordRecipientinfo(recipientIndex);
					break;
				default:
					return Promise.reject(`Uknown recipient type in array with index ${recipientIndex}`);
			}

			return currentSequence;
		}, error =>
			Promise.reject(error)
		);
		//endregion

		//region Finally decrypt data by session key
		sequence = sequence.then(result =>
		{
			//region Get WebCrypto form of content encryption algorithm
			const contentEncryptionAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);
			if(("name" in contentEncryptionAlgorithm) === false)
				return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);
			//endregion

			//region Get "intialization vector" for content encryption algorithm
			const ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;
			const ivView = new Uint8Array(ivBuffer);
			//endregion

			//region Create correct data block for decryption
			let dataBuffer = new ArrayBuffer(0);

			if(this.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false)
				dataBuffer = this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;
			else
			{
				for(const content of this.encryptedContentInfo.encryptedContent.valueBlock.value)
					dataBuffer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(dataBuffer, content.valueBlock.valueHex);
			}
			//endregion

			return crypto.decrypt({
				name: contentEncryptionAlgorithm.name,
				iv: ivView
			},
			result,
			dataBuffer);
		}, error =>
			Promise.reject(error)
		);
		//endregion

		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/ExtKeyUsage.js":
/*!***********************************************!*\
  !*** ./node_modules/pkijs/src/ExtKeyUsage.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ExtKeyUsage; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5280
 */
class ExtKeyUsage
{
	//**********************************************************************************
	/**
	 * Constructor for ExtKeyUsage class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<string>}
		 * @desc keyPurposes
		 */
		this.keyPurposes = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyPurposes", ExtKeyUsage.defaultValues("keyPurposes"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "keyPurposes":
				return [];
			default:
				throw new Error(`Invalid member name for ExtKeyUsage class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * ExtKeyUsage ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId
	 *
	 * KeyPurposeId ::= OBJECT IDENTIFIER
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [keyPurposes]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.keyPurposes || ""),
					value: new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"keyPurposes"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			ExtKeyUsage.schema({
				names: {
					keyPurposes: "keyPurposes"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for ExtKeyUsage");
		//endregion

		//region Get internal properties from parsed schema
		this.keyPurposes = Array.from(asn1.result.keyPurposes, element => element.valueBlock.toString());
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.keyPurposes, element => new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: element }))
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			keyPurposes: Array.from(this.keyPurposes)
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/Extension.js":
/*!*********************************************!*\
  !*** ./node_modules/pkijs/src/Extension.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Extension; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _SubjectDirectoryAttributes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SubjectDirectoryAttributes.js */ "./node_modules/pkijs/src/SubjectDirectoryAttributes.js");
/* harmony import */ var _PrivateKeyUsagePeriod_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PrivateKeyUsagePeriod.js */ "./node_modules/pkijs/src/PrivateKeyUsagePeriod.js");
/* harmony import */ var _AltName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AltName.js */ "./node_modules/pkijs/src/AltName.js");
/* harmony import */ var _BasicConstraints_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BasicConstraints.js */ "./node_modules/pkijs/src/BasicConstraints.js");
/* harmony import */ var _IssuingDistributionPoint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./IssuingDistributionPoint.js */ "./node_modules/pkijs/src/IssuingDistributionPoint.js");
/* harmony import */ var _GeneralNames_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GeneralNames.js */ "./node_modules/pkijs/src/GeneralNames.js");
/* harmony import */ var _NameConstraints_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./NameConstraints.js */ "./node_modules/pkijs/src/NameConstraints.js");
/* harmony import */ var _CRLDistributionPoints_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CRLDistributionPoints.js */ "./node_modules/pkijs/src/CRLDistributionPoints.js");
/* harmony import */ var _CertificatePolicies_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./CertificatePolicies.js */ "./node_modules/pkijs/src/CertificatePolicies.js");
/* harmony import */ var _PolicyMappings_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./PolicyMappings.js */ "./node_modules/pkijs/src/PolicyMappings.js");
/* harmony import */ var _AuthorityKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./AuthorityKeyIdentifier.js */ "./node_modules/pkijs/src/AuthorityKeyIdentifier.js");
/* harmony import */ var _PolicyConstraints_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./PolicyConstraints.js */ "./node_modules/pkijs/src/PolicyConstraints.js");
/* harmony import */ var _ExtKeyUsage_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ExtKeyUsage.js */ "./node_modules/pkijs/src/ExtKeyUsage.js");
/* harmony import */ var _InfoAccess_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./InfoAccess.js */ "./node_modules/pkijs/src/InfoAccess.js");
/* harmony import */ var _SignedCertificateTimestampList_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./SignedCertificateTimestampList.js */ "./node_modules/pkijs/src/SignedCertificateTimestampList.js");
/* harmony import */ var _CertificateTemplate_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./CertificateTemplate.js */ "./node_modules/pkijs/src/CertificateTemplate.js");
/* harmony import */ var _CAVersion_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./CAVersion.js */ "./node_modules/pkijs/src/CAVersion.js");
/* harmony import */ var _QCStatements_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./QCStatements.js */ "./node_modules/pkijs/src/QCStatements.js");




















//**************************************************************************************
/**
 * Class from RFC5280
 */
class Extension
{
	//**********************************************************************************
	/**
	 * Constructor for Extension class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc extnID
		 */
		this.extnID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "extnID", Extension.defaultValues("extnID"));
		/**
		 * @type {boolean}
		 * @desc critical
		 */
		this.critical = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "critical", Extension.defaultValues("critical"));
		/**
		 * @type {OctetString}
		 * @desc extnValue
		 */
		if("extnValue" in parameters)
			this.extnValue = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: parameters.extnValue });
		else
			this.extnValue = Extension.defaultValues("extnValue");

		if("parsedValue" in parameters)
			/**
			 * @type {Object}
			 * @desc parsedValue
			 */
			this.parsedValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "parsedValue", Extension.defaultValues("parsedValue"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "extnID":
				return "";
			case "critical":
				return false;
			case "extnValue":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "parsedValue":
				return {};
			default:
				throw new Error(`Invalid member name for Extension class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * Extension  ::=  SEQUENCE  {
	 *    extnID      OBJECT IDENTIFIER,
	 *    critical    BOOLEAN DEFAULT FALSE,
	 *    extnValue   OCTET STRING
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [extnID]
		 * @property {string} [critical]
		 * @property {string} [extnValue]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.extnID || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Boolean"]({
					name: (names.critical || ""),
					optional: true
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.extnValue || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"extnID",
			"critical",
			"extnValue"
		]);
		//endregion
		
		//region Check the schema is valid
		let asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			Extension.schema({
				names: {
					extnID: "extnID",
					critical: "critical",
					extnValue: "extnValue"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for Extension");
		//endregion

		//region Get internal properties from parsed schema
		this.extnID = asn1.result.extnID.valueBlock.toString();
		if("critical" in asn1.result)
			this.critical = asn1.result.critical.valueBlock.value;
		this.extnValue = asn1.result.extnValue;

		//region Get "parsedValue" for well-known extensions
		asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.extnValue.valueBlock.valueHex);
		if(asn1.offset === (-1))
			return;

		switch(this.extnID)
		{
			case "2.5.29.9": // SubjectDirectoryAttributes
				try
				{
					this.parsedValue = new _SubjectDirectoryAttributes_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _SubjectDirectoryAttributes_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated SubjectDirectoryAttributes";
				}
				break;
			case "2.5.29.14": // SubjectKeyIdentifier
				this.parsedValue = asn1.result; // Should be just a simple OCTETSTRING
				break;
			case "2.5.29.15": // KeyUsage
				this.parsedValue = asn1.result; // Should be just a simple BITSTRING
				break;
			case "2.5.29.16": // PrivateKeyUsagePeriod
				try
				{
					this.parsedValue = new _PrivateKeyUsagePeriod_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _PrivateKeyUsagePeriod_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated PrivateKeyUsagePeriod";
				}
				break;
			case "2.5.29.17": // SubjectAltName
			case "2.5.29.18": // IssuerAltName
				try
				{
					this.parsedValue = new _AltName_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _AltName_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated AltName";
				}
				break;
			case "2.5.29.19": // BasicConstraints
				try
				{
					this.parsedValue = new _BasicConstraints_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _BasicConstraints_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated BasicConstraints";
				}
				break;
			case "2.5.29.20": // CRLNumber
			case "2.5.29.27": // BaseCRLNumber (delta CRL indicator)
				this.parsedValue = asn1.result; // Should be just a simple INTEGER
				break;
			case "2.5.29.21": // CRLReason
				this.parsedValue = asn1.result; // Should be just a simple ENUMERATED
				break;
			case "2.5.29.24": // InvalidityDate
				this.parsedValue = asn1.result; // Should be just a simple GeneralizedTime
				break;
			case "2.5.29.28": // IssuingDistributionPoint
				try
				{
					this.parsedValue = new _IssuingDistributionPoint_js__WEBPACK_IMPORTED_MODULE_6__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _IssuingDistributionPoint_js__WEBPACK_IMPORTED_MODULE_6__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated IssuingDistributionPoint";
				}
				break;
			case "2.5.29.29": // CertificateIssuer
				try
				{
					this.parsedValue = new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: asn1.result }); // Should be just a simple
				}
				catch(ex)
				{
					this.parsedValue = new _GeneralNames_js__WEBPACK_IMPORTED_MODULE_7__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated GeneralNames";
				}
				break;
			case "2.5.29.30": // NameConstraints
				try
				{
					this.parsedValue = new _NameConstraints_js__WEBPACK_IMPORTED_MODULE_8__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _NameConstraints_js__WEBPACK_IMPORTED_MODULE_8__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated NameConstraints";
				}
				break;
			case "2.5.29.31": // CRLDistributionPoints
			case "2.5.29.46": // FreshestCRL
				try
				{
					this.parsedValue = new _CRLDistributionPoints_js__WEBPACK_IMPORTED_MODULE_9__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _CRLDistributionPoints_js__WEBPACK_IMPORTED_MODULE_9__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated CRLDistributionPoints";
				}
				break;
			case "2.5.29.32": // CertificatePolicies
			case "1.3.6.1.4.1.311.21.10": // szOID_APPLICATION_CERT_POLICIES - Microsoft-specific OID
				try
				{
					this.parsedValue = new _CertificatePolicies_js__WEBPACK_IMPORTED_MODULE_10__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _CertificatePolicies_js__WEBPACK_IMPORTED_MODULE_10__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated CertificatePolicies";
				}
				break;
			case "2.5.29.33": // PolicyMappings
				try
				{
					this.parsedValue = new _PolicyMappings_js__WEBPACK_IMPORTED_MODULE_11__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _PolicyMappings_js__WEBPACK_IMPORTED_MODULE_11__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated CertificatePolicies";
				}
				break;
			case "2.5.29.35": // AuthorityKeyIdentifier
				try
				{
					this.parsedValue = new _AuthorityKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_12__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _AuthorityKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_12__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated AuthorityKeyIdentifier";
				}
				break;
			case "2.5.29.36": // PolicyConstraints
				try
				{
					this.parsedValue = new _PolicyConstraints_js__WEBPACK_IMPORTED_MODULE_13__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _PolicyConstraints_js__WEBPACK_IMPORTED_MODULE_13__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated PolicyConstraints";
				}
				break;
			case "2.5.29.37": // ExtKeyUsage
				try
				{
					this.parsedValue = new _ExtKeyUsage_js__WEBPACK_IMPORTED_MODULE_14__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _ExtKeyUsage_js__WEBPACK_IMPORTED_MODULE_14__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated ExtKeyUsage";
				}
				break;
			case "2.5.29.54": // InhibitAnyPolicy
				this.parsedValue = asn1.result; // Should be just a simple INTEGER
				break;
			case "1.3.6.1.5.5.7.1.1": // AuthorityInfoAccess
			case "1.3.6.1.5.5.7.1.11": // SubjectInfoAccess
				try
				{
					this.parsedValue = new _InfoAccess_js__WEBPACK_IMPORTED_MODULE_15__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _InfoAccess_js__WEBPACK_IMPORTED_MODULE_15__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated InfoAccess";
				}
				break;
			case "1.3.6.1.4.1.11129.2.4.2": // SignedCertificateTimestampList
				try
				{
					this.parsedValue = new _SignedCertificateTimestampList_js__WEBPACK_IMPORTED_MODULE_16__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _SignedCertificateTimestampList_js__WEBPACK_IMPORTED_MODULE_16__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated SignedCertificateTimestampList";
				}
				break;
			case "1.3.6.1.4.1.311.20.2": // szOID_ENROLL_CERTTYPE_EXTENSION - Microsoft-specific extension
				this.parsedValue = asn1.result; // Used to be simple Unicode string
				break;
			case "1.3.6.1.4.1.311.21.2": // szOID_CERTSRV_PREVIOUS_CERT_HASH - Microsoft-specific extension
				this.parsedValue = asn1.result; // Used to be simple OctetString
				break;
			case "1.3.6.1.4.1.311.21.7": // szOID_CERTIFICATE_TEMPLATE - Microsoft-specific extension
				try
				{
					this.parsedValue = new _CertificateTemplate_js__WEBPACK_IMPORTED_MODULE_17__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _CertificateTemplate_js__WEBPACK_IMPORTED_MODULE_17__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated CertificateTemplate";
				}
				break;
			case "1.3.6.1.4.1.311.21.1": // szOID_CERTSRV_CA_VERSION - Microsoft-specific extension
				try
				{
					this.parsedValue = new _CAVersion_js__WEBPACK_IMPORTED_MODULE_18__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _CAVersion_js__WEBPACK_IMPORTED_MODULE_18__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated CAVersion";
				}
				break;
			case "1.3.6.1.5.5.7.1.3": // QCStatements
				try
				{
					this.parsedValue = new _QCStatements_js__WEBPACK_IMPORTED_MODULE_19__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					this.parsedValue = new _QCStatements_js__WEBPACK_IMPORTED_MODULE_19__["default"]();
					this.parsedValue.parsingError = "Incorrectly formated QCStatements";
				}
				break;
			default:
		}
		//endregion
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.extnID }));

		if(this.critical !== Extension.defaultValues("critical"))
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Boolean"]({ value: this.critical }));

		outputArray.push(this.extnValue);
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			extnID: this.extnID,
			extnValue: this.extnValue.toJSON()
		};

		if(this.critical !== Extension.defaultValues("critical"))
			object.critical = this.critical;

		if("parsedValue" in this)
		{
			if("toJSON" in this.parsedValue)
				object.parsedValue = this.parsedValue.toJSON();
		}

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/Extensions.js":
/*!**********************************************!*\
  !*** ./node_modules/pkijs/src/Extensions.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Extensions; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/pkijs/src/Extension.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class Extensions
{
	//**********************************************************************************
	/**
	 * Constructor for Extensions class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<Extension>}
		 * @desc type
		 */
		this.extensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "extensions", Extensions.defaultValues("extensions"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "extensions":
				return [];
			default:
				throw new Error(`Invalid member name for Extensions class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @param {boolean} optional Flag that current schema should be optional
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {}, optional = false)
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [extensions]
		 * @property {string} [extension]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			optional,
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.extensions || ""),
					value: _Extension_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.extension || {})
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"extensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			Extensions.schema({
				names: {
					extensions: "extensions"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for Extensions");
		//endregion

		//region Get internal properties from parsed schema
		this.extensions = Array.from(asn1.result.extensions, element => new _Extension_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.extensions, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			extensions: Array.from(this.extensions, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/GeneralName.js":
/*!***********************************************!*\
  !*** ./node_modules/pkijs/src/GeneralName.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GeneralName; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");



//**************************************************************************************
//region Additional asn1js schema elements existing inside GeneralName schema
//**************************************************************************************
/**
 * Schema for "builtInStandardAttributes" of "ORAddress"
 * @param {Object} parameters
 * @property {Object} [names]
 * @param {boolean} optional
 * @returns {Sequence}
 */
function builtInStandardAttributes(parameters = {}, optional = false)
{
	//builtInStandardAttributes ::= Sequence {
	//    country-name                  CountryName OPTIONAL,
	//    administration-domain-name    AdministrationDomainName OPTIONAL,
	//    network-address           [0] IMPLICIT NetworkAddress OPTIONAL,
	//    terminal-identifier       [1] IMPLICIT TerminalIdentifier OPTIONAL,
	//    private-domain-name       [2] PrivateDomainName OPTIONAL,
	//    organization-name         [3] IMPLICIT OrganizationName OPTIONAL,
	//    numeric-user-identifier   [4] IMPLICIT NumericUserIdentifier OPTIONAL,
	//    personal-name             [5] IMPLICIT PersonalName OPTIONAL,
	//    organizational-unit-names [6] IMPLICIT OrganizationalUnitNames OPTIONAL }

	/**
	 * @type {Object}
	 * @property {string} [country_name]
	 * @property {string} [administration_domain_name]
	 * @property {string} [network_address]
	 * @property {string} [terminal_identifier]
	 * @property {string} [private_domain_name]
	 * @property {string} [organization_name]
	 * @property {string} [numeric_user_identifier]
	 * @property {string} [personal_name]
	 * @property {string} [organizational_unit_names]
	 */
	const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

	return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
		optional,
		value: [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 2, // APPLICATION-SPECIFIC
					tagNumber: 1 // [1]
				},
				name: (names.country_name || ""),
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
						value: [
							new asn1js__WEBPACK_IMPORTED_MODULE_0__["NumericString"](),
							new asn1js__WEBPACK_IMPORTED_MODULE_0__["PrintableString"]()
						]
					})
				]
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 2, // APPLICATION-SPECIFIC
					tagNumber: 2 // [2]
				},
				name: (names.administration_domain_name || ""),
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
						value: [
							new asn1js__WEBPACK_IMPORTED_MODULE_0__["NumericString"](),
							new asn1js__WEBPACK_IMPORTED_MODULE_0__["PrintableString"]()
						]
					})
				]
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				name: (names.network_address || ""),
				isHexOnly: true
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				name: (names.terminal_identifier || ""),
				isHexOnly: true
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 2 // [2]
				},
				name: (names.private_domain_name || ""),
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
						value: [
							new asn1js__WEBPACK_IMPORTED_MODULE_0__["NumericString"](),
							new asn1js__WEBPACK_IMPORTED_MODULE_0__["PrintableString"]()
						]
					})
				]
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 3 // [3]
				},
				name: (names.organization_name || ""),
				isHexOnly: true
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				optional: true,
				name: (names.numeric_user_identifier || ""),
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 4 // [4]
				},
				isHexOnly: true
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				name: (names.personal_name || ""),
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 5 // [5]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 0 // [0]
						},
						isHexOnly: true
					}),
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 1 // [1]
						},
						isHexOnly: true
					}),
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 2 // [2]
						},
						isHexOnly: true
					}),
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
						optional: true,
						idBlock: {
							tagClass: 3, // CONTEXT-SPECIFIC
							tagNumber: 3 // [3]
						},
						isHexOnly: true
					})
				]
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				name: (names.organizational_unit_names || ""),
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 6 // [6]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
						value: new asn1js__WEBPACK_IMPORTED_MODULE_0__["PrintableString"]()
					})
				]
			})
		]
	}));
}
//**************************************************************************************
/**
 * Schema for "builtInDomainDefinedAttributes" of "ORAddress"
 * @param {boolean} optional
 * @returns {Sequence}
 */
function builtInDomainDefinedAttributes(optional = false)
{
	return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
		optional,
		value: [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["PrintableString"](),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["PrintableString"]()
		]
	}));
}
//**************************************************************************************
/**
 * Schema for "builtInDomainDefinedAttributes" of "ORAddress"
 * @param {boolean} optional
 * @returns {Set}
 */
function extensionAttributes(optional = false)
{
	return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
		optional,
		value: [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				isHexOnly: true
			}),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]()]
			})
		]
	}));
}
//**************************************************************************************
//endregion
//**************************************************************************************
/**
 * Class from RFC5280
 */
class GeneralName
{
	//**********************************************************************************
	/**
	 * Constructor for GeneralName class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 * @property {number} [type] value type - from a tagged value (0 for "otherName", 1 for "rfc822Name" etc.)
	 * @property {Object} [value] asn1js object having GeneralName value (type depends on "type" value)
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc value type - from a tagged value (0 for "otherName", 1 for "rfc822Name" etc.)
		 */
		this.type = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "type", GeneralName.defaultValues("type"));
		/**
		 * @type {Object}
		 * @desc asn1js object having GeneralName value (type depends on "type" value)
		 */
		this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "value", GeneralName.defaultValues("value"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "type":
				return 9;
			case "value":
				return {};
			default:
				throw new Error(`Invalid member name for GeneralName class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "type":
				return (memberValue === GeneralName.defaultValues(memberName));
			case "value":
				return (Object.keys(memberValue).length === 0);
			default:
				throw new Error(`Invalid member name for GeneralName class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * GeneralName ::= Choice {
	 *    otherName                       [0]     OtherName,
	 *    rfc822Name                      [1]     IA5String,
	 *    dNSName                         [2]     IA5String,
	 *    x400Address                     [3]     ORAddress,
	 *    directoryName                   [4]     value,
	 *    ediPartyName                    [5]     EDIPartyName,
	 *    uniformResourceIdentifier       [6]     IA5String,
	 *    iPAddress                       [7]     OCTET STRING,
	 *    registeredID                    [8]     OBJECT IDENTIFIER }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {Object} [directoryName]
		 * @property {Object} [builtInStandardAttributes]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					name: (names.blockName || ""),
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"](),
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 0 // [0]
							},
							value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]()]
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 3 // [3]
					},
					name: (names.blockName || ""),
					value: [
						builtInStandardAttributes((names.builtInStandardAttributes || {}), false),
						builtInDomainDefinedAttributes(true),
						extensionAttributes(true)
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 4 // [4]
					},
					name: (names.blockName || ""),
					value: [_RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.directoryName || {})]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 5 // [5]
					},
					name: (names.blockName || ""),
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							optional: true,
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 0 // [0]
							},
							value: [
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
									value: [
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["TeletexString"](),
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["PrintableString"](),
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["UniversalString"](),
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["Utf8String"](),
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["BmpString"]()
									]
								})
							]
						}),
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 1 // [1]
							},
							value: [
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
									value: [
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["TeletexString"](),
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["PrintableString"](),
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["UniversalString"](),
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["Utf8String"](),
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["BmpString"]()
									]
								})
							]
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 6 // [6]
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 7 // [7]
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 8 // [8]
					}
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"blockName",
			"otherName",
			"rfc822Name",
			"dNSName",
			"x400Address",
			"directoryName",
			"ediPartyName",
			"uniformResourceIdentifier",
			"iPAddress",
			"registeredID"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			GeneralName.schema({
				names: {
					blockName: "blockName",
					otherName: "otherName",
					rfc822Name: "rfc822Name",
					dNSName: "dNSName",
					x400Address: "x400Address",
					directoryName: {
						names: {
							blockName: "directoryName"
						}
					},
					ediPartyName: "ediPartyName",
					uniformResourceIdentifier: "uniformResourceIdentifier",
					iPAddress: "iPAddress",
					registeredID: "registeredID"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for GeneralName");
		//endregion

		//region Get internal properties from parsed schema
		this.type = asn1.result.blockName.idBlock.tagNumber;

		switch(this.type)
		{
			case 0: // otherName
				this.value = asn1.result.blockName;
				break;
			case 1: // rfc822Name + dNSName + uniformResourceIdentifier
			case 2:
			case 6:
				{
					const value = asn1.result.blockName;

					value.idBlock.tagClass = 1; // UNIVERSAL
					value.idBlock.tagNumber = 22; // IA5STRING

					const valueBER = value.toBER(false);

					this.value = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](valueBER).result.valueBlock.value;
				}
				break;
			case 3: // x400Address
				this.value = asn1.result.blockName;
				break;
			case 4: // directoryName
				this.value = new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.directoryName });
				break;
			case 5: // ediPartyName
				this.value = asn1.result.ediPartyName;
				break;
			case 7: // iPAddress
				this.value = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: asn1.result.blockName.valueBlock.valueHex });
				break;
			case 8: // registeredID
				{
					const value = asn1.result.blockName;

					value.idBlock.tagClass = 1; // UNIVERSAL
					value.idBlock.tagNumber = 6; // ObjectIdentifier

					const valueBER = value.toBER(false);

					this.value = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](valueBER).result.valueBlock.toString(); // Getting a string representation of the ObjectIdentifier
				}
				break;
			default:
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		switch(this.type)
		{
			case 0:
			case 3:
			case 5:
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: this.type
					},
					value: [
						this.value
					]
				});
			case 1:
			case 2:
			case 6:
				{
					const value = new asn1js__WEBPACK_IMPORTED_MODULE_0__["IA5String"]({ value: this.value });

					value.idBlock.tagClass = 3;
					value.idBlock.tagNumber = this.type;

					return value;
				}
			case 4:
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 4
					},
					value: [this.value.toSchema()]
				});
			case 7:
				{
					const value = this.value;

					value.idBlock.tagClass = 3;
					value.idBlock.tagNumber = this.type;

					return value;
				}
			case 8:
				{
					const value = new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.value });

					value.idBlock.tagClass = 3;
					value.idBlock.tagNumber = this.type;

					return value;
				}
			default:
				return GeneralName.schema();
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			type: this.type,
			value: ""
		};

		if((typeof this.value) === "string")
			_object.value = this.value;
		else
		{
			try
			{
				_object.value = this.value.toJSON();
			}
			catch(ex){}
		}

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/GeneralNames.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/GeneralNames.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GeneralNames; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class GeneralNames
{
	//**********************************************************************************
	/**
	 * Constructor for GeneralNames class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<GeneralName>}
		 * @desc Array of "general names"
		 */
		this.names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", GeneralNames.defaultValues("names"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "names":
				return [];
			default:
				throw new Error(`Invalid member name for GeneralNames class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @param {boolean} [optional=false] Flag would be element optional or not
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {}, optional = false)
	{
		/**
		 * @type {Object}
		 * @property {string} utcTimeName Name for "utcTimeName" choice
		 * @property {string} generalTimeName Name for "generalTimeName" choice
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			optional,
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.generalNames || ""),
					value: _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"names",
			"generalNames"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			GeneralNames.schema({
				names: {
					blockName: "names",
					generalNames: "generalNames"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for GeneralNames");
		//endregion

		//region Get internal properties from parsed schema
		this.names = Array.from(asn1.result.generalNames, element => new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.names, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			names: Array.from(this.names, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/GeneralSubtree.js":
/*!**************************************************!*\
  !*** ./node_modules/pkijs/src/GeneralSubtree.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GeneralSubtree; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class GeneralSubtree
{
	//**********************************************************************************
	/**
	 * Constructor for GeneralSubtree class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {GeneralName}
		 * @desc base
		 */
		this.base = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "base", GeneralSubtree.defaultValues("base"));

		/**
		 * @type {number|Integer}
		 * @desc base
		 */
		this.minimum = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "minimum", GeneralSubtree.defaultValues("minimum"));

		if("maximum" in parameters)
			/**
			 * @type {number|Integer}
			 * @desc minimum
			 */
			this.maximum = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "maximum", GeneralSubtree.defaultValues("maximum"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "base":
				return new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "minimum":
				return 0;
			case "maximum":
				return 0;
			default:
				throw new Error(`Invalid member name for GeneralSubtree class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * GeneralSubtree ::= SEQUENCE {
	 *    base                    GeneralName,
	 *    minimum         [0]     BaseDistance DEFAULT 0,
	 *    maximum         [1]     BaseDistance OPTIONAL }
	 *
	 * BaseDistance ::= INTEGER (0..MAX)
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [base]
		 * @property {string} [minimum]
		 * @property {string} [maximum]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.base || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.minimum || "") })]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.maximum || "") })]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"base",
			"minimum",
			"maximum"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			GeneralSubtree.schema({
				names: {
					base: {
						names: {
							blockName: "base"
						}
					},
					minimum: "minimum",
					maximum: "maximum"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for GeneralSubtree");
		//endregion

		//region Get internal properties from parsed schema
		this.base = new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.base });

		if("minimum" in asn1.result)
		{
			if(asn1.result.minimum.valueBlock.isHexOnly)
				this.minimum = asn1.result.minimum;
			else
				this.minimum = asn1.result.minimum.valueBlock.valueDec;
		}

		if("maximum" in asn1.result)
		{
			if(asn1.result.maximum.valueBlock.isHexOnly)
				this.maximum = asn1.result.maximum;
			else
				this.maximum = asn1.result.maximum.valueBlock.valueDec;
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		outputArray.push(this.base.toSchema());
		
		if(this.minimum !== 0)
		{
			let valueMinimum = 0;
			
			if(this.minimum instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"])
				valueMinimum = this.minimum;
			else
				valueMinimum = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.minimum });
			
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [valueMinimum]
			}));
		}
		
		if("maximum" in this)
		{
			let valueMaximum = 0;
			
			if(this.maximum instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"])
				valueMaximum = this.maximum;
			else
				valueMaximum = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.maximum });
			
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: [valueMaximum]
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			base: this.base.toJSON()
		};
		
		if(this.minimum !== 0)
		{
			if((typeof this.minimum) === "number")
				object.minimum = this.minimum;
			else
				object.minimum = this.minimum.toJSON();
		}
		
		if("maximum" in this)
		{
			if((typeof this.maximum) === "number")
				object.maximum = this.maximum;
			else
				object.maximum = this.maximum.toJSON();
		}
		
		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/InfoAccess.js":
/*!**********************************************!*\
  !*** ./node_modules/pkijs/src/InfoAccess.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InfoAccess; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AccessDescription_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AccessDescription.js */ "./node_modules/pkijs/src/AccessDescription.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class InfoAccess
{
	//**********************************************************************************
	/**
	 * Constructor for InfoAccess class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<AccessDescription>}
		 * @desc accessDescriptions
		 */
		this.accessDescriptions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "accessDescriptions", InfoAccess.defaultValues("accessDescriptions"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "accessDescriptions":
				return [];
			default:
				throw new Error(`Invalid member name for InfoAccess class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * AuthorityInfoAccessSyntax  ::=
	 * SEQUENCE SIZE (1..MAX) OF AccessDescription
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [accessDescriptions]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.accessDescriptions || ""),
					value: _AccessDescription_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"accessDescriptions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			InfoAccess.schema({
				names: {
					accessDescriptions: "accessDescriptions"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for InfoAccess");
		//endregion

		//region Get internal properties from parsed schema
		this.accessDescriptions = Array.from(asn1.result.accessDescriptions, element => new _AccessDescription_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.accessDescriptions, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			accessDescriptions: Array.from(this.accessDescriptions, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/IssuerAndSerialNumber.js":
/*!*********************************************************!*\
  !*** ./node_modules/pkijs/src/IssuerAndSerialNumber.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IssuerAndSerialNumber; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class IssuerAndSerialNumber
{
	//**********************************************************************************
	/**
	 * Constructor for IssuerAndSerialNumber class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {RelativeDistinguishedNames}
		 * @desc issuer
		 */
		this.issuer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuer", IssuerAndSerialNumber.defaultValues("issuer"));
		/**
		 * @type {Integer}
		 * @desc serialNumber
		 */
		this.serialNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "serialNumber", IssuerAndSerialNumber.defaultValues("serialNumber"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "issuer":
				return new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "serialNumber":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			default:
				throw new Error(`Invalid member name for IssuerAndSerialNumber class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * IssuerAndSerialNumber ::= SEQUENCE {
	 *    issuer Name,
	 *    serialNumber CertificateSerialNumber }
	 *
	 * CertificateSerialNumber ::= INTEGER
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [issuer]
		 * @property {string} [serialNumber]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.issuer || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.serialNumber || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"issuer",
			"serialNumber"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			IssuerAndSerialNumber.schema({
				names: {
					issuer: {
						names: {
							blockName: "issuer"
						}
					},
					serialNumber: "serialNumber"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for IssuerAndSerialNumber");
		//endregion

		//region Get internal properties from parsed schema
		this.issuer = new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.issuer });
		this.serialNumber = asn1.result.serialNumber;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.issuer.toSchema(),
				this.serialNumber
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			issuer: this.issuer.toJSON(),
			serialNumber: this.serialNumber.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/IssuingDistributionPoint.js":
/*!************************************************************!*\
  !*** ./node_modules/pkijs/src/IssuingDistributionPoint.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IssuingDistributionPoint; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");
/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");




//**************************************************************************************
/**
 * Class from RFC5280
 */
class IssuingDistributionPoint
{
	//**********************************************************************************
	/**
	 * Constructor for IssuingDistributionPoint class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("distributionPoint" in parameters)
			/**
			 * @type {Array.<GeneralName>|RelativeDistinguishedNames}
			 * @desc distributionPoint
			 */
			this.distributionPoint = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "distributionPoint", IssuingDistributionPoint.defaultValues("distributionPoint"));

		/**
		 * @type {boolean}
		 * @desc onlyContainsUserCerts
		 */
		this.onlyContainsUserCerts = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "onlyContainsUserCerts", IssuingDistributionPoint.defaultValues("onlyContainsUserCerts"));

		/**
		 * @type {boolean}
		 * @desc onlyContainsCACerts
		 */
		this.onlyContainsCACerts = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "onlyContainsCACerts", IssuingDistributionPoint.defaultValues("onlyContainsCACerts"));

		if("onlySomeReasons" in parameters)
			/**
			 * @type {number}
			 * @desc onlySomeReasons
			 */
			this.onlySomeReasons = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "onlySomeReasons", IssuingDistributionPoint.defaultValues("onlySomeReasons"));

		/**
		 * @type {boolean}
		 * @desc indirectCRL
		 */
		this.indirectCRL = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "indirectCRL", IssuingDistributionPoint.defaultValues("indirectCRL"));

		/**
		 * @type {boolean}
		 * @desc onlyContainsAttributeCerts
		 */
		this.onlyContainsAttributeCerts = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "onlyContainsAttributeCerts", IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "distributionPoint":
				return [];
			case "onlyContainsUserCerts":
				return false;
			case "onlyContainsCACerts":
				return false;
			case "onlySomeReasons":
				return 0;
			case "indirectCRL":
				return false;
			case "onlyContainsAttributeCerts":
				return false;
			default:
				throw new Error(`Invalid member name for IssuingDistributionPoint class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * IssuingDistributionPoint ::= SEQUENCE {
	 *    distributionPoint          [0] DistributionPointName OPTIONAL,
	 *    onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE,
	 *    onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE,
	 *    onlySomeReasons            [3] ReasonFlags OPTIONAL,
	 *    indirectCRL                [4] BOOLEAN DEFAULT FALSE,
	 *    onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
	 *
	 * ReasonFlags ::= BIT STRING {
	 *    unused                  (0),
	 *    keyCompromise           (1),
	 *    cACompromise            (2),
	 *    affiliationChanged      (3),
	 *    superseded              (4),
	 *    cessationOfOperation    (5),
	 *    certificateHold         (6),
	 *    privilegeWithdrawn      (7),
	 *    aACompromise            (8) }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [distributionPoint]
		 * @property {string} [distributionPointNames]
		 * @property {string} [onlyContainsUserCerts]
		 * @property {string} [onlyContainsCACerts]
		 * @property {string} [onlySomeReasons]
		 * @property {string} [indirectCRL]
		 * @property {string} [onlyContainsAttributeCerts]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
							value: [
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
									name: (names.distributionPoint || ""),
									idBlock: {
										tagClass: 3, // CONTEXT-SPECIFIC
										tagNumber: 0 // [0]
									},
									value: [
										new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
											name: (names.distributionPointNames || ""),
											value: _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
										})
									]
								}),
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
									name: (names.distributionPoint || ""),
									idBlock: {
										tagClass: 3, // CONTEXT-SPECIFIC
										tagNumber: 1 // [1]
									},
									value: _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema().valueBlock.value
								})
							]
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.onlyContainsUserCerts || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					}
				}), // IMPLICIT boolean value
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.onlyContainsCACerts || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					}
				}), // IMPLICIT boolean value
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.onlySomeReasons || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 3 // [3]
					}
				}), // IMPLICIT bitstring value
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.indirectCRL || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 4 // [4]
					}
				}), // IMPLICIT boolean value
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.onlyContainsAttributeCerts || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 5 // [5]
					}
				}) // IMPLICIT boolean value
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"distributionPoint",
			"distributionPointNames",
			"onlyContainsUserCerts",
			"onlyContainsCACerts",
			"onlySomeReasons",
			"indirectCRL",
			"onlyContainsAttributeCerts"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			IssuingDistributionPoint.schema({
				names: {
					distributionPoint: "distributionPoint",
					distributionPointNames: "distributionPointNames",
					onlyContainsUserCerts: "onlyContainsUserCerts",
					onlyContainsCACerts: "onlyContainsCACerts",
					onlySomeReasons: "onlySomeReasons",
					indirectCRL: "indirectCRL",
					onlyContainsAttributeCerts: "onlyContainsAttributeCerts"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");
		//endregion
		
		//region Get internal properties from parsed schema
		if("distributionPoint" in asn1.result)
		{
			switch(true)
			{
				case (asn1.result.distributionPoint.idBlock.tagNumber === 0): // GENERAL_NAMES variant
					this.distributionPoint = Array.from(asn1.result.distributionPointNames, element => new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
					break;
				case (asn1.result.distributionPoint.idBlock.tagNumber === 1): // RDN variant
					{
						this.distributionPoint = new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
							schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
								value: asn1.result.distributionPoint.valueBlock.value
							})
						});
					}
					break;
				default:
					throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}");
			}
		}
		
		if("onlyContainsUserCerts" in asn1.result)
		{
			const view = new Uint8Array(asn1.result.onlyContainsUserCerts.valueBlock.valueHex);
			this.onlyContainsUserCerts = (view[0] !== 0x00);
		}
		
		if("onlyContainsCACerts" in asn1.result)
		{
			const view = new Uint8Array(asn1.result.onlyContainsCACerts.valueBlock.valueHex);
			this.onlyContainsCACerts = (view[0] !== 0x00);
		}
		
		if("onlySomeReasons" in asn1.result)
		{
			const view = new Uint8Array(asn1.result.onlySomeReasons.valueBlock.valueHex);
			this.onlySomeReasons = view[0];
		}
		
		if("indirectCRL" in asn1.result)
		{
			const view = new Uint8Array(asn1.result.indirectCRL.valueBlock.valueHex);
			this.indirectCRL = (view[0] !== 0x00);
		}
		
		if("onlyContainsAttributeCerts" in asn1.result)
		{
			const view = new Uint8Array(asn1.result.onlyContainsAttributeCerts.valueBlock.valueHex);
			this.onlyContainsAttributeCerts = (view[0] !== 0x00);
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if("distributionPoint" in this)
		{
			let value;
			
			if(this.distributionPoint instanceof Array)
			{
				value = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: Array.from(this.distributionPoint, element => element.toSchema())
				});
			}
			else
			{
				value = this.distributionPoint.toSchema();
				
				value.idBlock.tagClass = 3; // CONTEXT - SPECIFIC
				value.idBlock.tagNumber = 1; // [1]
			}
			
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [value]
			}));
		}
		
		if(this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues("onlyContainsUserCerts"))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				valueHex: (new Uint8Array([0xFF])).buffer
			}));
		}
		
		if(this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues("onlyContainsCACerts"))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 2 // [2]
				},
				valueHex: (new Uint8Array([0xFF])).buffer
			}));
		}
		
		if("onlySomeReasons" in this)
		{
			const buffer = new ArrayBuffer(1);
			const view = new Uint8Array(buffer);
			
			view[0] = this.onlySomeReasons;
			
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 3 // [3]
				},
				valueHex: buffer
			}));
		}
		
		if(this.indirectCRL !== IssuingDistributionPoint.defaultValues("indirectCRL"))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 4 // [4]
				},
				valueHex: (new Uint8Array([0xFF])).buffer
			}));
		}
		
		if(this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts"))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 5 // [5]
				},
				valueHex: (new Uint8Array([0xFF])).buffer
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};
		
		if("distributionPoint" in this)
		{
			if(this.distributionPoint instanceof Array)
				object.distributionPoint = Array.from(this.distributionPoint, element => element.toJSON());
			else
				object.distributionPoint = this.distributionPoint.toJSON();
		}
		
		if(this.onlyContainsUserCerts !== IssuingDistributionPoint.defaultValues("onlyContainsUserCerts"))
			object.onlyContainsUserCerts = this.onlyContainsUserCerts;
		
		if(this.onlyContainsCACerts !== IssuingDistributionPoint.defaultValues("onlyContainsCACerts"))
			object.onlyContainsCACerts = this.onlyContainsCACerts;
		
		if("onlySomeReasons" in this)
			object.onlySomeReasons = this.onlySomeReasons;
		
		if(this.indirectCRL !== IssuingDistributionPoint.defaultValues("indirectCRL"))
			object.indirectCRL = this.indirectCRL;
		
		if(this.onlyContainsAttributeCerts !== IssuingDistributionPoint.defaultValues("onlyContainsAttributeCerts"))
			object.onlyContainsAttributeCerts = this.onlyContainsAttributeCerts;
		
		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/KEKIdentifier.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/KEKIdentifier.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KEKIdentifier; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OtherKeyAttribute.js */ "./node_modules/pkijs/src/OtherKeyAttribute.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class KEKIdentifier
{
	//**********************************************************************************
	/**
	 * Constructor for KEKIdentifier class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {OctetString}
		 * @desc keyIdentifier
		 */
		this.keyIdentifier = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyIdentifier", KEKIdentifier.defaultValues("keyIdentifier"));

		if("date" in parameters)
			/**
			 * @type {GeneralizedTime}
			 * @desc date
			 */
			this.date = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "date", KEKIdentifier.defaultValues("date"));
		if("other" in parameters)
			/**
			 * @type {OtherKeyAttribute}
			 * @desc other
			 */
			this.other = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "other", KEKIdentifier.defaultValues("other"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "keyIdentifier":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "date":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]();
			case "other":
				return new _OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			default:
				throw new Error(`Invalid member name for KEKIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "keyIdentifier":
				return (memberValue.isEqual(KEKIdentifier.defaultValues("keyIdentifier")));
			case "date":
				// noinspection OverlyComplexBooleanExpressionJS
				return ((memberValue.year === 0) &&
						(memberValue.month === 0) &&
						(memberValue.day === 0) &&
						(memberValue.hour === 0) &&
						(memberValue.minute === 0) &&
						(memberValue.second === 0) &&
						(memberValue.millisecond === 0));
			case "other":
				return ((memberValue.compareWithDefault("keyAttrId", memberValue.keyAttrId)) &&
						(("keyAttr" in memberValue) === false));
			default:
				throw new Error(`Invalid member name for KEKIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * KEKIdentifier ::= SEQUENCE {
	 *    keyIdentifier OCTET STRING,
	 *    date GeneralizedTime OPTIONAL,
	 *    other OtherKeyAttribute OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [keyIdentifier]
		 * @property {string} [date]
		 * @property {string} [other]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.keyIdentifier || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({
					optional: true,
					name: (names.date || "")
				}),
				_OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.other || {})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"keyIdentifier",
			"date",
			"other"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			KEKIdentifier.schema({
				names: {
					keyIdentifier: "keyIdentifier",
					date: "date",
					other: {
						names: {
							blockName: "other"
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for KEKIdentifier");
		//endregion

		//region Get internal properties from parsed schema
		this.keyIdentifier = asn1.result.keyIdentifier;

		if("date" in asn1.result)
			this.date = asn1.result.date;

		if("other" in asn1.result)
			this.other = new _OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.other });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(this.keyIdentifier);

		if("date" in this)
			outputArray.push(this.date);

		if("other" in this)
			outputArray.push(this.other.toSchema());
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			keyIdentifier: this.keyIdentifier.toJSON()
		};

		if("date" in this)
			_object.date = this.date;

		if("other" in this)
			_object.other = this.other.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/KEKRecipientInfo.js":
/*!****************************************************!*\
  !*** ./node_modules/pkijs/src/KEKRecipientInfo.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KEKRecipientInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _KEKIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KEKIdentifier.js */ "./node_modules/pkijs/src/KEKIdentifier.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");




//**************************************************************************************
/**
 * Class from RFC5652
 */
class KEKRecipientInfo
{
	//**********************************************************************************
	/**
	 * Constructor for KEKRecipientInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", KEKRecipientInfo.defaultValues("version"));
		/**
		 * @type {KEKIdentifier}
		 * @desc kekid
		 */
		this.kekid = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "kekid", KEKRecipientInfo.defaultValues("kekid"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc keyEncryptionAlgorithm
		 */
		this.keyEncryptionAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyEncryptionAlgorithm", KEKRecipientInfo.defaultValues("keyEncryptionAlgorithm"));
		/**
		 * @type {OctetString}
		 * @desc encryptedKey
		 */
		this.encryptedKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptedKey", KEKRecipientInfo.defaultValues("encryptedKey"));
		/**
		 * @type {ArrayBuffer}
		 * @desc preDefinedKEK KEK using to encrypt CEK
		 */
		this.preDefinedKEK = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "preDefinedKEK", KEKRecipientInfo.defaultValues("preDefinedKEK"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "kekid":
				return new _KEKIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "keyEncryptionAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "encryptedKey":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "preDefinedKEK":
				return new ArrayBuffer(0);
			default:
				throw new Error(`Invalid member name for KEKRecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "KEKRecipientInfo":
				return (memberValue === KEKRecipientInfo.defaultValues("version"));
			case "kekid":
				return ((memberValue.compareWithDefault("keyIdentifier", memberValue.keyIdentifier)) &&
						(("date" in memberValue) === false) &&
						(("other" in memberValue) === false));
			case "keyEncryptionAlgorithm":
				return ((memberValue.algorithmId === "") && (("algorithmParams" in memberValue) === false));
			case "encryptedKey":
				return (memberValue.isEqual(KEKRecipientInfo.defaultValues("encryptedKey")));
			case "preDefinedKEK":
				return (memberValue.byteLength === 0);
			default:
				throw new Error(`Invalid member name for KEKRecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * KEKRecipientInfo ::= SEQUENCE {
	 *    version CMSVersion,  -- always set to 4
	 *    kekid KEKIdentifier,
	 *    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
	 *    encryptedKey EncryptedKey }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [kekid]
		 * @property {string} [keyEncryptionAlgorithm]
		 * @property {string} [encryptedKey]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				_KEKIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.kekid || {}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.keyEncryptionAlgorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.encryptedKey || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"kekid",
			"keyEncryptionAlgorithm",
			"encryptedKey"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			KEKRecipientInfo.schema({
				names: {
					version: "version",
					kekid: {
						names: {
							blockName: "kekid"
						}
					},
					keyEncryptionAlgorithm: {
						names: {
							blockName: "keyEncryptionAlgorithm"
						}
					},
					encryptedKey: "encryptedKey"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for KEKRecipientInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.kekid = new _KEKIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.kekid });
		this.keyEncryptionAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.keyEncryptionAlgorithm });
		this.encryptedKey = asn1.result.encryptedKey;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }),
				this.kekid.toSchema(),
				this.keyEncryptionAlgorithm.toSchema(),
				this.encryptedKey
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			version: this.version,
			kekid: this.kekid.toJSON(),
			keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
			encryptedKey: this.encryptedKey.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/KeyAgreeRecipientIdentifier.js":
/*!***************************************************************!*\
  !*** ./node_modules/pkijs/src/KeyAgreeRecipientIdentifier.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KeyAgreeRecipientIdentifier; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IssuerAndSerialNumber.js */ "./node_modules/pkijs/src/IssuerAndSerialNumber.js");
/* harmony import */ var _RecipientKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RecipientKeyIdentifier.js */ "./node_modules/pkijs/src/RecipientKeyIdentifier.js");




//**************************************************************************************
/**
 * Class from RFC5652
 */
class KeyAgreeRecipientIdentifier
{
	//**********************************************************************************
	/**
	 * Constructor for KeyAgreeRecipientIdentifier class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc variant
		 */
		this.variant = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "variant", KeyAgreeRecipientIdentifier.defaultValues("variant"));
		/**
		 * @type {*}
		 * @desc values
		 */
		this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "value", KeyAgreeRecipientIdentifier.defaultValues("value"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "variant":
				return (-1);
			case "value":
				return {};
			default:
				throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "variant":
				return (memberValue === (-1));
			case "value":
				return (Object.keys(memberValue).length === 0);
			default:
				throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * KeyAgreeRecipientIdentifier ::= CHOICE {
	 *    issuerAndSerialNumber IssuerAndSerialNumber,
	 *    rKeyId [0] IMPLICIT RecipientKeyIdentifier }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [issuerAndSerialNumber]
		 * @property {string} [rKeyId]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
			value: [
				_IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.issuerAndSerialNumber || {
					names: {
						blockName: (names.blockName || "")
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: _RecipientKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.rKeyId || {
						names: {
							blockName: (names.blockName || "")
						}
					}).valueBlock.value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"blockName"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			KeyAgreeRecipientIdentifier.schema({
				names: {
					blockName: "blockName"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for KeyAgreeRecipientIdentifier");
		//endregion

		//region Get internal properties from parsed schema
		if(asn1.result.blockName.idBlock.tagClass === 1)
		{
			this.variant = 1;
			this.value = new _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.blockName });
		}
		else
		{
			this.variant = 2;

			this.value = new _RecipientKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.blockName.valueBlock.value
				})
			});
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		switch(this.variant)
		{
			case 1:
				return this.value.toSchema();
			case 2:
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: this.value.toSchema().valueBlock.value
				});
			default:
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			variant: this.variant
		};

		if((this.variant === 1) || (this.variant === 2))
			_object.value = this.value.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/KeyAgreeRecipientInfo.js":
/*!*********************************************************!*\
  !*** ./node_modules/pkijs/src/KeyAgreeRecipientInfo.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KeyAgreeRecipientInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _OriginatorIdentifierOrKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OriginatorIdentifierOrKey.js */ "./node_modules/pkijs/src/OriginatorIdentifierOrKey.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _RecipientEncryptedKeys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RecipientEncryptedKeys.js */ "./node_modules/pkijs/src/RecipientEncryptedKeys.js");
/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Certificate.js */ "./node_modules/pkijs/src/Certificate.js");






//**************************************************************************************
/**
 * Class from RFC5652
 */
class KeyAgreeRecipientInfo
{
	//**********************************************************************************
	/**
	 * Constructor for KeyAgreeRecipientInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", KeyAgreeRecipientInfo.defaultValues("version"));
		/**
		 * @type {OriginatorIdentifierOrKey}
		 * @desc originator
		 */
		this.originator = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "originator", KeyAgreeRecipientInfo.defaultValues("originator"));

		if("ukm" in parameters)
			/**
			 * @type {OctetString}
			 * @desc ukm
			 */
			this.ukm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "ukm", KeyAgreeRecipientInfo.defaultValues("ukm"));

		/**
		 * @type {AlgorithmIdentifier}
		 * @desc keyEncryptionAlgorithm
		 */
		this.keyEncryptionAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyEncryptionAlgorithm", KeyAgreeRecipientInfo.defaultValues("keyEncryptionAlgorithm"));
		/**
		 * @type {RecipientEncryptedKeys}
		 * @desc recipientEncryptedKeys
		 */
		this.recipientEncryptedKeys = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "recipientEncryptedKeys", KeyAgreeRecipientInfo.defaultValues("recipientEncryptedKeys"));
		/**
		 * @type {Certificate}
		 * @desc recipientCertificate For some reasons we need to store recipient's certificate here
		 */
		this.recipientCertificate = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "recipientCertificate", KeyAgreeRecipientInfo.defaultValues("recipientCertificate"));
		//endregion
		/**
		 * @type {CryptoKey}
		 * @desc recipientPublicKey
		 */
		this.recipientPublicKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "recipientPublicKey", KeyAgreeRecipientInfo.defaultValues("recipientPublicKey"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "originator":
				return new _OriginatorIdentifierOrKey_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "ukm":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "keyEncryptionAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "recipientEncryptedKeys":
				return new _RecipientEncryptedKeys_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			case "recipientCertificate":
				return new _Certificate_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			case "recipientPublicKey":
				return null;
			default:
				throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
				return (memberValue === 0);
			case "originator":
				return ((memberValue.variant === (-1)) && (("value" in memberValue) === false));
			case "ukm":
				return (memberValue.isEqual(KeyAgreeRecipientInfo.defaultValues("ukm")));
			case "keyEncryptionAlgorithm":
				return ((memberValue.algorithmId === "") && (("algorithmParams" in memberValue) === false));
			case "recipientEncryptedKeys":
				return (memberValue.encryptedKeys.length === 0);
			case "recipientCertificate":
				return false; // For now leave it as is
			case "recipientPublicKey":
				return false;
			default:
				throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * KeyAgreeRecipientInfo ::= SEQUENCE {
	 *    version CMSVersion,  -- always set to 3
	 *    originator [0] EXPLICIT OriginatorIdentifierOrKey,
	 *    ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
	 *    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
	 *    recipientEncryptedKeys RecipientEncryptedKeys }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [originator]
		 * @property {string} [ukm]
		 * @property {string} [keyEncryptionAlgorithm]
		 * @property {string} [recipientEncryptedKeys]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: names.blockName || "",
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: names.version || "" }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						_OriginatorIdentifierOrKey_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.originator || {})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: names.ukm || "" })]
				}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.keyEncryptionAlgorithm || {}),
				_RecipientEncryptedKeys_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.recipientEncryptedKeys || {})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"originator",
			"ukm",
			"keyEncryptionAlgorithm",
			"recipientEncryptedKeys"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			KeyAgreeRecipientInfo.schema({
				names: {
					version: "version",
					originator: {
						names: {
							blockName: "originator"
						}
					},
					ukm: "ukm",
					keyEncryptionAlgorithm: {
						names: {
							blockName: "keyEncryptionAlgorithm"
						}
					},
					recipientEncryptedKeys: {
						names: {
							blockName: "recipientEncryptedKeys"
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for KeyAgreeRecipientInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.originator = new _OriginatorIdentifierOrKey_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.originator });

		if("ukm" in asn1.result)
			this.ukm = asn1.result.ukm;

		this.keyEncryptionAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.keyEncryptionAlgorithm });
		this.recipientEncryptedKeys = new _RecipientEncryptedKeys_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result.recipientEncryptedKeys });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for final sequence
		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
			idBlock: {
				tagClass: 3, // CONTEXT-SPECIFIC
				tagNumber: 0 // [0]
			},
			value: [this.originator.toSchema()]
		}));

		if("ukm" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: [this.ukm]
			}));
		}

		outputArray.push(this.keyEncryptionAlgorithm.toSchema());
		outputArray.push(this.recipientEncryptedKeys.toSchema());
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			version: this.version,
			originator: this.originator.toJSON()
		};

		if("ukm" in this)
			_object.ukm = this.ukm.toJSON();

		_object.keyEncryptionAlgorithm = this.keyEncryptionAlgorithm.toJSON();
		_object.recipientEncryptedKeys = this.recipientEncryptedKeys.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/KeyBag.js":
/*!******************************************!*\
  !*** ./node_modules/pkijs/src/KeyBag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KeyBag; });
/* harmony import */ var _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrivateKeyInfo.js */ "./node_modules/pkijs/src/PrivateKeyInfo.js");

//**************************************************************************************
/**
 * Class from RFC5208
 */
class KeyBag extends _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_0__["default"]
{
	//**********************************************************************************
	/**
	 * Constructor for Attribute class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		super(parameters);
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/KeyTransRecipientInfo.js":
/*!*********************************************************!*\
  !*** ./node_modules/pkijs/src/KeyTransRecipientInfo.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KeyTransRecipientInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Certificate.js */ "./node_modules/pkijs/src/Certificate.js");
/* harmony import */ var _RecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RecipientIdentifier.js */ "./node_modules/pkijs/src/RecipientIdentifier.js");
/* harmony import */ var _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IssuerAndSerialNumber.js */ "./node_modules/pkijs/src/IssuerAndSerialNumber.js");






//**************************************************************************************
/**
 * Class from RFC5652
 */
class KeyTransRecipientInfo
{
	//**********************************************************************************
	/**
	 * Constructor for KeyTransRecipientInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", KeyTransRecipientInfo.defaultValues("version"));
		/**
		 * @type {RecipientIdentifier}
		 * @desc rid
		 */
		this.rid = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "rid", KeyTransRecipientInfo.defaultValues("rid"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc keyEncryptionAlgorithm
		 */
		this.keyEncryptionAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyEncryptionAlgorithm", KeyTransRecipientInfo.defaultValues("keyEncryptionAlgorithm"));
		/**
		 * @type {OctetString}
		 * @desc encryptedKey
		 */
		this.encryptedKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptedKey", KeyTransRecipientInfo.defaultValues("encryptedKey"));
		/**
		 * @type {Certificate}
		 * @desc recipientCertificate For some reasons we need to store recipient's certificate here
		 */
		this.recipientCertificate = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "recipientCertificate", KeyTransRecipientInfo.defaultValues("recipientCertificate"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return (-1);
			case "rid":
				return {};
			case "keyEncryptionAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "encryptedKey":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "recipientCertificate":
				return new _Certificate_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			default:
				throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
				return (memberValue === KeyTransRecipientInfo.defaultValues("version"));
			case "rid":
				return (Object.keys(memberValue).length === 0);
			case "keyEncryptionAlgorithm":
			case "encryptedKey":
				return memberValue.isEqual(KeyTransRecipientInfo.defaultValues(memberName));
			case "recipientCertificate":
				return false; // For now we do not need to compare any values with the "recipientCertificate"
			default:
				throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * KeyTransRecipientInfo ::= SEQUENCE {
	 *    version CMSVersion,  -- always set to 0 or 2
	 *    rid RecipientIdentifier,
	 *    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
	 *    encryptedKey EncryptedKey }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [rid]
		 * @property {string} [keyEncryptionAlgorithm]
		 * @property {string} [encryptedKey]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				_RecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.rid || {}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.keyEncryptionAlgorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.encryptedKey || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"rid",
			"keyEncryptionAlgorithm",
			"encryptedKey"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			KeyTransRecipientInfo.schema({
				names: {
					version: "version",
					rid: {
						names: {
							blockName: "rid"
						}
					},
					keyEncryptionAlgorithm: {
						names: {
							blockName: "keyEncryptionAlgorithm"
						}
					},
					encryptedKey: "encryptedKey"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for KeyTransRecipientInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;

		if(asn1.result.rid.idBlock.tagClass === 3)
			this.rid = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: asn1.result.rid.valueBlock.valueHex }); // SubjectKeyIdentifier
		else
			this.rid = new _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result.rid });

		this.keyEncryptionAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.keyEncryptionAlgorithm });
		this.encryptedKey = asn1.result.encryptedKey;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence 
		const outputArray = [];
		
		if(this.rid instanceof _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_5__["default"])
		{
			this.version = 0;
			
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
			outputArray.push(this.rid.toSchema());
		}
		else
		{
			this.version = 2;
			
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				valueHex: this.rid.valueBlock.valueHex
			}));
		}
		
		outputArray.push(this.keyEncryptionAlgorithm.toSchema());
		outputArray.push(this.encryptedKey);
		//endregion 
		
		//region Construct and return new ASN.1 schema for this object 
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion 
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			version: this.version,
			rid: this.rid.toJSON(),
			keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
			encryptedKey: this.encryptedKey.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/MacData.js":
/*!*******************************************!*\
  !*** ./node_modules/pkijs/src/MacData.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MacData; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _DigestInfo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DigestInfo.js */ "./node_modules/pkijs/src/DigestInfo.js");



//**************************************************************************************
/**
 * Class from RFC7292
 */
class MacData 
{
	//**********************************************************************************
	/**
	 * Constructor for MacData class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {DigestInfo}
		 * @desc mac
		 */
		this.mac = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "mac", MacData.defaultValues("mac"));
		/**
		 * @type {OctetString}
		 * @desc macSalt
		 */
		this.macSalt = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "macSalt", MacData.defaultValues("macSalt"));
		
		if("iterations" in parameters)
			/**
			 * @type {number}
			 * @desc iterations
			 */
			this.iterations = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "iterations", MacData.defaultValues("iterations"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "mac":
				return new _DigestInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "macSalt":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "iterations":
				return 1;
			default:
				throw new Error(`Invalid member name for MacData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "mac":
				return ((_DigestInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("digestAlgorithm", memberValue.digestAlgorithm)) &&
				(_DigestInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("digest", memberValue.digest)));
			case "macSalt":
				return (memberValue.isEqual(MacData.defaultValues(memberName)));
			case "iterations":
				return (memberValue === MacData.defaultValues(memberName));
			default:
				throw new Error(`Invalid member name for MacData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * MacData ::= SEQUENCE {
	 *    mac 		DigestInfo,
	 *    macSalt       OCTET STRING,
	 *    iterations	INTEGER DEFAULT 1
	 *    -- Note: The default is for historical reasons and its use is
	 *    -- deprecated. A higher value, like 1024 is recommended.
	 *    }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [optional]
		 * @property {string} [mac]
		 * @property {string} [macSalt]
		 * @property {string} [iterations]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			optional: (names.optional || true),
			value: [
				_DigestInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.mac || {
					names: {
						blockName: "mac"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.macSalt || "macSalt") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
					optional: true,
					name: (names.iterations || "iterations")
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"mac",
			"macSalt",
			"iterations"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			MacData.schema({
				names: {
					mac: {
						names: {
							blockName: "mac"
						}
					},
					macSalt: "macSalt",
					iterations: "iterations"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for MacData");
		//endregion
		
		//region Get internal properties from parsed schema
		this.mac = new _DigestInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.mac });
		this.macSalt = asn1.result.macSalt;
		
		if("iterations" in asn1.result)
			this.iterations = asn1.result.iterations.valueBlock.valueDec;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		const outputArray = [
			this.mac.toSchema(),
			this.macSalt
		];
		
		if("iterations" in this)
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.iterations }));
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const output = {
			mac: this.mac.toJSON(),
			macSalt: this.macSalt.toJSON()
		};
		
		if("iterations" in this)
			output.iterations = this.iterations.toJSON();
		
		return output;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/MessageImprint.js":
/*!**************************************************!*\
  !*** ./node_modules/pkijs/src/MessageImprint.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MessageImprint; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC3161
 */
class MessageImprint
{
	//**********************************************************************************
	/**
	 * Constructor for MessageImprint class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc hashAlgorithm
		 */
		this.hashAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "hashAlgorithm", MessageImprint.defaultValues("hashAlgorithm"));
		/**
		 * @type {OctetString}
		 * @desc hashedMessage
		 */
		this.hashedMessage = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "hashedMessage", MessageImprint.defaultValues("hashedMessage"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "hashAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "hashedMessage":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			default:
				throw new Error(`Invalid member name for MessageImprint class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "hashAlgorithm":
				return ((memberValue.algorithmId === "") && (("algorithmParams" in memberValue) === false));
			case "hashedMessage":
				return (memberValue.isEqual(MessageImprint.defaultValues(memberName)) === 0);
			default:
				throw new Error(`Invalid member name for MessageImprint class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * MessageImprint ::= SEQUENCE  {
	 *    hashAlgorithm                AlgorithmIdentifier,
	 *    hashedMessage                OCTET STRING  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [hashAlgorithm]
		 * @property {string} [hashedMessage]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.hashAlgorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.hashedMessage || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"hashAlgorithm",
			"hashedMessage"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			MessageImprint.schema({
				names: {
					hashAlgorithm: {
						names: {
							blockName: "hashAlgorithm"
						}
					},
					hashedMessage: "hashedMessage"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for MessageImprint");
		//endregion

		//region Get internal properties from parsed schema
		this.hashAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.hashAlgorithm });
		this.hashedMessage = asn1.result.hashedMessage;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.hashAlgorithm.toSchema(),
				this.hashedMessage
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			hashAlgorithm: this.hashAlgorithm.toJSON(),
			hashedMessage: this.hashedMessage.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/NameConstraints.js":
/*!***************************************************!*\
  !*** ./node_modules/pkijs/src/NameConstraints.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NameConstraints; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralSubtree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralSubtree.js */ "./node_modules/pkijs/src/GeneralSubtree.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class NameConstraints
{
	//**********************************************************************************
	/**
	 * Constructor for NameConstraints class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("permittedSubtrees" in parameters)
			/**
			 * @type {Array.<GeneralSubtree>}
			 * @desc permittedSubtrees
			 */
			this.permittedSubtrees = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "permittedSubtrees", NameConstraints.defaultValues("permittedSubtrees"));

		if("excludedSubtrees" in parameters)
			/**
			 * @type {Array.<GeneralSubtree>}
			 * @desc excludedSubtrees
			 */
			this.excludedSubtrees = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "excludedSubtrees", NameConstraints.defaultValues("excludedSubtrees"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "permittedSubtrees":
				return [];
			case "excludedSubtrees":
				return [];
			default:
				throw new Error(`Invalid member name for NameConstraints class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * NameConstraints ::= SEQUENCE {
	 *    permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
	 *    excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [permittedSubtrees]
		 * @property {string} [excludedSubtrees]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.permittedSubtrees || ""),
							value: _GeneralSubtree_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.excludedSubtrees || ""),
							value: _GeneralSubtree_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"permittedSubtrees",
			"excludedSubtrees"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			NameConstraints.schema({
				names: {
					permittedSubtrees: "permittedSubtrees",
					excludedSubtrees: "excludedSubtrees"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for NameConstraints");
		//endregion

		//region Get internal properties from parsed schema
		if("permittedSubtrees" in asn1.result)
			this.permittedSubtrees = Array.from(asn1.result.permittedSubtrees, element => new _GeneralSubtree_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));

		if("excludedSubtrees" in asn1.result)
			this.excludedSubtrees = Array.from(asn1.result.excludedSubtrees, element => new _GeneralSubtree_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if("permittedSubtrees" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: Array.from(this.permittedSubtrees, element => element.toSchema())
			}));
		}
		
		if("excludedSubtrees" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.excludedSubtrees, element => element.toSchema())
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};
		
		if("permittedSubtrees" in this)
			object.permittedSubtrees = Array.from(this.permittedSubtrees, element => element.toJSON());

		if("excludedSubtrees" in this)
			object.excludedSubtrees = Array.from(this.excludedSubtrees, element => element.toJSON());

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OCSPRequest.js":
/*!***********************************************!*\
  !*** ./node_modules/pkijs/src/OCSPRequest.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OCSPRequest; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TBSRequest.js */ "./node_modules/pkijs/src/TBSRequest.js");
/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Signature.js */ "./node_modules/pkijs/src/Signature.js");
/* harmony import */ var _Request_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Request.js */ "./node_modules/pkijs/src/Request.js");
/* harmony import */ var _CertID_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CertID.js */ "./node_modules/pkijs/src/CertID.js");







//**************************************************************************************
/**
 * Class from RFC6960
 */
class OCSPRequest 
{
	//**********************************************************************************
	/**
	 * Constructor for OCSPRequest class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {TBSRequest}
		 * @desc tbsRequest
		 */
		this.tbsRequest = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "tbsRequest", OCSPRequest.defaultValues("tbsRequest"));
		
		if("optionalSignature" in parameters)
			/**
			 * @type {Signature}
			 * @desc optionalSignature
			 */
			this.optionalSignature = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "optionalSignature", OCSPRequest.defaultValues("optionalSignature"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "tbsRequest":
				return new _TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "optionalSignature":
				return new _Signature_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			default:
				throw new Error(`Invalid member name for OCSPRequest class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "tbsRequest":
				// noinspection OverlyComplexBooleanExpressionJS
				return ((_TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("tbs", memberValue.tbs)) &&
				(_TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("version", memberValue.version)) &&
				(_TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("requestorName", memberValue.requestorName)) &&
				(_TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("requestList", memberValue.requestList)) &&
				(_TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("requestExtensions", memberValue.requestExtensions)));
			case "optionalSignature":
				return ((_Signature_js__WEBPACK_IMPORTED_MODULE_4__["default"].compareWithDefault("signatureAlgorithm", memberValue.signatureAlgorithm)) &&
				(_Signature_js__WEBPACK_IMPORTED_MODULE_4__["default"].compareWithDefault("signature", memberValue.signature)) &&
				(_Signature_js__WEBPACK_IMPORTED_MODULE_4__["default"].compareWithDefault("certs", memberValue.certs)));
			default:
				throw new Error(`Invalid member name for OCSPRequest class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OCSPRequest     ::=     SEQUENCE {
	 *    tbsRequest                  TBSRequest,
	 *    optionalSignature   [0]     EXPLICIT Signature OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [tbsRequest]
		 * @property {string} [optionalSignature]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: names.blockName || "OCSPRequest",
			value: [
				_TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.tbsRequest || {
					names: {
						blockName: "tbsRequest"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						_Signature_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.optionalSignature || {
							names: {
								blockName: "optionalSignature"
							}
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"tbsRequest",
			"optionalSignature"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OCSPRequest.schema()
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OCSPRequest");
		//endregion
		
		//region Get internal properties from parsed schema
		this.tbsRequest = new _TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.tbsRequest });
		if("optionalSignature" in asn1.result)
			this.optionalSignature = new _Signature_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result.optionalSignature });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @param {boolean} encodeFlag If param equal to false then create TBS schema via decoding stored value. In othe case create TBS schema via assembling from TBS parts.
	 * @returns {Object} asn1js object
	 */
	toSchema(encodeFlag = false)
	{
		//region Create array for output sequence
		const outputArray = [];
		
		outputArray.push(this.tbsRequest.toSchema(encodeFlag));
		if("optionalSignature" in this)
			outputArray.push(
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						this.optionalSignature.toSchema()
					]
				}));
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			tbsRequest: this.tbsRequest.toJSON()
		};
		
		if("optionalSignature" in this)
			_object.optionalSignature = this.optionalSignature.toJSON();
		
		return _object;
	}
	//**********************************************************************************
	/**
	 * Making OCSP Request for specific certificate
	 * @param {Certificate} certificate Certificate making OCSP Request for
	 * @param {Object} parameters Additional parameters
	 * @returns {Promise}
	 */
	createForCertificate(certificate, parameters)
	{
		//region Initial variables
		let sequence = Promise.resolve();
		
		const certID = new _CertID_js__WEBPACK_IMPORTED_MODULE_6__["default"]();
		//endregion
		
		//region Create OCSP certificate identifier for the certificate
		sequence = sequence.then(() =>
			certID.createForCertificate(certificate, parameters)
		);
		//endregion
		
		//region Make final request data
		sequence = sequence.then(() =>
		{
			this.tbsRequest = new _TBSRequest_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
				requestList: [
					new _Request_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
						reqCert: certID
					})
				]
			});
		}, error =>
			Promise.reject(error)
		);
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Make signature for current OCSP Request
	 * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
	 * @param {string} [hashAlgorithm] Hashing algorithm. Default SHA-1
	 * @returns {Promise}
	 */
	sign(privateKey, hashAlgorithm = "SHA-1")
	{
		//region Initial checking
		//region Check private key
		if(typeof privateKey === "undefined")
			return Promise.reject("Need to provide a private key for signing");
		//endregion
		
		//region Check that "optionalSignature" exists in the current request
		if(("optionalSignature" in this) === false)
			return Promise.reject("Need to create \"optionalSignature\" field before signing");
		//endregion
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		let parameters;
		
		let tbs;
		
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		//endregion

		//region Get a "default parameters" for current algorithm and set correct signature algorithm
		sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
		
		sequence = sequence.then(result =>
		{
			parameters = result.parameters;
			this.optionalSignature.signatureAlgorithm = result.signatureAlgorithm;
		});
		//endregion
		
		//region Create TBS data for signing
		sequence = sequence.then(() =>
		{
			tbs = this.tbsRequest.toSchema(true).toBER(false);
		});
		//endregion
		
		//region Signing TBS data on provided private key
		sequence = sequence.then(() => engine.subtle.signWithPrivateKey(tbs, privateKey, parameters));
		
		sequence = sequence.then(result =>
		{
			this.optionalSignature.signature = new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ valueHex: result });
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	verify()
	{
		// TODO: Create the function
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OCSPResponse.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/OCSPResponse.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OCSPResponse; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _ResponseBytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ResponseBytes.js */ "./node_modules/pkijs/src/ResponseBytes.js");
/* harmony import */ var _BasicOCSPResponse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BasicOCSPResponse.js */ "./node_modules/pkijs/src/BasicOCSPResponse.js");




//**************************************************************************************
/**
 * Class from RFC6960
 */
class OCSPResponse
{
	//**********************************************************************************
	/**
	 * Constructor for OCSPResponse class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Enumerated}
		 * @desc responseStatus
		 */
		this.responseStatus = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "responseStatus", OCSPResponse.defaultValues("responseStatus"));

		if("responseBytes" in parameters)
			/**
			 * @type {ResponseBytes}
			 * @desc responseBytes
			 */
			this.responseBytes = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "responseBytes", OCSPResponse.defaultValues("responseBytes"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "responseStatus":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Enumerated"]();
			case "responseBytes":
				return new _ResponseBytes_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			default:
				throw new Error(`Invalid member name for OCSPResponse class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "responseStatus":
				return (memberValue.isEqual(OCSPResponse.defaultValues(memberName)));
			case "responseBytes":
				return ((_ResponseBytes_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("responseType", memberValue.responseType)) &&
						(_ResponseBytes_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("response", memberValue.response)));
			default:
				throw new Error(`Invalid member name for OCSPResponse class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OCSPResponse ::= SEQUENCE {
	 *    responseStatus         OCSPResponseStatus,
	 *    responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
	 *
	 * OCSPResponseStatus ::= ENUMERATED {
	 *    successful            (0),  -- Response has valid confirmations
	 *    malformedRequest      (1),  -- Illegal confirmation request
	 *    internalError         (2),  -- Internal error in issuer
	 *    tryLater              (3),  -- Try again later
	 *    -- (4) is not used
	 *    sigRequired           (5),  -- Must sign the request
	 *    unauthorized          (6)   -- Request unauthorized
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [responseStatus]
		 * @property {string} [responseBytes]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "OCSPResponse"),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Enumerated"]({ name: (names.responseStatus || "responseStatus") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						_ResponseBytes_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.responseBytes || {
							names: {
								blockName: "responseBytes"
							}
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"responseStatus",
			"responseBytes"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OCSPResponse.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OCSPResponse");
		//endregion

		//region Get internal properties from parsed schema
		this.responseStatus = asn1.result.responseStatus;
		if("responseBytes" in asn1.result)
			this.responseBytes = new _ResponseBytes_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.responseBytes });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(this.responseStatus);
		if("responseBytes" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [this.responseBytes.toSchema()]
			}));
		}
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			responseStatus: this.responseStatus.toJSON()
		};

		if("responseBytes" in this)
			_object.responseBytes = this.responseBytes.toJSON();

		return _object;
	}
	//**********************************************************************************
	/**
	 * Get OCSP response status for specific certificate
	 * @param {Certificate} certificate
	 * @param {Certificate} issuerCertificate
	 * @returns {*}
	 */
	getCertificateStatus(certificate, issuerCertificate)
	{
		//region Initial variables
		let basicResponse;

		const result = {
			isForCertificate: false,
			status: 2 // 0 = good, 1 = revoked, 2 = unknown
		};
		//endregion

		//region Check that "ResponseBytes" contain "OCSP_BASIC_RESPONSE"
		if(("responseBytes" in this) === false)
			return result;

		if(this.responseBytes.responseType !== "1.3.6.1.5.5.7.48.1.1") // id-pkix-ocsp-basic
			return result;

		try
		{
			const asn1Basic = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.responseBytes.response.valueBlock.valueHex);
			basicResponse = new _BasicOCSPResponse_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1Basic.result });
		}
		catch(ex)
		{
			return result;
		}
		//endregion

		return basicResponse.getCertificateStatus(certificate, issuerCertificate);
	}
	//**********************************************************************************
	/**
	 * Make a signature for current OCSP Response
	 * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
	 * @param {string} [hashAlgorithm] Hashing algorithm. Default SHA-1
	 * @returns {Promise}
	 */
	sign(privateKey, hashAlgorithm)
	{
		//region Check that ResponseData has type BasicOCSPResponse and sign it
		if(this.responseBytes.responseType === "1.3.6.1.5.5.7.48.1.1")
		{
			const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.responseBytes.response.valueBlock.valueHex);
			const basicResponse = new _BasicOCSPResponse_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result });

			return basicResponse.sign(privateKey, hashAlgorithm);
		}

		return Promise.reject(`Unknown ResponseBytes type: ${this.responseBytes.responseType}`);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Verify current OCSP Response
	 * @param {Certificate|null} issuerCertificate In order to decrease size of resp issuer cert could be ommited. In such case you need manually provide it.
	 * @returns {Promise}
	 */
	verify(issuerCertificate = null)
	{
		//region Check that ResponseBytes exists in the object
		if(("responseBytes" in this) === false)
			return Promise.reject("Empty ResponseBytes field");
		//endregion

		//region Check that ResponceData has type BasicOCSPResponse and verify it
		if(this.responseBytes.responseType === "1.3.6.1.5.5.7.48.1.1")
		{
			const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.responseBytes.response.valueBlock.valueHex);
			const basicResponse = new _BasicOCSPResponse_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result });

			if(issuerCertificate !== null)
			{
				if(("certs" in basicResponse) === false)
					basicResponse.certs = [];
				
				basicResponse.certs.push(issuerCertificate);
			}
			
			return basicResponse.verify();
		}

		return Promise.reject(`Unknown ResponseBytes type: ${this.responseBytes.responseType}`);
		//endregion
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OriginatorIdentifierOrKey.js":
/*!*************************************************************!*\
  !*** ./node_modules/pkijs/src/OriginatorIdentifierOrKey.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OriginatorIdentifierOrKey; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IssuerAndSerialNumber.js */ "./node_modules/pkijs/src/IssuerAndSerialNumber.js");
/* harmony import */ var _OriginatorPublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OriginatorPublicKey.js */ "./node_modules/pkijs/src/OriginatorPublicKey.js");




//**************************************************************************************
/**
 * Class from RFC5652
 */
class OriginatorIdentifierOrKey 
{
	//**********************************************************************************
	/**
	 * Constructor for OriginatorIdentifierOrKey class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc variant
		 */
		this.variant = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "variant", OriginatorIdentifierOrKey.defaultValues("variant"));

		if("value" in parameters)
			/**
			 * @type {IssuerAndSerialNumber|OctetString|OriginatorPublicKey}
			 * @desc value
			 */
			this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "value", OriginatorIdentifierOrKey.defaultValues("value"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "variant":
				return (-1);
			case "value":
				return {};
			default:
				throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "variant":
				return (memberValue === (-1));
			case "value":
				return (Object.keys(memberValue).length === 0);
			default:
				throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OriginatorIdentifierOrKey ::= CHOICE {
	 *    issuerAndSerialNumber IssuerAndSerialNumber,
	 *    subjectKeyIdentifier [0] SubjectKeyIdentifier,
	 *    originatorKey [1] OriginatorPublicKey }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
			value: [
				_IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema({
					names: {
						blockName: (names.blockName || "")
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					name: (names.blockName || "")
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					name: (names.blockName || ""),
					value: _OriginatorPublicKey_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema().valueBlock.value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"blockName"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OriginatorIdentifierOrKey.schema({
				names: {
					blockName: "blockName"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OriginatorIdentifierOrKey");
		//endregion

		//region Get internal properties from parsed schema
		if(asn1.result.blockName.idBlock.tagClass === 1)
		{
			this.variant = 1;
			this.value = new _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.blockName });
		}
		else
		{
			if(asn1.result.blockName.idBlock.tagNumber === 0)
			{
				//region Create "OCTETSTRING" from "ASN1_PRIMITIVE"
				asn1.result.blockName.idBlock.tagClass = 1; // UNIVERSAL
				asn1.result.blockName.idBlock.tagNumber = 4; // OCTETSTRING
				//endregion

				this.variant = 2;
				this.value = asn1.result.blockName;
			}
			else
			{
				this.variant = 3;
				this.value = new _OriginatorPublicKey_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
					schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
						value: asn1.result.blockName.valueBlock.value
					})
				});
			}
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		switch(this.variant)
		{
			case 1:
				return this.value.toSchema();
			case 2:
				this.value.idBlock.tagClass = 3; // CONTEXT-SPECIFIC
				this.value.idBlock.tagNumber = 0; // [0]

				return this.value;
			case 3:
				{
					const _schema = this.value.toSchema();

					_schema.idBlock.tagClass = 3; // CONTEXT-SPECIFIC
					_schema.idBlock.tagNumber = 1; // [1]

					return _schema;
				}
			default:
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			variant: this.variant
		};

		if((this.variant === 1) || (this.variant === 2) || (this.variant === 3))
			_object.value = this.value.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OriginatorInfo.js":
/*!**************************************************!*\
  !*** ./node_modules/pkijs/src/OriginatorInfo.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OriginatorInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _CertificateSet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CertificateSet.js */ "./node_modules/pkijs/src/CertificateSet.js");
/* harmony import */ var _RevocationInfoChoices_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RevocationInfoChoices.js */ "./node_modules/pkijs/src/RevocationInfoChoices.js");




//**************************************************************************************
/**
 * Class from RFC5652
 */
class OriginatorInfo
{
	//**********************************************************************************
	/**
	 * Constructor for OriginatorInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("certs" in parameters)
			/**
			 * @type {CertificateSet}
			 * @desc certs
			 */
			this.certs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certs", OriginatorInfo.defaultValues("certs"));

		if("crls" in parameters)
			/**
			 * @type {RevocationInfoChoices}
			 * @desc crls
			 */
			this.crls = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "crls", OriginatorInfo.defaultValues("crls"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "certs":
				return new _CertificateSet_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "crls":
				return new _RevocationInfoChoices_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			default:
				throw new Error(`Invalid member name for OriginatorInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "certs":
				return (memberValue.certificates.length === 0);
			case "crls":
				return ((memberValue.crls.length === 0) && (memberValue.otherRevocationInfos.length === 0));
			default:
				throw new Error(`Invalid member name for OriginatorInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OriginatorInfo ::= SEQUENCE {
	 *    certs [0] IMPLICIT CertificateSet OPTIONAL,
	 *    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [certs]
		 * @property {string} [crls]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.certs || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: _CertificateSet_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema().valueBlock.value
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.crls || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: _RevocationInfoChoices_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema().valueBlock.value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"certs",
			"crls"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OriginatorInfo.schema({
				names: {
					certs: "certs",
					crls: "crls"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OriginatorInfo");
		//endregion

		//region Get internal properties from parsed schema
		if("certs" in asn1.result)
		{
			this.certs = new _CertificateSet_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					value: asn1.result.certs.valueBlock.value
				})
			});
		}

		if("crls" in asn1.result)
		{
			this.crls = new _RevocationInfoChoices_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					value: asn1.result.crls.valueBlock.value
				})
			});
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const sequenceValue = [];

		if("certs" in this)
		{
			sequenceValue.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: this.certs.toSchema().valueBlock.value
			}));
		}

		if("crls" in this)
		{
			sequenceValue.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: this.crls.toSchema().valueBlock.value
			}));
		}

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: sequenceValue
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};

		if("certs" in this)
			object.certs = this.certs.toJSON();

		if("crls" in this)
			object.crls = this.crls.toJSON();

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OriginatorPublicKey.js":
/*!*******************************************************!*\
  !*** ./node_modules/pkijs/src/OriginatorPublicKey.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OriginatorPublicKey; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class OriginatorPublicKey
{
	//**********************************************************************************
	/**
	 * Constructor for OriginatorPublicKey class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc algorithm
		 */
		this.algorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "algorithm", OriginatorPublicKey.defaultValues("algorithm"));
		/**
		 * @type {BitString}
		 * @desc publicKey
		 */
		this.publicKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "publicKey", OriginatorPublicKey.defaultValues("publicKey"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "algorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "publicKey":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for OriginatorPublicKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "algorithm":
			case "publicKey":
				return (memberValue.isEqual(OriginatorPublicKey.defaultValues(memberName)));
			default:
				throw new Error(`Invalid member name for OriginatorPublicKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OriginatorPublicKey ::= SEQUENCE {
	 *    algorithm AlgorithmIdentifier,
	 *    publicKey BIT STRING }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [algorithm]
		 * @property {string} [publicKey]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.algorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.publicKey || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"algorithm",
			"publicKey"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OriginatorPublicKey.schema({
				names: {
					algorithm: {
						names: {
							blockName: "algorithm"
						}
					},
					publicKey: "publicKey"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OriginatorPublicKey");
		//endregion

		//region Get internal properties from parsed schema
		this.algorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.algorithm });
		this.publicKey = asn1.result.publicKey;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.algorithm.toSchema(),
				this.publicKey
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			algorithm: this.algorithm.toJSON(),
			publicKey: this.publicKey.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OtherCertificateFormat.js":
/*!**********************************************************!*\
  !*** ./node_modules/pkijs/src/OtherCertificateFormat.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OtherCertificateFormat; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5652
 */
class OtherCertificateFormat
{
	//**********************************************************************************
	/**
	 * Constructor for OtherCertificateFormat class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc otherCertFormat
		 */
		this.otherCertFormat = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "otherCertFormat", OtherCertificateFormat.defaultValues("otherCertFormat"));
		/**
		 * @type {Any}
		 * @desc otherCert
		 */
		this.otherCert = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "otherCert", OtherCertificateFormat.defaultValues("otherCert"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "otherCertFormat":
				return "";
			case "otherCert":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
			default:
				throw new Error(`Invalid member name for OtherCertificateFormat class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OtherCertificateFormat ::= SEQUENCE {
	 *    otherCertFormat OBJECT IDENTIFIER,
	 *    otherCert ANY DEFINED BY otherCertFormat }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [otherCertFormat]
		 * @property {string} [otherCert]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.otherCertFormat || "otherCertFormat") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.otherCert || "otherCert") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"otherCertFormat",
			"otherCert"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OtherCertificateFormat.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OtherCertificateFormat");
		//endregion

		//region Get internal properties from parsed schema
		this.otherCertFormat = asn1.result.otherCertFormat.valueBlock.toString();
		this.otherCert = asn1.result.otherCert;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.otherCertFormat }),
				this.otherCert
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			otherCertFormat: this.otherCertFormat
		};

		if(!(this.otherCert instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]))
			object.otherCert = this.otherCert.toJSON();

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OtherKeyAttribute.js":
/*!*****************************************************!*\
  !*** ./node_modules/pkijs/src/OtherKeyAttribute.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OtherKeyAttribute; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5652
 */
class OtherKeyAttribute
{
	//**********************************************************************************
	/**
	 * Constructor for OtherKeyAttribute class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc keyAttrId
		 */
		this.keyAttrId = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyAttrId", OtherKeyAttribute.defaultValues("keyAttrId"));

		if("keyAttr" in parameters)
			/**
			 * @type {*}
			 * @desc keyAttr
			 */
			this.keyAttr = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyAttr", OtherKeyAttribute.defaultValues("keyAttr"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "keyAttrId":
				return "";
			case "keyAttr":
				return {};
			default:
				throw new Error(`Invalid member name for OtherKeyAttribute class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "keyAttrId":
				return (memberValue === "");
			case "keyAttr":
				return (Object.keys(memberValue).length === 0);
			default:
				throw new Error(`Invalid member name for OtherKeyAttribute class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OtherKeyAttribute ::= SEQUENCE {
	 *    keyAttrId OBJECT IDENTIFIER,
	 *    keyAttr ANY DEFINED BY keyAttrId OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [optional]
		 * @property {string} [keyAttrId]
		 * @property {string} [keyAttr]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			optional: (names.optional || true),
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.keyAttrId || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({
					optional: true,
					name: (names.keyAttr || "")
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"keyAttrId",
			"keyAttr"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OtherKeyAttribute.schema({
				names: {
					keyAttrId: "keyAttrId",
					keyAttr: "keyAttr"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OtherKeyAttribute");
		//endregion

		//region Get internal properties from parsed schema
		this.keyAttrId = asn1.result.keyAttrId.valueBlock.toString();

		if("keyAttr" in asn1.result)
			this.keyAttr = asn1.result.keyAttr;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.keyAttrId }));

		if("keyAttr" in this)
			outputArray.push(this.keyAttr);
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			keyAttrId: this.keyAttrId
		};

		if("keyAttr" in this)
			_object.keyAttr = this.keyAttr.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OtherPrimeInfo.js":
/*!**************************************************!*\
  !*** ./node_modules/pkijs/src/OtherPrimeInfo.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OtherPrimeInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC3447
 */
class OtherPrimeInfo
{
	//**********************************************************************************
	/**
	 * Constructor for OtherPrimeInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Integer}
		 * @desc prime
		 */
		this.prime = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "prime", OtherPrimeInfo.defaultValues("prime"));
		/**
		 * @type {Integer}
		 * @desc exponent
		 */
		this.exponent = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "exponent", OtherPrimeInfo.defaultValues("exponent"));
		/**
		 * @type {Integer}
		 * @desc coefficient
		 */
		this.coefficient = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "coefficient", OtherPrimeInfo.defaultValues("coefficient"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
		//region If input argument array contains "json" for this object
		if("json" in parameters)
			this.fromJSON(parameters.json);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "prime":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "exponent":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "coefficient":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			default:
				throw new Error(`Invalid member name for OtherPrimeInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OtherPrimeInfo ::= Sequence {
	 *    prime             Integer,  -- ri
	 *    exponent          Integer,  -- di
	 *    coefficient       Integer   -- ti
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{

		/**
		 * @type {Object}
		 * @property {string} prime
		 * @property {string} exponent
		 * @property {string} coefficient
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.prime || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.exponent || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.coefficient || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"prime",
			"exponent",
			"coefficient"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OtherPrimeInfo.schema({
				names: {
					prime: "prime",
					exponent: "exponent",
					coefficient: "coefficient"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.prime = asn1.result.prime.convertFromDER();
		this.exponent = asn1.result.exponent.convertFromDER();
		this.coefficient = asn1.result.coefficient.convertFromDER();
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.prime.convertToDER(),
				this.exponent.convertToDER(),
				this.coefficient.convertToDER()
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			r: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.prime.valueBlock.valueHex), true, true),
			d: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.exponent.valueBlock.valueHex), true, true),
			t: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.coefficient.valueBlock.valueHex), true, true)
		};
	}
	//**********************************************************************************
	/**
	 * Convert JSON value into current object
	 * @param {Object} json
	 */
	fromJSON(json)
	{
		if("r" in json)
			this.prime = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.r, true)) });
		else
			throw new Error("Absent mandatory parameter \"r\"");

		if("d" in json)
			this.exponent = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.d, true)) });
		else
			throw new Error("Absent mandatory parameter \"d\"");

		if("t" in json)
			this.coefficient = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.t, true)) });
		else
			throw new Error("Absent mandatory parameter \"t\"");
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OtherRecipientInfo.js":
/*!******************************************************!*\
  !*** ./node_modules/pkijs/src/OtherRecipientInfo.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OtherRecipientInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5652
 */
class OtherRecipientInfo
{
	//**********************************************************************************
	/**
	 * Constructor for OtherRecipientInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc oriType
		 */
		this.oriType = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "oriType", OtherRecipientInfo.defaultValues("oriType"));
		/**
		 * @type {*}
		 * @desc oriValue
		 */
		this.oriValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "oriValue", OtherRecipientInfo.defaultValues("oriValue"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "oriType":
				return "";
			case "oriValue":
				return {};
			default:
				throw new Error(`Invalid member name for OtherRecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "oriType":
				return (memberValue === "");
			case "oriValue":
				return (Object.keys(memberValue).length === 0);
			default:
				throw new Error(`Invalid member name for OtherRecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OtherRecipientInfo ::= SEQUENCE {
	 *    oriType OBJECT IDENTIFIER,
	 *    oriValue ANY DEFINED BY oriType }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [oriType]
		 * @property {string} [oriValue]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.oriType || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.oriValue || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"oriType",
			"oriValue"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OtherRecipientInfo.schema({
				names: {
					oriType: "oriType",
					oriValue: "oriValue"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OtherRecipientInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.oriType = asn1.result.oriType.valueBlock.toString();
		this.oriValue = asn1.result.oriValue;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.oriType }),
				this.oriValue
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			oriType: this.oriType
		};

		if(OtherRecipientInfo.compareWithDefault("oriValue", this.oriValue) === false)
			_object.oriValue = this.oriValue.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/OtherRevocationInfoFormat.js":
/*!*************************************************************!*\
  !*** ./node_modules/pkijs/src/OtherRevocationInfoFormat.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OtherRevocationInfoFormat; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5652
 */
class OtherRevocationInfoFormat
{
	//**********************************************************************************
	/**
	 * Constructor for OtherRevocationInfoFormat class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc otherRevInfoFormat
		 */
		this.otherRevInfoFormat = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "otherRevInfoFormat", OtherRevocationInfoFormat.defaultValues("otherRevInfoFormat"));
		/**
		 * @type {Any}
		 * @desc otherRevInfo
		 */
		this.otherRevInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "otherRevInfo", OtherRevocationInfoFormat.defaultValues("otherRevInfo"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "otherRevInfoFormat":
				return "";
			case "otherRevInfo":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
			default:
				throw new Error(`Invalid member name for OtherRevocationInfoFormat class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * OtherCertificateFormat ::= SEQUENCE {
	 *    otherRevInfoFormat OBJECT IDENTIFIER,
	 *    otherRevInfo ANY DEFINED BY otherCertFormat }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [otherRevInfoFormat]
		 * @property {string} [otherRevInfo]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.otherRevInfoFormat || "otherRevInfoFormat") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.otherRevInfo || "otherRevInfo") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"otherRevInfoFormat",
			"otherRevInfo"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			OtherRevocationInfoFormat.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for OtherRevocationInfoFormat");
		//endregion

		//region Get internal properties from parsed schema
		this.otherRevInfoFormat = asn1.result.otherRevInfoFormat.valueBlock.toString();
		this.otherRevInfo = asn1.result.otherRevInfo;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.otherRevInfoFormat }),
				this.otherRevInfo
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			otherRevInfoFormat: this.otherRevInfoFormat
		};

		if(!(this.otherRevInfo instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]))
			object.otherRevInfo = this.otherRevInfo.toJSON();

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PBES2Params.js":
/*!***********************************************!*\
  !*** ./node_modules/pkijs/src/PBES2Params.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PBES2Params; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC2898
 */
class PBES2Params
{
	//**********************************************************************************
	/**
	 * Constructor for PBES2Params class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc keyDerivationFunc
		 */
		this.keyDerivationFunc = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyDerivationFunc", PBES2Params.defaultValues("keyDerivationFunc"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc encryptionScheme
		 */
		this.encryptionScheme = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptionScheme", PBES2Params.defaultValues("encryptionScheme"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "keyDerivationFunc":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "encryptionScheme":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			default:
				throw new Error(`Invalid member name for PBES2Params class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PBES2-params ::= SEQUENCE {
	 *    keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
	 *    encryptionScheme AlgorithmIdentifier {{PBES2-Encs}} }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [keyDerivationFunc]
		 * @property {string} [encryptionScheme]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.keyDerivationFunc || {}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.encryptionScheme || {})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"keyDerivationFunc",
			"encryptionScheme"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PBES2Params.schema({
				names: {
					keyDerivationFunc: {
						names: {
							blockName: "keyDerivationFunc"
						}
					},
					encryptionScheme: {
						names: {
							blockName: "encryptionScheme"
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PBES2Params");
		//endregion

		//region Get internal properties from parsed schema
		this.keyDerivationFunc = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.keyDerivationFunc });
		this.encryptionScheme = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.encryptionScheme });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.keyDerivationFunc.toSchema(),
				this.encryptionScheme.toSchema()
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			keyDerivationFunc: this.keyDerivationFunc.toJSON(),
			encryptionScheme: this.encryptionScheme.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PBKDF2Params.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/PBKDF2Params.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PBKDF2Params; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC2898
 */
class PBKDF2Params
{
	//**********************************************************************************
	/**
	 * Constructor for PBKDF2Params class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Object}
		 * @desc salt
		 */
		this.salt = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "salt", PBKDF2Params.defaultValues("salt"));
		/**
		 * @type {number}
		 * @desc iterationCount
		 */
		this.iterationCount = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "iterationCount", PBKDF2Params.defaultValues("iterationCount"));
		
		if("keyLength" in parameters)
			/**
			 * @type {number}
			 * @desc keyLength
			 */
			this.keyLength = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyLength", PBKDF2Params.defaultValues("keyLength"));
		
		if("prf" in parameters)
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc prf
			 */
			this.prf = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "prf", PBKDF2Params.defaultValues("prf"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "salt":
				return {};
			case "iterationCount":
				return (-1);
			case "keyLength":
				return 0;
			case "prf":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
					algorithmId: "1.3.14.3.2.26", // SHA-1
					algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
				});
			default:
				throw new Error(`Invalid member name for PBKDF2Params class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PBKDF2-params ::= SEQUENCE {
	 *    salt CHOICE {
	 *        specified OCTET STRING,
	 *        otherSource AlgorithmIdentifier },
	 *  iterationCount INTEGER (1..MAX),
	 *  keyLength INTEGER (1..MAX) OPTIONAL,
	 *  prf AlgorithmIdentifier
	 *    DEFAULT { algorithm hMAC-SHA1, parameters NULL } }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [saltPrimitive]
		 * @property {string} [saltConstructed]
		 * @property {string} [iterationCount]
		 * @property {string} [keyLength]
		 * @property {string} [prf]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.saltPrimitive || "") }),
						_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.saltConstructed || {})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.iterationCount || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
					name: (names.keyLength || ""),
					optional: true
				}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.prf || {
					names: {
						optional: true
					}
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"salt",
			"iterationCount",
			"keyLength",
			"prf"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PBKDF2Params.schema({
				names: {
					saltPrimitive: "salt",
					saltConstructed: {
						names: {
							blockName: "salt"
						}
					},
					iterationCount: "iterationCount",
					keyLength: "keyLength",
					prf: {
						names: {
							blockName: "prf",
							optional: true
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PBKDF2Params");
		//endregion

		//region Get internal properties from parsed schema
		this.salt = asn1.result.salt;
		this.iterationCount = asn1.result.iterationCount.valueBlock.valueDec;

		if("keyLength" in asn1.result)
			this.keyLength = asn1.result.keyLength.valueBlock.valueDec;

		if("prf" in asn1.result)
			this.prf = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.prf });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence 
		const outputArray = [];
		
		outputArray.push(this.salt);
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.iterationCount }));
		
		if("keyLength" in this)
		{
			if(PBKDF2Params.defaultValues("keyLength") !== this.keyLength)
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.keyLength }));
		}
		
		if("prf" in this)
		{
			if(PBKDF2Params.defaultValues("prf").isEqual(this.prf) === false)
				outputArray.push(this.prf.toSchema());
		}
		//endregion 
		
		//region Construct and return new ASN.1 schema for this object 
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion 
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			salt: this.salt.toJSON(),
			iterationCount: this.iterationCount
		};
		
		if("keyLength" in this)
		{
			if(PBKDF2Params.defaultValues("keyLength") !== this.keyLength)
				_object.keyLength = this.keyLength;
		}
		
		if("prf" in this)
		{
			if(PBKDF2Params.defaultValues("prf").isEqual(this.prf) === false)
				_object.prf = this.prf.toJSON();
		}

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PFX.js":
/*!***************************************!*\
  !*** ./node_modules/pkijs/src/PFX.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PFX; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ContentInfo.js */ "./node_modules/pkijs/src/ContentInfo.js");
/* harmony import */ var _MacData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MacData.js */ "./node_modules/pkijs/src/MacData.js");
/* harmony import */ var _DigestInfo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DigestInfo.js */ "./node_modules/pkijs/src/DigestInfo.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _SignedData_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SignedData.js */ "./node_modules/pkijs/src/SignedData.js");
/* harmony import */ var _EncapsulatedContentInfo_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EncapsulatedContentInfo.js */ "./node_modules/pkijs/src/EncapsulatedContentInfo.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");
/* harmony import */ var _SignerInfo_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SignerInfo.js */ "./node_modules/pkijs/src/SignerInfo.js");
/* harmony import */ var _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./IssuerAndSerialNumber.js */ "./node_modules/pkijs/src/IssuerAndSerialNumber.js");
/* harmony import */ var _SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SignedAndUnsignedAttributes.js */ "./node_modules/pkijs/src/SignedAndUnsignedAttributes.js");
/* harmony import */ var _AuthenticatedSafe_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./AuthenticatedSafe.js */ "./node_modules/pkijs/src/AuthenticatedSafe.js");














//**************************************************************************************
/**
 * Class from RFC7292
 */
class PFX 
{
	//**********************************************************************************
	/**
	 * Constructor for PFX class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", PFX.defaultValues("version"));
		/**
		 * @type {ContentInfo}
		 * @desc authSafe
		 */
		this.authSafe = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "authSafe", PFX.defaultValues("authSafe"));
		
		if("macData" in parameters)
			/**
			 * @type {MacData}
			 * @desc macData
			 */
			this.macData = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "macData", PFX.defaultValues("macData"));
		
		if("parsedValue" in parameters)
			/**
			 * @type {*}
			 * @desc parsedValue
			 */
			this.parsedValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "parsedValue", PFX.defaultValues("parsedValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 3;
			case "authSafe":
				return (new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]());
			case "macData":
				return (new _MacData_js__WEBPACK_IMPORTED_MODULE_4__["default"]());
			case "parsedValue":
				return {};
			default:
				throw new Error(`Invalid member name for PFX class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
				return (memberValue === PFX.defaultValues(memberName));
			case "authSafe":
				return ((_ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("contentType", memberValue.contentType)) &&
				(_ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("content", memberValue.content)));
			case "macData":
				return ((_MacData_js__WEBPACK_IMPORTED_MODULE_4__["default"].compareWithDefault("mac", memberValue.mac)) &&
				(_MacData_js__WEBPACK_IMPORTED_MODULE_4__["default"].compareWithDefault("macSalt", memberValue.macSalt)) &&
				(_MacData_js__WEBPACK_IMPORTED_MODULE_4__["default"].compareWithDefault("iterations", memberValue.iterations)));
			case "parsedValue":
				return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
			default:
				throw new Error(`Invalid member name for PFX class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PFX ::= SEQUENCE {
	 *    version		INTEGER {v3(3)}(v3,...),
	 *    authSafe	ContentInfo,
	 *    macData    	MacData OPTIONAL
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [authSafe]
		 * @property {string} [macData]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "version") }),
				_ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.authSafe || {
					names: {
						blockName: "authSafe"
					}
				}),
				_MacData_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.macData || {
					names: {
						blockName: "macData",
						optional: true
					}
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"authSafe",
			"macData"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PFX.schema({
				names: {
					version: "version",
					authSafe: {
						names: {
							blockName: "authSafe"
						}
					},
					macData: {
						names: {
							blockName: "macData"
						}
					}
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PFX");
		//endregion
		
		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.authSafe = new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.authSafe });
		
		if("macData" in asn1.result)
			this.macData = new _MacData_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result.macData });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		const outputArray = [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }),
			this.authSafe.toSchema()
		];
		
		if("macData" in this)
			outputArray.push(this.macData.toSchema());
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const output = {
			version: this.version,
			authSafe: this.authSafe.toJSON()
		};
		
		if("macData" in this)
			output.macData = this.macData.toJSON();
		
		return output;
	}
	//**********************************************************************************
	/**
	 * Making ContentInfo from "parsedValue" object
	 * @param {Object} parameters Parameters, specific to each "integrity mode"
	 */
	makeInternalValues(parameters = {})
	{
		//region Check mandatory parameter
		if((parameters instanceof Object) === false)
			return Promise.reject("The \"parameters\" must has \"Object\" type");
		
		if(("parsedValue" in this) === false)
			return Promise.reject("Please call \"parseValues\" function first in order to make \"parsedValue\" data");
		
		if(("integrityMode" in this.parsedValue) === false)
			return Promise.reject("Absent mandatory parameter \"integrityMode\" inside \"parsedValue\"");
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		//endregion
		
		//region Get a "crypto" extension
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion
		
		//region Makes values for each particular integrity mode
		//region Check that we do have neccessary fields in "parsedValue" object
		if(("authenticatedSafe" in this.parsedValue) === false)
			return Promise.reject("Absent mandatory parameter \"authenticatedSafe\" in \"parsedValue\"");
		//endregion
		
		switch(this.parsedValue.integrityMode)
		{
			//region HMAC-based integrity
			case 0:
				{
					//region Check additional mandatory parameters
					if(("iterations" in parameters) === false)
						return Promise.reject("Absent mandatory parameter \"iterations\"");
				
					if(("pbkdf2HashAlgorithm" in parameters) === false)
						return Promise.reject("Absent mandatory parameter \"pbkdf2HashAlgorithm\"");
				
					if(("hmacHashAlgorithm" in parameters) === false)
						return Promise.reject("Absent mandatory parameter \"hmacHashAlgorithm\"");
				
					if(("password" in parameters) === false)
						return Promise.reject("Absent mandatory parameter \"password\"");
					//endregion
				
					//region Initial variables
					const saltBuffer = new ArrayBuffer(64);
					const saltView = new Uint8Array(saltBuffer);
				
					Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getRandomValues"])(saltView);
					
					const data = this.parsedValue.authenticatedSafe.toSchema().toBER(false);

					this.authSafe = new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
						contentType: "1.2.840.113549.1.7.1",
						content: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: data })
					});
					//endregion
					
					//region Call current crypto engine for making HMAC-based data stamp
					const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
					
					if(("stampDataWithPassword" in engine.subtle) === false)
						return Promise.reject(`No support for "stampDataWithPassword" in current engine "${engine.name}"`);
					
					sequence = sequence.then(() =>
						engine.subtle.stampDataWithPassword({
							password: parameters.password,
							hashAlgorithm: parameters.hmacHashAlgorithm,
							salt: saltBuffer,
							iterationCount: parameters.iterations,
							contentToStamp: data
						})
					);
					//endregion
					
					//region Make "MacData" values
					sequence = sequence.then(
						result =>
						{
							this.macData = new _MacData_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
								mac: new _DigestInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
									digestAlgorithm: new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
										algorithmId: Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({ name: parameters.hmacHashAlgorithm })
									}),
									digest: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: result })
								}),
								macSalt: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: saltBuffer }),
								iterations: parameters.iterations
							});
						},
						error => Promise.reject(error)
					);
					//endregion
					//endregion
				}
				break;
			//endregion
			//region publicKey-based integrity
			case 1:
				{
					//region Check additional mandatory parameters
					if(("signingCertificate" in parameters) === false)
						return Promise.reject("Absent mandatory parameter \"signingCertificate\"");
				
					if(("privateKey" in parameters) === false)
						return Promise.reject("Absent mandatory parameter \"privateKey\"");
				
					if(("hashAlgorithm" in parameters) === false)
						return Promise.reject("Absent mandatory parameter \"hashAlgorithm\"");
					//endregion
				
					//region Making data to be signed
					// NOTE: all internal data for "authenticatedSafe" must be already prepared.
					// Thus user must call "makeValues" for all internal "SafeContent" value with appropriate parameters.
					// Or user can choose to use values from initial parsing of existing PKCS#12 data.
				
					const toBeSigned = this.parsedValue.authenticatedSafe.toSchema().toBER(false);
					//endregion
					
					//region Initial variables
					const cmsSigned = new _SignedData_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
						version: 1,
						encapContentInfo: new _EncapsulatedContentInfo_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
							eContentType: "1.2.840.113549.1.7.1", // "data" content type
							eContent: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: toBeSigned })
						}),
						certificates: [parameters.signingCertificate]
					});
					//endregion
					
					//region Making additional attributes for CMS Signed Data
					//region Create a message digest
					sequence = sequence.then(
						() => crypto.digest({ name: parameters.hashAlgorithm }, new Uint8Array(toBeSigned))
					);
					//endregion
				
					//region Combine all signed extensions
					sequence = sequence.then(
						result =>
						{
							//region Initial variables
							const signedAttr = [];
							//endregion
							
							//region contentType
							signedAttr.push(new _Attribute_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
								type: "1.2.840.113549.1.9.3",
								values: [
									new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: "1.2.840.113549.1.7.1" })
								]
							}));
							//endregion
							//region signingTime
							signedAttr.push(new _Attribute_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
								type: "1.2.840.113549.1.9.5",
								values: [
									new asn1js__WEBPACK_IMPORTED_MODULE_0__["UTCTime"]({ valueDate: new Date() })
								]
							}));
							//endregion
							//region messageDigest
							signedAttr.push(new _Attribute_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
								type: "1.2.840.113549.1.9.4",
								values: [
									new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: result })
								]
							}));
							//endregion
							
							//region Making final value for "SignerInfo" type
							cmsSigned.signerInfos.push(new _SignerInfo_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
								version: 1,
								sid: new _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
									issuer: parameters.signingCertificate.issuer,
									serialNumber: parameters.signingCertificate.serialNumber
								}),
								signedAttrs: new _SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_12__["default"]({
									type: 0,
									attributes: signedAttr
								})
							}));
							//endregion
						},
						error => Promise.reject(`Error during making digest for message: ${error}`)
					);
					//endregion
					//endregion
				
					//region Signing CMS Signed Data
					sequence = sequence.then(
						() => cmsSigned.sign(parameters.privateKey, 0, parameters.hashAlgorithm)
					);
					//endregion
				
					//region Making final CMS_CONTENT_INFO type
					sequence = sequence.then(
						() =>
						{
							this.authSafe = new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
								contentType: "1.2.840.113549.1.7.2",
								content: cmsSigned.toSchema(true)
							});
						},
						error => Promise.reject(`Error during making signature: ${error}`)
					);
					//endregion
				}
				break;
			//endregion
			//region default
			default:
				return Promise.reject(`Parameter "integrityMode" has unknown value: ${parameters.integrityMode}`);
			//endregion
		}
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	parseInternalValues(parameters)
	{
		//region Check input data from "parameters" 
		if((parameters instanceof Object) === false)
			return Promise.reject("The \"parameters\" must has \"Object\" type");
		
		if(("checkIntegrity" in parameters) === false)
			parameters.checkIntegrity = true;
		//endregion 
		
		//region Initial variables 
		let sequence = Promise.resolve();
		//endregion 
		
		//region Get a "crypto" extension 
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion 
		
		//region Create value for "this.parsedValue.authenticatedSafe" and check integrity 
		this.parsedValue = {};
		
		switch(this.authSafe.contentType)
		{
			//region data 
			case "1.2.840.113549.1.7.1":
				{
					//region Check additional mandatory parameters
					if(("password" in parameters) === false)
						return Promise.reject("Absent mandatory parameter \"password\"");
					//endregion
				
					//region Integrity based on HMAC
					this.parsedValue.integrityMode = 0;
					//endregion
				
					//region Check that we do have OCTETSTRING as "content"
					if((this.authSafe.content instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]) === false)
						return Promise.reject("Wrong type of \"this.authSafe.content\"");
					//endregion
					
					//region Check we have "constructive encoding" for AuthSafe content
					let authSafeContent = new ArrayBuffer(0);
					
					if(this.authSafe.content.valueBlock.isConstructed)
					{
						for(const contentValue of this.authSafe.content.valueBlock.value)
							authSafeContent = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(authSafeContent, contentValue.valueBlock.valueHex);
					}
					else
						authSafeContent = this.authSafe.content.valueBlock.valueHex;
					//endregion
					
					//region Parse internal ASN.1 data
					const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](authSafeContent);
					if(asn1.offset === (-1))
						return Promise.reject("Error during parsing of ASN.1 data inside \"this.authSafe.content\"");
					//endregion
				
					//region Set "authenticatedSafe" value
					this.parsedValue.authenticatedSafe = new _AuthenticatedSafe_js__WEBPACK_IMPORTED_MODULE_13__["default"]({ schema: asn1.result });
					//endregion
				
					//region Check integrity
					if(parameters.checkIntegrity)
					{
						//region Check that "MacData" exists
						if(("macData" in this) === false)
							return Promise.reject("Absent \"macData\" value, can not check PKCS#12 data integrity");
						//endregion
						
						//region Initial variables
						const hashAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(this.macData.mac.digestAlgorithm.algorithmId);
						if(("name" in hashAlgorithm) === false)
							return Promise.reject(`Unsupported digest algorithm: ${this.macData.mac.digestAlgorithm.algorithmId}`);
						//endregion
						
						//region Call current crypto engine for verifying HMAC-based data stamp
						const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
						
						sequence = sequence.then(() =>
							engine.subtle.verifyDataStampedWithPassword({
								password: parameters.password,
								hashAlgorithm: hashAlgorithm.name,
								salt: this.macData.macSalt.valueBlock.valueHex,
								iterationCount: this.macData.iterations,
								contentToVerify: authSafeContent,
								signatureToVerify: this.macData.mac.digest.valueBlock.valueHex
							})
						);
						//endregion

						//region Verify HMAC signature
						sequence = sequence.then(
							result =>
							{
								if(result === false)
									return Promise.reject("Integrity for the PKCS#12 data is broken!");
								
								return Promise.resolve();
							},
							error => Promise.reject(error)
						);
						//endregion
					}
					//endregion
				}
				break;
			//endregion 
			//region signedData 
			case "1.2.840.113549.1.7.2":
				{
					//region Integrity based on signature using public key
					this.parsedValue.integrityMode = 1;
					//endregion
				
					//region Parse CMS Signed Data
					const cmsSigned = new _SignedData_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: this.authSafe.content });
					//endregion
				
					//region Check that we do have OCTETSTRING as "content"
					if(("eContent" in cmsSigned.encapContentInfo) === false)
						return Promise.reject("Absent of attached data in \"cmsSigned.encapContentInfo\"");
				
					if((cmsSigned.encapContentInfo.eContent instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]) === false)
						return Promise.reject("Wrong type of \"cmsSigned.encapContentInfo.eContent\"");
					//endregion
				
					//region Create correct data block for verification
					let data = new ArrayBuffer(0);
				
					if(cmsSigned.encapContentInfo.eContent.idBlock.isConstructed === false)
						data = cmsSigned.encapContentInfo.eContent.valueBlock.valueHex;
					else
					{
						for(let i = 0; i < cmsSigned.encapContentInfo.eContent.valueBlock.value.length; i++)
							data = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(data, cmsSigned.encapContentInfo.eContent.valueBlock.value[i].valueBlock.valueHex);
					}
					//endregion
				
					//region Parse internal ASN.1 data
					const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](data);
					if(asn1.offset === (-1))
						return Promise.reject("Error during parsing of ASN.1 data inside \"this.authSafe.content\"");
					//endregion
				
					//region Set "authenticatedSafe" value
					this.parsedValue.authenticatedSafe = new _AuthenticatedSafe_js__WEBPACK_IMPORTED_MODULE_13__["default"]({ schema: asn1.result });
					//endregion
				
					//region Check integrity
					sequence = sequence.then(
						() => cmsSigned.verify({ signer: 0, checkChain: false })
					).then(
						result =>
						{
							if(result === false)
								return Promise.reject("Integrity for the PKCS#12 data is broken!");
							
							return Promise.resolve();
						},
						error => Promise.reject(`Error during integrity verification: ${error}`)
					);
					//endregion
				}
				break;
			//endregion   
			//region default 
			default:
				return Promise.reject(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`);
			//endregion 
		}
		//endregion 
		
		//region Return result of the function 
		return sequence.then(
			() => this,
			error => Promise.reject(`Error during parsing: ${error}`)
		);
		//endregion   
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PKCS8ShroudedKeyBag.js":
/*!*******************************************************!*\
  !*** ./node_modules/pkijs/src/PKCS8ShroudedKeyBag.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PKCS8ShroudedKeyBag; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _EncryptedData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EncryptedData.js */ "./node_modules/pkijs/src/EncryptedData.js");
/* harmony import */ var _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EncryptedContentInfo.js */ "./node_modules/pkijs/src/EncryptedContentInfo.js");
/* harmony import */ var _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PrivateKeyInfo.js */ "./node_modules/pkijs/src/PrivateKeyInfo.js");






//**************************************************************************************
/**
 * Class from RFC7292
 */
class PKCS8ShroudedKeyBag 
{
	//**********************************************************************************
	/**
	 * Constructor for PKCS8ShroudedKeyBag class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc encryptionAlgorithm
		 */
		this.encryptionAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptionAlgorithm", PKCS8ShroudedKeyBag.defaultValues("encryptionAlgorithm"));
		/**
		 * @type {OctetString}
		 * @desc encryptedData
		 */
		this.encryptedData = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptedData", PKCS8ShroudedKeyBag.defaultValues("encryptedData"));
		
		if("parsedValue" in parameters)
			/**
			 * @type {*}
			 * @desc parsedValue
			 */
			this.parsedValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "parsedValue", PKCS8ShroudedKeyBag.defaultValues("parsedValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "encryptionAlgorithm":
				return (new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]());
			case "encryptedData":
				return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]());
			case "parsedValue":
				return {};
			default:
				throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "encryptionAlgorithm":
				return ((_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("algorithmId", memberValue.algorithmId)) &&
				(("algorithmParams" in memberValue) === false));
			case "encryptedData":
				return (memberValue.isEqual(PKCS8ShroudedKeyBag.defaultValues(memberName)));
			case "parsedValue":
				return ((memberValue instanceof Object) && (Object.keys(memberValue).length === 0));
			default:
				throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PKCS8ShroudedKeyBag ::= EncryptedPrivateKeyInfo
	 *
	 * EncryptedPrivateKeyInfo ::= SEQUENCE {
	 *    encryptionAlgorithm AlgorithmIdentifier {{KeyEncryptionAlgorithms}},
	 *    encryptedData EncryptedData
	 * }
	 *
	 * EncryptedData ::= OCTET STRING
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [encryptionAlgorithm]
		 * @property {string} [encryptedData]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.encryptionAlgorithm || {
					names: {
						blockName: "encryptionAlgorithm"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.encryptedData || "encryptedData") }),
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({
							idBlock: {
								isConstructed: true
							},
							name: (names.encryptedData || "encryptedData")
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"encryptionAlgorithm",
			"encryptedData"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PKCS8ShroudedKeyBag.schema({
				names: {
					encryptionAlgorithm: {
						names: {
							blockName: "encryptionAlgorithm"
						}
					},
					encryptedData: "encryptedData"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PKCS8ShroudedKeyBag");
		//endregion
		
		//region Get internal properties from parsed schema
		this.encryptionAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.encryptionAlgorithm });
		this.encryptedData = asn1.result.encryptedData;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.encryptionAlgorithm.toSchema(),
				this.encryptedData
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			encryptionAlgorithm: this.encryptionAlgorithm.toJSON(),
			encryptedData: this.encryptedData.toJSON()
		};
	}
	//**********************************************************************************
	parseInternalValues(parameters)
	{
		//region Initial variables 
		let sequence = Promise.resolve();
		
		const cmsEncrypted = new _EncryptedData_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
			encryptedContentInfo: new _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
				contentEncryptionAlgorithm: this.encryptionAlgorithm,
				encryptedContent: this.encryptedData
			})
		});
		//endregion 
		
		//region Decrypt internal data 
		sequence = sequence.then(
			() => cmsEncrypted.decrypt(parameters),
			error => Promise.reject(error)
		);
		//endregion 
		
		//region Initialize "parsedValue" with decrypted PKCS#8 private key 
		sequence = sequence.then(
			/**
			 * @param {ArrayBuffer} result
			 */
			result =>
			{
				const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](result);
				if(asn1.offset === (-1))
					return Promise.reject("Error during parsing ASN.1 data");
				
				this.parsedValue = new _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result });
				
				return Promise.resolve();
			},
			error => Promise.reject(error)
		);
		//endregion 
		
		return sequence;
	}
	//**********************************************************************************
	makeInternalValues(parameters)
	{
		//region Check that we do have "parsedValue" 
		if(("parsedValue" in this) === false)
			return Promise.reject("Please initialize \"parsedValue\" first");
		//endregion 
		
		//region Initial variables 
		let sequence = Promise.resolve();
		
		const cmsEncrypted = new _EncryptedData_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
		//endregion 
		
		//region Encrypt internal data 
		sequence = sequence.then(
			() =>
			{
				parameters.contentToEncrypt = this.parsedValue.toSchema().toBER(false);
				
				return cmsEncrypted.encrypt(parameters);
			},
			error => Promise.reject(error)
		);
		//endregion 
		
		//region Initialize internal values 
		sequence = sequence.then(
			() =>
			{
				this.encryptionAlgorithm = cmsEncrypted.encryptedContentInfo.contentEncryptionAlgorithm;
				this.encryptedData = cmsEncrypted.encryptedContentInfo.encryptedContent;
			}
		);
		//endregion 
		
		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PKIStatusInfo.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/PKIStatusInfo.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PKIStatusInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC3161
 */
class PKIStatusInfo
{
	//**********************************************************************************
	/**
	 * Constructor for PKIStatusInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc status
		 */
		this.status = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "status", PKIStatusInfo.defaultValues("status"));

		if("statusStrings" in parameters)
			/**
			 * @type {Array.<Utf8String>}
			 * @desc statusStrings
			 */
			this.statusStrings = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "statusStrings", PKIStatusInfo.defaultValues("statusStrings"));

		if("failInfo" in parameters)
			/**
			 * @type {BitString}
			 * @desc failInfo
			 */
			this.failInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "failInfo", PKIStatusInfo.defaultValues("failInfo"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "status":
				return 2;
			case "statusStrings":
				return [];
			case "failInfo":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for PKIStatusInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "status":
				return (memberValue === PKIStatusInfo.defaultValues(memberName));
			case "statusStrings":
				return (memberValue.length === 0);
			case "failInfo":
				return (memberValue.isEqual(PKIStatusInfo.defaultValues(memberName)));
			default:
				throw new Error(`Invalid member name for PKIStatusInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PKIStatusInfo ::= SEQUENCE {
	 *    status        PKIStatus,
	 *    statusString  PKIFreeText     OPTIONAL,
	 *    failInfo      PKIFailureInfo  OPTIONAL  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [status]
		 * @property {string} [statusStrings]
		 * @property {string} [failInfo]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.status || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					optional: true,
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.statusStrings || ""),
							value: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Utf8String"]()
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({
					name: (names.failInfo || ""),
					optional: true
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"status",
			"statusStrings",
			"failInfo"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PKIStatusInfo.schema({
				names: {
					status: "status",
					statusStrings: "statusStrings",
					failInfo: "failInfo"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PKIStatusInfo");
		//endregion

		//region Get internal properties from parsed schema
		const _status = asn1.result.status;

		if((_status.valueBlock.isHexOnly === true) ||
			(_status.valueBlock.valueDec < 0) ||
			(_status.valueBlock.valueDec > 5))
			throw new Error("PKIStatusInfo \"status\" has invalid value");

		this.status = _status.valueBlock.valueDec;

		if("statusStrings" in asn1.result)
			this.statusStrings = asn1.result.statusStrings;
		if("failInfo" in asn1.result)
			this.failInfo = asn1.result.failInfo;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array of output sequence
		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.status }));

		if("statusStrings" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				optional: true,
				value: this.statusStrings
			}));
		}

		if("failInfo" in this)
			outputArray.push(this.failInfo);
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			status: this.status
		};

		if("statusStrings" in this)
			_object.statusStrings = Array.from(this.statusStrings, element => element.toJSON());

		if("failInfo" in this)
			_object.failInfo = this.failInfo.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PasswordRecipientinfo.js":
/*!*********************************************************!*\
  !*** ./node_modules/pkijs/src/PasswordRecipientinfo.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PasswordRecipientinfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class PasswordRecipientinfo
{
	//**********************************************************************************
	/**
	 * Constructor for PasswordRecipientinfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", PasswordRecipientinfo.defaultValues("version"));

		if("keyDerivationAlgorithm" in parameters)
			/**
			 * @type {AlgorithmIdentifier}
			 * @desc keyDerivationAlgorithm
			 */
			this.keyDerivationAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyDerivationAlgorithm", PasswordRecipientinfo.defaultValues("keyDerivationAlgorithm"));

		/**
		 * @type {AlgorithmIdentifier}
		 * @desc keyEncryptionAlgorithm
		 */
		this.keyEncryptionAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "keyEncryptionAlgorithm", PasswordRecipientinfo.defaultValues("keyEncryptionAlgorithm"));
		/**
		 * @type {OctetString}
		 * @desc encryptedKey
		 */
		this.encryptedKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptedKey", PasswordRecipientinfo.defaultValues("encryptedKey"));
		/**
		 * @type {ArrayBuffer}
		 * @desc password Password to derive key from
		 */
		this.password = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "password", PasswordRecipientinfo.defaultValues("password"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return (-1);
			case "keyDerivationAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "keyEncryptionAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "encryptedKey":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "password":
				return new ArrayBuffer(0);
			default:
				throw new Error(`Invalid member name for PasswordRecipientinfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
				return (memberValue === (-1));
			case "keyDerivationAlgorithm":
			case "keyEncryptionAlgorithm":
				return ((memberValue.algorithmId === "") && (("algorithmParams" in memberValue) === false));
			case "encryptedKey":
				return (memberValue.isEqual(PasswordRecipientinfo.defaultValues("encryptedKey")));
			case "password":
				return (memberValue.byteLength === 0);
			default:
				throw new Error(`Invalid member name for PasswordRecipientinfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PasswordRecipientInfo ::= SEQUENCE {
	 *    version CMSVersion,   -- Always set to 0
	 *    keyDerivationAlgorithm [0] KeyDerivationAlgorithmIdentifier OPTIONAL,
	 *    keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
	 *    encryptedKey EncryptedKey }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [keyDerivationAlgorithm]
		 * @property {string} [keyEncryptionAlgorithm]
		 * @property {string} [encryptedKey]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.keyDerivationAlgorithm || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema().valueBlock.value
				}),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.keyEncryptionAlgorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.encryptedKey || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"keyDerivationAlgorithm",
			"keyEncryptionAlgorithm",
			"encryptedKey"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PasswordRecipientinfo.schema({
				names: {
					version: "version",
					keyDerivationAlgorithm: "keyDerivationAlgorithm",
					keyEncryptionAlgorithm: {
						names: {
							blockName: "keyEncryptionAlgorithm"
						}
					},
					encryptedKey: "encryptedKey"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PasswordRecipientinfo");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;

		if("keyDerivationAlgorithm" in asn1.result)
		{
			this.keyDerivationAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: asn1.result.keyDerivationAlgorithm.valueBlock.value
				})
			});
		}

		this.keyEncryptionAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.keyEncryptionAlgorithm });
		this.encryptedKey = asn1.result.encryptedKey;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create output array for sequence
		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));

		if("keyDerivationAlgorithm" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: this.keyDerivationAlgorithm.toSchema().valueBlock.value
			}));
		}

		outputArray.push(this.keyEncryptionAlgorithm.toSchema());
		outputArray.push(this.encryptedKey);
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			version: this.version,
			keyDerivationAlgorithm: this.keyDerivationAlgorithm.toJSON(),
			keyEncryptionAlgorithm: this.keyEncryptionAlgorithm.toJSON(),
			encryptedKey: this.encryptedKey.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PolicyConstraints.js":
/*!*****************************************************!*\
  !*** ./node_modules/pkijs/src/PolicyConstraints.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolicyConstraints; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5280
 */
class PolicyConstraints
{
	//**********************************************************************************
	/**
	 * Constructor for PolicyConstraints class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("requireExplicitPolicy" in parameters)
			/**
			 * @type {number}
			 * @desc requireExplicitPolicy
			 */
			this.requireExplicitPolicy = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "requireExplicitPolicy", PolicyConstraints.defaultValues("requireExplicitPolicy"));

		if("inhibitPolicyMapping" in parameters)
			/**
			 * @type {number}
			 * @desc Value of the TIME class
			 */
			this.inhibitPolicyMapping = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "inhibitPolicyMapping", PolicyConstraints.defaultValues("inhibitPolicyMapping"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "requireExplicitPolicy":
				return 0;
			case "inhibitPolicyMapping":
				return 0;
			default:
				throw new Error(`Invalid member name for PolicyConstraints class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PolicyConstraints ::= SEQUENCE {
	 *    requireExplicitPolicy           [0] SkipCerts OPTIONAL,
	 *    inhibitPolicyMapping            [1] SkipCerts OPTIONAL }
	 *
	 * SkipCerts ::= INTEGER (0..MAX)
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [requireExplicitPolicy]
		 * @property {string} [inhibitPolicyMapping]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.requireExplicitPolicy || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					}
				}), // IMPLICIT integer value
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.inhibitPolicyMapping || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					}
				}) // IMPLICIT integer value
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"requireExplicitPolicy",
			"inhibitPolicyMapping"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PolicyConstraints.schema({
				names: {
					requireExplicitPolicy: "requireExplicitPolicy",
					inhibitPolicyMapping: "inhibitPolicyMapping"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PolicyConstraints");
		//endregion

		//region Get internal properties from parsed schema
		if("requireExplicitPolicy" in asn1.result)
		{
			const field1 = asn1.result.requireExplicitPolicy;

			field1.idBlock.tagClass = 1; // UNIVERSAL
			field1.idBlock.tagNumber = 2; // INTEGER

			const ber1 = field1.toBER(false);
			const int1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](ber1);

			this.requireExplicitPolicy = int1.result.valueBlock.valueDec;
		}

		if("inhibitPolicyMapping" in asn1.result)
		{
			const field2 = asn1.result.inhibitPolicyMapping;

			field2.idBlock.tagClass = 1; // UNIVERSAL
			field2.idBlock.tagNumber = 2; // INTEGER

			const ber2 = field2.toBER(false);
			const int2 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](ber2);

			this.inhibitPolicyMapping = int2.result.valueBlock.valueDec;
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create correct values for output sequence
		const outputArray = [];
		
		if("requireExplicitPolicy" in this)
		{
			const int1 = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.requireExplicitPolicy });
			
			int1.idBlock.tagClass = 3; // CONTEXT-SPECIFIC
			int1.idBlock.tagNumber = 0; // [0]
			
			outputArray.push(int1);
		}
		
		if("inhibitPolicyMapping" in this)
		{
			const int2 = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.inhibitPolicyMapping });
			
			int2.idBlock.tagClass = 3; // CONTEXT-SPECIFIC
			int2.idBlock.tagNumber = 1; // [1]
			
			outputArray.push(int2);
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};

		if("requireExplicitPolicy" in this)
			object.requireExplicitPolicy = this.requireExplicitPolicy;

		if("inhibitPolicyMapping" in this)
			object.inhibitPolicyMapping = this.inhibitPolicyMapping;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PolicyInformation.js":
/*!*****************************************************!*\
  !*** ./node_modules/pkijs/src/PolicyInformation.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolicyInformation; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _PolicyQualifierInfo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PolicyQualifierInfo.js */ "./node_modules/pkijs/src/PolicyQualifierInfo.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class PolicyInformation
{
	//**********************************************************************************
	/**
	 * Constructor for PolicyInformation class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc policyIdentifier
		 */
		this.policyIdentifier = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "policyIdentifier", PolicyInformation.defaultValues("policyIdentifier"));

		if("policyQualifiers" in parameters)
			/**
			 * @type {Array.<PolicyQualifierInfo>}
			 * @desc Value of the TIME class
			 */
			this.policyQualifiers = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "policyQualifiers", PolicyInformation.defaultValues("policyQualifiers"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "policyIdentifier":
				return "";
			case "policyQualifiers":
				return [];
			default:
				throw new Error(`Invalid member name for PolicyInformation class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PolicyInformation ::= SEQUENCE {
	 *    policyIdentifier   CertPolicyId,
	 *    policyQualifiers   SEQUENCE SIZE (1..MAX) OF
	 *    PolicyQualifierInfo OPTIONAL }
	 *
	 * CertPolicyId ::= OBJECT IDENTIFIER
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [policyIdentifier]
		 * @property {string} [policyQualifiers]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.policyIdentifier || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					optional: true,
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.policyQualifiers || ""),
							value: _PolicyQualifierInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"policyIdentifier",
			"policyQualifiers"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PolicyInformation.schema({
				names: {
					policyIdentifier: "policyIdentifier",
					policyQualifiers: "policyQualifiers"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PolicyInformation");
		//endregion

		//region Get internal properties from parsed schema
		this.policyIdentifier = asn1.result.policyIdentifier.valueBlock.toString();

		if("policyQualifiers" in asn1.result)
			this.policyQualifiers = Array.from(asn1.result.policyQualifiers, element => new _PolicyQualifierInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.policyIdentifier }));
		
		if("policyQualifiers" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: Array.from(this.policyQualifiers, element => element.toSchema())
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			policyIdentifier: this.policyIdentifier
		};

		if("policyQualifiers" in this)
			object.policyQualifiers = Array.from(this.policyQualifiers, element => element.toJSON());

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PolicyMapping.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/PolicyMapping.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolicyMapping; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5280
 */
class PolicyMapping
{
	//**********************************************************************************
	/**
	 * Constructor for PolicyMapping class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc issuerDomainPolicy
		 */
		this.issuerDomainPolicy = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "issuerDomainPolicy", PolicyMapping.defaultValues("issuerDomainPolicy"));
		/**
		 * @type {string}
		 * @desc subjectDomainPolicy
		 */
		this.subjectDomainPolicy = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subjectDomainPolicy", PolicyMapping.defaultValues("subjectDomainPolicy"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "issuerDomainPolicy":
				return "";
			case "subjectDomainPolicy":
				return "";
			default:
				throw new Error(`Invalid member name for PolicyMapping class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PolicyMapping ::= SEQUENCE {
	 *    issuerDomainPolicy      CertPolicyId,
	 *    subjectDomainPolicy     CertPolicyId }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [issuerDomainPolicy]
		 * @property {string} [subjectDomainPolicy]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.issuerDomainPolicy || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.subjectDomainPolicy || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"issuerDomainPolicy",
			"subjectDomainPolicy"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PolicyMapping.schema({
				names: {
					issuerDomainPolicy: "issuerDomainPolicy",
					subjectDomainPolicy: "subjectDomainPolicy"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PolicyMapping");
		//endregion

		//region Get internal properties from parsed schema
		this.issuerDomainPolicy = asn1.result.issuerDomainPolicy.valueBlock.toString();
		this.subjectDomainPolicy = asn1.result.subjectDomainPolicy.valueBlock.toString();
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.issuerDomainPolicy }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.subjectDomainPolicy })
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			issuerDomainPolicy: this.issuerDomainPolicy,
			subjectDomainPolicy: this.subjectDomainPolicy
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PolicyMappings.js":
/*!**************************************************!*\
  !*** ./node_modules/pkijs/src/PolicyMappings.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolicyMappings; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _PolicyMapping_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PolicyMapping.js */ "./node_modules/pkijs/src/PolicyMapping.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class PolicyMappings
{
	//**********************************************************************************
	/**
	 * Constructor for PolicyMappings class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<PolicyMapping>}
		 * @desc mappings
		 */
		this.mappings = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "mappings", PolicyMappings.defaultValues("mappings"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "mappings":
				return [];
			default:
				throw new Error(`Invalid member name for PolicyMappings class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF PolicyMapping
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [utcTimeName] Name for "utcTimeName" choice
		 * @property {string} [generalTimeName] Name for "generalTimeName" choice
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.mappings || ""),
					value: _PolicyMapping_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"mappings"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PolicyMappings.schema({
				names: {
					mappings: "mappings"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PolicyMappings");
		//endregion

		//region Get internal properties from parsed schema
		this.mappings = Array.from(asn1.result.mappings, element => new _PolicyMapping_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.mappings, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			mappings: Array.from(this.mappings, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PolicyQualifierInfo.js":
/*!*******************************************************!*\
  !*** ./node_modules/pkijs/src/PolicyQualifierInfo.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolicyQualifierInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5280
 */
class PolicyQualifierInfo
{
	//**********************************************************************************
	/**
	 * Constructor for PolicyQualifierInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc policyQualifierId
		 */
		this.policyQualifierId = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "policyQualifierId", PolicyQualifierInfo.defaultValues("policyQualifierId"));
		/**
		 * @type {Object}
		 * @desc qualifier
		 */
		this.qualifier = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "qualifier", PolicyQualifierInfo.defaultValues("qualifier"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "policyQualifierId":
				return "";
			case "qualifier":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
			default:
				throw new Error(`Invalid member name for PolicyQualifierInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PolicyQualifierInfo ::= SEQUENCE {
	 *    policyQualifierId  PolicyQualifierId,
	 *    qualifier          ANY DEFINED BY policyQualifierId }
	 *
	 * id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }
	 * id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }
	 * id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }
	 *
	 * PolicyQualifierId ::= OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [policyQualifierId]
		 * @property {string} [qualifier]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.policyQualifierId || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.qualifier || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"policyQualifierId",
			"qualifier"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PolicyQualifierInfo.schema({
				names: {
					policyQualifierId: "policyQualifierId",
					qualifier: "qualifier"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.policyQualifierId = asn1.result.policyQualifierId.valueBlock.toString();
		this.qualifier = asn1.result.qualifier;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.policyQualifierId }),
				this.qualifier
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			policyQualifierId: this.policyQualifierId,
			qualifier: this.qualifier.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PrivateKeyInfo.js":
/*!**************************************************!*\
  !*** ./node_modules/pkijs/src/PrivateKeyInfo.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PrivateKeyInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");
/* harmony import */ var _ECPrivateKey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ECPrivateKey.js */ "./node_modules/pkijs/src/ECPrivateKey.js");
/* harmony import */ var _RSAPrivateKey_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RSAPrivateKey.js */ "./node_modules/pkijs/src/RSAPrivateKey.js");






//**************************************************************************************
/**
 * Class from RFC5208
 */
class PrivateKeyInfo
{
	//**********************************************************************************
	/**
	 * Constructor for PrivateKeyInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", PrivateKeyInfo.defaultValues("version"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc privateKeyAlgorithm
		 */
		this.privateKeyAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "privateKeyAlgorithm", PrivateKeyInfo.defaultValues("privateKeyAlgorithm"));
		/**
		 * @type {OctetString}
		 * @desc privateKey
		 */
		this.privateKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "privateKey", PrivateKeyInfo.defaultValues("privateKey"));

		if("attributes" in parameters)
			/**
			 * @type {Array.<Attribute>}
			 * @desc attributes
			 */
			this.attributes = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "attributes", PrivateKeyInfo.defaultValues("attributes"));

		if("parsedKey" in parameters)
			/**
			 * @type {ECPrivateKey|RSAPrivateKey}
			 * @desc Parsed public key value
			 */
			this.parsedKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "parsedKey", PrivateKeyInfo.defaultValues("parsedKey"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
		//region If input argument array contains "json" for this object
		if("json" in parameters)
			this.fromJSON(parameters.json);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "privateKeyAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "privateKey":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "attributes":
				return [];
			case "parsedKey":
				return {};
			default:
				throw new Error(`Invalid member name for PrivateKeyInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PrivateKeyInfo ::= SEQUENCE {
	 *    version Version,
	 *    privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}},
	 *    privateKey PrivateKey,
	 *    attributes [0] Attributes OPTIONAL }
	 *
	 * Version ::= INTEGER {v1(0)} (v1,...)
	 *
	 * PrivateKey ::= OCTET STRING
	 *
	 * Attributes ::= SET OF Attribute
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [privateKeyAlgorithm]
		 * @property {string} [privateKey]
		 * @property {string} [attributes]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.privateKeyAlgorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.privateKey || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.attributes || ""),
							value: _Attribute_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"privateKeyAlgorithm",
			"privateKey",
			"attributes"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PrivateKeyInfo.schema({
				names: {
					version: "version",
					privateKeyAlgorithm: {
						names: {
							blockName: "privateKeyAlgorithm"
						}
					},
					privateKey: "privateKey",
					attributes: "attributes"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PrivateKeyInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.privateKeyAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.privateKeyAlgorithm });
		this.privateKey = asn1.result.privateKey;

		if("attributes" in asn1.result)
			this.attributes = Array.from(asn1.result.attributes, element => new _Attribute_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: element }));

		switch(this.privateKeyAlgorithm.algorithmId)
		{
			case "1.2.840.113549.1.1.1": // RSA
				{
					const privateKeyASN1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.privateKey.valueBlock.valueHex);
					if(privateKeyASN1.offset !== (-1))
						this.parsedKey = new _RSAPrivateKey_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: privateKeyASN1.result });
				}
				break;
			case "1.2.840.10045.2.1": // ECDSA
				if("algorithmParams" in this.privateKeyAlgorithm)
				{
					if(this.privateKeyAlgorithm.algorithmParams instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"])
					{
						const privateKeyASN1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.privateKey.valueBlock.valueHex);
						if(privateKeyASN1.offset !== (-1))
						{
							this.parsedKey = new _ECPrivateKey_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
								namedCurve: this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),
								schema: privateKeyASN1.result
							});
						}
					}
				}
				break;
			default:
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }),
			this.privateKeyAlgorithm.toSchema(),
			this.privateKey
		];

		if("attributes" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: Array.from(this.attributes, element => element.toSchema())
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		//region Return common value in case we do not have enough info fo making JWK
		if(("parsedKey" in this) === false)
		{
			const object = {
				version: this.version,
				privateKeyAlgorithm: this.privateKeyAlgorithm.toJSON(),
				privateKey: this.privateKey.toJSON()
			};

			if("attributes" in this)
				object.attributes = Array.from(this.attributes, element => element.toJSON());

			return object;
		}
		//endregion

		//region Making JWK
		const jwk = {};

		switch(this.privateKeyAlgorithm.algorithmId)
		{
			case "1.2.840.10045.2.1": // ECDSA
				jwk.kty = "EC";
				break;
			case "1.2.840.113549.1.1.1": // RSA
				jwk.kty = "RSA";
				break;
			default:
		}

		const publicKeyJWK = this.parsedKey.toJSON();

		for(const key of Object.keys(publicKeyJWK))
			jwk[key] = publicKeyJWK[key];

		return jwk;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert JSON value into current object
	 * @param {Object} json
	 */
	fromJSON(json)
	{
		if("kty" in json)
		{
			switch(json.kty.toUpperCase())
			{
				case "EC":
					this.parsedKey = new _ECPrivateKey_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ json });

					this.privateKeyAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
						algorithmId: "1.2.840.10045.2.1",
						algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.parsedKey.namedCurve })
					});
					break;
				case "RSA":
					this.parsedKey = new _RSAPrivateKey_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ json });

					this.privateKeyAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
						algorithmId: "1.2.840.113549.1.1.1",
						algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
					});
					break;
				default:
					throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
			}

			this.privateKey = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: this.parsedKey.toSchema().toBER(false) });
		}
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PrivateKeyUsagePeriod.js":
/*!*********************************************************!*\
  !*** ./node_modules/pkijs/src/PrivateKeyUsagePeriod.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PrivateKeyUsagePeriod; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5280
 */
class PrivateKeyUsagePeriod
{
	//**********************************************************************************
	/**
	 * Constructor for PrivateKeyUsagePeriod class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		if("notBefore" in parameters)
			/**
			 * @type {Date}
			 * @desc notBefore
			 */
			this.notBefore = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "notBefore", PrivateKeyUsagePeriod.defaultValues("notBefore"));

		if("notAfter" in parameters)
			/**
			 * @type {Date}
			 * @desc notAfter
			 */
			this.notAfter = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "notAfter", PrivateKeyUsagePeriod.defaultValues("notAfter"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "notBefore":
				return new Date();
			case "notAfter":
				return new Date();
			default:
				throw new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * PrivateKeyUsagePeriod OID ::= 2.5.29.16
	 *
	 * PrivateKeyUsagePeriod ::= SEQUENCE {
	 *    notBefore       [0]     GeneralizedTime OPTIONAL,
	 *    notAfter        [1]     GeneralizedTime OPTIONAL }
	 * -- either notBefore or notAfter MUST be present
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [notBefore]
		 * @property {string} [notAfter]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.notBefore || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.notAfter || ""),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					}
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"notBefore",
			"notAfter"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PrivateKeyUsagePeriod.schema({
				names: {
					notBefore: "notBefore",
					notAfter: "notAfter"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");
		//endregion

		//region Get internal properties from parsed schema
		if("notBefore" in asn1.result)
		{
			const localNotBefore = new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]();
			localNotBefore.fromBuffer(asn1.result.notBefore.valueBlock.valueHex);
			this.notBefore = localNotBefore.toDate();
		}

		if("notAfter" in asn1.result)
		{
			const localNotAfter = new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueHex: asn1.result.notAfter.valueBlock.valueHex });
			localNotAfter.fromBuffer(asn1.result.notAfter.valueBlock.valueHex);
			this.notAfter = localNotAfter.toDate();
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if("notBefore" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				valueHex: (new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueDate: this.notBefore })).valueBlock.valueHex
			}));
		}
		
		if("notAfter" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				valueHex: (new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueDate: this.notAfter })).valueBlock.valueHex
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};

		if("notBefore" in this)
			object.notBefore = this.notBefore;

		if("notAfter" in this)
			object.notAfter = this.notAfter;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/PublicKeyInfo.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/PublicKeyInfo.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PublicKeyInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _ECPublicKey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ECPublicKey.js */ "./node_modules/pkijs/src/ECPublicKey.js");
/* harmony import */ var _RSAPublicKey_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RSAPublicKey.js */ "./node_modules/pkijs/src/RSAPublicKey.js");






//**************************************************************************************
/**
 * Class from RFC5280
 */
class PublicKeyInfo 
{
	//**********************************************************************************
	/**
	 * Constructor for PublicKeyInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc Algorithm identifier
		 */
		this.algorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "algorithm", PublicKeyInfo.defaultValues("algorithm"));
		/**
		 * @type {BitString}
		 * @desc Subject public key value
		 */
		this.subjectPublicKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subjectPublicKey", PublicKeyInfo.defaultValues("subjectPublicKey"));
		
		if("parsedKey" in parameters)
			/**
			 * @type {ECPublicKey|RSAPublicKey}
			 * @desc Parsed public key value
			 */
			this.parsedKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "parsedKey", PublicKeyInfo.defaultValues("parsedKey"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
		//region If input argument array contains "json" for this object
		if("json" in parameters)
			this.fromJSON(parameters.json);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "algorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "subjectPublicKey":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			default:
				throw new Error(`Invalid member name for PublicKeyInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SubjectPublicKeyInfo  ::=  Sequence  {
	 *    algorithm            AlgorithmIdentifier,
	 *    subjectPublicKey     BIT STRING  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [algorithm]
		 * @property {string} [subjectPublicKey]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.algorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.subjectPublicKey || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"algorithm",
			"subjectPublicKey"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			PublicKeyInfo.schema({
				names: {
					algorithm: {
						names: {
							blockName: "algorithm"
						}
					},
					subjectPublicKey: "subjectPublicKey"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for PublicKeyInfo");
		//endregion
		
		//region Get internal properties from parsed schema
		this.algorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.algorithm });
		this.subjectPublicKey = asn1.result.subjectPublicKey;
		
		switch(this.algorithm.algorithmId)
		{
			case "1.2.840.10045.2.1": // ECDSA
				if("algorithmParams" in this.algorithm)
				{
					if(this.algorithm.algorithmParams.constructor.blockName() === asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"].blockName())
					{
						try
						{
							this.parsedKey = new _ECPublicKey_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
								namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),
								schema: this.subjectPublicKey.valueBlock.valueHex
							});
						}
						catch(ex){} // Could be a problems during recognision of internal public key data here. Let's ignore them.
					}
				}
				break;
			case "1.2.840.113549.1.1.1": // RSA
				{
					const publicKeyASN1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.subjectPublicKey.valueBlock.valueHex);
					if(publicKeyASN1.offset !== (-1))
					{
						try
						{
							this.parsedKey = new _RSAPublicKey_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: publicKeyASN1.result });
						}
						catch(ex){} // Could be a problems during recognision of internal public key data here. Let's ignore them.
					}
				}
				break;
			default:
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.algorithm.toSchema(),
				this.subjectPublicKey
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		//region Return common value in case we do not have enough info fo making JWK
		if(("parsedKey" in this) === false)
		{
			return {
				algorithm: this.algorithm.toJSON(),
				subjectPublicKey: this.subjectPublicKey.toJSON()
			};
		}
		//endregion
		
		//region Making JWK
		const jwk = {};
		
		switch(this.algorithm.algorithmId)
		{
			case "1.2.840.10045.2.1": // ECDSA
				jwk.kty = "EC";
				break;
			case "1.2.840.113549.1.1.1": // RSA
				jwk.kty = "RSA";
				break;
			default:
		}
		
		const publicKeyJWK = this.parsedKey.toJSON();
		
		for(const key of Object.keys(publicKeyJWK))
			jwk[key] = publicKeyJWK[key];
		
		return jwk;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert JSON value into current object
	 * @param {Object} json
	 */
	fromJSON(json)
	{
		if("kty" in json)
		{
			switch(json.kty.toUpperCase())
			{
				case "EC":
					this.parsedKey = new _ECPublicKey_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ json });
					
					this.algorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
						algorithmId: "1.2.840.10045.2.1",
						algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.parsedKey.namedCurve })
					});
					break;
				case "RSA":
					this.parsedKey = new _RSAPublicKey_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ json });
					
					this.algorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
						algorithmId: "1.2.840.113549.1.1.1",
						algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
					});
					break;
				default:
					throw new Error(`Invalid value for "kty" parameter: ${json.kty}`);
			}
			
			this.subjectPublicKey = new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ valueHex: this.parsedKey.toSchema().toBER(false) });
		}
	}
	//**********************************************************************************
	importKey(publicKey)
	{
		//region Initial variables
		let sequence = Promise.resolve();
		const _this = this;
		//endregion
		
		//region Initial check
		if(typeof publicKey === "undefined")
			return Promise.reject("Need to provide publicKey input parameter");
		//endregion
		
		//region Get a "crypto" extension
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion
		
		//region Export public key
		sequence = sequence.then(() =>
			crypto.exportKey("spki", publicKey));
		//endregion
		
		//region Initialize internal variables by parsing exported value
		sequence = sequence.then(
			/**
			 * @param {ArrayBuffer} exportedKey
			 */
			exportedKey =>
			{
				const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](exportedKey);
				try
				{
					_this.fromSchema(asn1.result);
				}
				catch(exception)
				{
					return Promise.reject("Error during initializing object from schema");
				}
				
				return undefined;
			},
			error => Promise.reject(`Error during exporting public key: ${error}`)
		);
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/QCStatements.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/QCStatements.js ***!
  \************************************************/
/*! exports provided: QCStatement, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QCStatement", function() { return QCStatement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return QCStatements; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC3739
 */
class QCStatement
{
	//**********************************************************************************
	/**
	 * Constructor for QCStatement class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 */
		this.id = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "id", QCStatement.defaultValues("id"));

		if("type" in parameters)
		{
			/**
			 * @type {*} Any data described by "id"
			 */
			this.type = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "type", QCStatement.defaultValues("type"));
		}
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "id":
				return "";
			case "type":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]();
			default:
				throw new Error(`Invalid member name for QCStatement class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "id":
				return (memberValue === "");
			case "type":
				return (memberValue instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]);
			default:
				throw new Error(`Invalid member name for QCStatement class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
 	 *	 QCStatement ::= SEQUENCE {
	 *       statementId   QC-STATEMENT.&id({SupportedStatements}),
	 *       statementInfo QC-STATEMENT.&Type({SupportedStatements}{@statementId}) OPTIONAL
	 *   }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [id]
		 * @property {string} [type]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.id || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({
					name: (names.type || ""),
					optional: true
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"id",
			"type"
		]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			QCStatement.schema({
				names: {
					id: "id",
					type: "type"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for QCStatement");
		//endregion

		//region Get internal properties from parsed schema
		this.id = asn1.result.id.valueBlock.toString();

		if("type" in asn1.result)
			this.type = asn1.result.type;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const value = [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.id })
		];

		if("type" in this)
			value.push(this.type);

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			id: this.id
		};

		if("type" in this)
			object.type = this.type.toJSON();

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Class from RFC3739
 */
class QCStatements
{
	//**********************************************************************************
	/**
	 * Constructor for QCStatements class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array<QCStatement>}
		 */
		this.values = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "values", QCStatements.defaultValues("values"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "values":
				return [];
			default:
				throw new Error(`Invalid member name for QCStatements class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "values":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for QCStatements class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * QCStatements ::= SEQUENCE OF QCStatement
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [values]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.values || ""),
					value: QCStatement.schema(names.value || {})
				}),
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"values"
		]);
		//endregion

		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			QCStatements.schema({
				names: {
					values: "values"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for QCStatements");
		//endregion

		//region Get internal properties from parsed schema
		this.values = Array.from(asn1.result.values, element => new QCStatement({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.values, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			extensions: Array.from(this.values, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RSAESOAEPParams.js":
/*!***************************************************!*\
  !*** ./node_modules/pkijs/src/RSAESOAEPParams.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RSAESOAEPParams; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC3447
 */
class RSAESOAEPParams
{
	//**********************************************************************************
	/**
	 * Constructor for RSAESOAEPParams class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc hashAlgorithm
		 */
		this.hashAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "hashAlgorithm", RSAESOAEPParams.defaultValues("hashAlgorithm"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc maskGenAlgorithm
		 */
		this.maskGenAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "maskGenAlgorithm", RSAESOAEPParams.defaultValues("maskGenAlgorithm"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc pSourceAlgorithm
		 */
		this.pSourceAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "pSourceAlgorithm", RSAESOAEPParams.defaultValues("pSourceAlgorithm"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "hashAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
					algorithmId: "1.3.14.3.2.26", // SHA-1
					algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
				});
			case "maskGenAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
					algorithmId: "1.2.840.113549.1.1.8", // MGF1
					algorithmParams: (new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
						algorithmId: "1.3.14.3.2.26", // SHA-1
						algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
					})).toSchema()
				});
			case "pSourceAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
					algorithmId: "1.2.840.113549.1.1.9", // id-pSpecified
					algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: (new Uint8Array([0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90, 0xaf, 0xd8, 0x07, 0x09])).buffer }) // SHA-1 hash of empty string
				});
			default:
				throw new Error(`Invalid member name for RSAESOAEPParams class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RSAES-OAEP-params ::= SEQUENCE {
	 *    hashAlgorithm     [0] HashAlgorithm    DEFAULT sha1,
	 *    maskGenAlgorithm  [1] MaskGenAlgorithm DEFAULT mgf1SHA1,
	 *    pSourceAlgorithm  [2] PSourceAlgorithm DEFAULT pSpecifiedEmpty
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [hashAlgorithm]
		 * @property {string} [maskGenAlgorithm]
		 * @property {string} [pSourceAlgorithm]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					optional: true,
					value: [_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.hashAlgorithm || {})]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					optional: true,
					value: [_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.maskGenAlgorithm || {})]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					optional: true,
					value: [_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.pSourceAlgorithm || {})]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"hashAlgorithm",
			"maskGenAlgorithm",
			"pSourceAlgorithm"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RSAESOAEPParams.schema({
				names: {
					hashAlgorithm: {
						names: {
							blockName: "hashAlgorithm"
						}
					},
					maskGenAlgorithm: {
						names: {
							blockName: "maskGenAlgorithm"
						}
					},
					pSourceAlgorithm: {
						names: {
							blockName: "pSourceAlgorithm"
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RSAESOAEPParams");
		//endregion

		//region Get internal properties from parsed schema
		if("hashAlgorithm" in asn1.result)
			this.hashAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.hashAlgorithm });

		if("maskGenAlgorithm" in asn1.result)
			this.maskGenAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.maskGenAlgorithm });

		if("pSourceAlgorithm" in asn1.result)
			this.pSourceAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.pSourceAlgorithm });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if(!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues("hashAlgorithm")))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [this.hashAlgorithm.toSchema()]
			}));
		}
		
		if(!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues("maskGenAlgorithm")))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: [this.maskGenAlgorithm.toSchema()]
			}));
		}

		if(!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues("pSourceAlgorithm")))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 2 // [2]
				},
				value: [this.pSourceAlgorithm.toSchema()]
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};

		if(!this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues("hashAlgorithm")))
			object.hashAlgorithm = this.hashAlgorithm.toJSON();

		if(!this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues("maskGenAlgorithm")))
			object.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();

		if(!this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues("pSourceAlgorithm")))
			object.pSourceAlgorithm = this.pSourceAlgorithm.toJSON();

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RSAPrivateKey.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/RSAPrivateKey.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RSAPrivateKey; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _OtherPrimeInfo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OtherPrimeInfo.js */ "./node_modules/pkijs/src/OtherPrimeInfo.js");



//**************************************************************************************
/**
 * Class from RFC3447
 */
class RSAPrivateKey
{
	//**********************************************************************************
	/**
	 * Constructor for RSAPrivateKey class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", RSAPrivateKey.defaultValues("version"));
		/**
		 * @type {Integer}
		 * @desc modulus
		 */
		this.modulus = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "modulus", RSAPrivateKey.defaultValues("modulus"));
		/**
		 * @type {Integer}
		 * @desc publicExponent
		 */
		this.publicExponent = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "publicExponent", RSAPrivateKey.defaultValues("publicExponent"));
		/**
		 * @type {Integer}
		 * @desc privateExponent
		 */
		this.privateExponent = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "privateExponent", RSAPrivateKey.defaultValues("privateExponent"));
		/**
		 * @type {Integer}
		 * @desc prime1
		 */
		this.prime1 = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "prime1", RSAPrivateKey.defaultValues("prime1"));
		/**
		 * @type {Integer}
		 * @desc prime2
		 */
		this.prime2 = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "prime2", RSAPrivateKey.defaultValues("prime2"));
		/**
		 * @type {Integer}
		 * @desc exponent1
		 */
		this.exponent1 = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "exponent1", RSAPrivateKey.defaultValues("exponent1"));
		/**
		 * @type {Integer}
		 * @desc exponent2
		 */
		this.exponent2 = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "exponent2", RSAPrivateKey.defaultValues("exponent2"));
		/**
		 * @type {Integer}
		 * @desc coefficient
		 */
		this.coefficient = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "coefficient", RSAPrivateKey.defaultValues("coefficient"));

		if("otherPrimeInfos" in parameters)
			/**
			 * @type {Array.<OtherPrimeInfo>}
			 * @desc otherPrimeInfos
			 */
			this.otherPrimeInfos = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "otherPrimeInfos", RSAPrivateKey.defaultValues("otherPrimeInfos"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
		//region If input argument array contains "json" for this object
		if("json" in parameters)
			this.fromJSON(parameters.json);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "modulus":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "publicExponent":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "privateExponent":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "prime1":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "prime2":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "exponent1":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "exponent2":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "coefficient":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "otherPrimeInfos":
				return [];
			default:
				throw new Error(`Invalid member name for RSAPrivateKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RSAPrivateKey ::= Sequence {
	 *    version           Version,
	 *    modulus           Integer,  -- n
	 *    publicExponent    Integer,  -- e
	 *    privateExponent   Integer,  -- d
	 *    prime1            Integer,  -- p
	 *    prime2            Integer,  -- q
	 *    exponent1         Integer,  -- d mod (p-1)
	 *    exponent2         Integer,  -- d mod (q-1)
	 *    coefficient       Integer,  -- (inverse of q) mod p
	 *    otherPrimeInfos   OtherPrimeInfos OPTIONAL
	 * }
	 *
	 * OtherPrimeInfos ::= Sequence SIZE(1..MAX) OF OtherPrimeInfo
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [modulus]
		 * @property {string} [publicExponent]
		 * @property {string} [privateExponent]
		 * @property {string} [prime1]
		 * @property {string} [prime2]
		 * @property {string} [exponent1]
		 * @property {string} [exponent2]
		 * @property {string} [coefficient]
		 * @property {string} [otherPrimeInfosName]
		 * @property {Object} [otherPrimeInfo]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.modulus || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.publicExponent || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.privateExponent || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.prime1 || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.prime2 || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.exponent1 || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.exponent2 || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.coefficient || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					optional: true,
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.otherPrimeInfosName || ""),
							value: _OtherPrimeInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.otherPrimeInfo || {})
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"version",
			"modulus",
			"publicExponent",
			"privateExponent",
			"prime1",
			"prime2",
			"exponent1",
			"exponent2",
			"coefficient",
			"otherPrimeInfos"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RSAPrivateKey.schema({
				names: {
					version: "version",
					modulus: "modulus",
					publicExponent: "publicExponent",
					privateExponent: "privateExponent",
					prime1: "prime1",
					prime2: "prime2",
					exponent1: "exponent1",
					exponent2: "exponent2",
					coefficient: "coefficient",
					otherPrimeInfo: {
						names: {
							blockName: "otherPrimeInfos"
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RSAPrivateKey");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result.version.valueBlock.valueDec;
		this.modulus = asn1.result.modulus.convertFromDER(256);
		this.publicExponent = asn1.result.publicExponent;
		this.privateExponent = asn1.result.privateExponent.convertFromDER(256);
		this.prime1 = asn1.result.prime1.convertFromDER(128);
		this.prime2 = asn1.result.prime2.convertFromDER(128);
		this.exponent1 = asn1.result.exponent1.convertFromDER(128);
		this.exponent2 = asn1.result.exponent2.convertFromDER(128);
		this.coefficient = asn1.result.coefficient.convertFromDER(128);

		if("otherPrimeInfos" in asn1.result)
			this.otherPrimeInfos = Array.from(asn1.result.otherPrimeInfos, element => new _OtherPrimeInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
		outputArray.push(this.modulus.convertToDER());
		outputArray.push(this.publicExponent);
		outputArray.push(this.privateExponent.convertToDER());
		outputArray.push(this.prime1.convertToDER());
		outputArray.push(this.prime2.convertToDER());
		outputArray.push(this.exponent1.convertToDER());
		outputArray.push(this.exponent2.convertToDER());
		outputArray.push(this.coefficient.convertToDER());
		
		if("otherPrimeInfos" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: Array.from(this.otherPrimeInfos, element => element.toSchema())
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const jwk = {
			n: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.modulus.valueBlock.valueHex), true, true, true),
			e: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.publicExponent.valueBlock.valueHex), true, true, true),
			d: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.privateExponent.valueBlock.valueHex), true, true, true),
			p: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.prime1.valueBlock.valueHex), true, true, true),
			q: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.prime2.valueBlock.valueHex), true, true, true),
			dp: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.exponent1.valueBlock.valueHex), true, true, true),
			dq: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.exponent2.valueBlock.valueHex), true, true, true),
			qi: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.coefficient.valueBlock.valueHex), true, true, true)
		};

		if("otherPrimeInfos" in this)
			jwk.oth = Array.from(this.otherPrimeInfos, element => element.toJSON());

		return jwk;
	}
	//**********************************************************************************
	/**
	 * Convert JSON value into current object
	 * @param {Object} json
	 */
	fromJSON(json)
	{
		if("n" in json)
			this.modulus = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.n, true, true)) });
		else
			throw new Error("Absent mandatory parameter \"n\"");

		if("e" in json)
			this.publicExponent = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.e, true, true)) });
		else
			throw new Error("Absent mandatory parameter \"e\"");

		if("d" in json)
			this.privateExponent = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.d, true, true)) });
		else
			throw new Error("Absent mandatory parameter \"d\"");

		if("p" in json)
			this.prime1 = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.p, true, true)) });
		else
			throw new Error("Absent mandatory parameter \"p\"");

		if("q" in json)
			this.prime2 = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.q, true, true)) });
		else
			throw new Error("Absent mandatory parameter \"q\"");

		if("dp" in json)
			this.exponent1 = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.dp, true, true)) });
		else
			throw new Error("Absent mandatory parameter \"dp\"");

		if("dq" in json)
			this.exponent2 = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.dq, true, true)) });
		else
			throw new Error("Absent mandatory parameter \"dq\"");

		if("qi" in json)
			this.coefficient = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.qi, true, true)) });
		else
			throw new Error("Absent mandatory parameter \"qi\"");

		if("oth" in json)
			this.otherPrimeInfos = Array.from(json.oth, element => new _OtherPrimeInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ json: element }));
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RSAPublicKey.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/RSAPublicKey.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RSAPublicKey; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC3447
 */
class RSAPublicKey
{
	//**********************************************************************************
	/**
	 * Constructor for RSAPublicKey class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 * @property {Integer} [modulus]
	 * @property {Integer} [publicExponent]
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Integer}
		 * @desc Modulus part of RSA public key
		 */
		this.modulus = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "modulus", RSAPublicKey.defaultValues("modulus"));
		/**
		 * @type {Integer}
		 * @desc Public exponent of RSA public key
		 */
		this.publicExponent = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "publicExponent", RSAPublicKey.defaultValues("publicExponent"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
		//region If input argument array contains "json" for this object
		if("json" in parameters)
			this.fromJSON(parameters.json);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "modulus":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "publicExponent":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			default:
				throw new Error(`Invalid member name for RSAPublicKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RSAPublicKey ::= Sequence {
	 *    modulus           Integer,  -- n
	 *    publicExponent    Integer   -- e
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} utcTimeName Name for "utcTimeName" choice
		 * @property {string} generalTimeName Name for "generalTimeName" choice
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.modulus || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.publicExponent || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"modulus",
			"publicExponent"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RSAPublicKey.schema({
				names: {
					modulus: "modulus",
					publicExponent: "publicExponent"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RSAPublicKey");
		//endregion

		//region Get internal properties from parsed schema
		this.modulus = asn1.result.modulus.convertFromDER(256);
		this.publicExponent = asn1.result.publicExponent;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.modulus.convertToDER(),
				this.publicExponent
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			n: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.modulus.valueBlock.valueHex), true, true, true),
			e: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.publicExponent.valueBlock.valueHex), true, true, true)
		};
	}
	//**********************************************************************************
	/**
	 * Convert JSON value into current object
	 * @param {Object} json
	 */
	fromJSON(json)
	{
		if("n" in json)
		{
			const array = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.n, true));
			this.modulus = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: array.slice(0, Math.pow(2, Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["nearestPowerOf2"])(array.byteLength))) });
		}
		else
			throw new Error("Absent mandatory parameter \"n\"");

		if("e" in json)
			this.publicExponent = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(json.e, true)).slice(0, 3) });
		else
			throw new Error("Absent mandatory parameter \"e\"");
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RSASSAPSSParams.js":
/*!***************************************************!*\
  !*** ./node_modules/pkijs/src/RSASSAPSSParams.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RSASSAPSSParams; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC4055
 */
class RSASSAPSSParams
{
	//**********************************************************************************
	/**
	 * Constructor for RSASSAPSSParams class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc Algorithms of hashing (DEFAULT sha1)
		 */
		this.hashAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "hashAlgorithm", RSASSAPSSParams.defaultValues("hashAlgorithm"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc Algorithm of "mask generaion function (MGF)" (DEFAULT mgf1SHA1)
		 */
		this.maskGenAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "maskGenAlgorithm", RSASSAPSSParams.defaultValues("maskGenAlgorithm"));
		/**
		 * @type {number}
		 * @desc Salt length (DEFAULT 20)
		 */
		this.saltLength = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "saltLength", RSASSAPSSParams.defaultValues("saltLength"));
		/**
		 * @type {number}
		 * @desc (DEFAULT 1)
		 */
		this.trailerField = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "trailerField", RSASSAPSSParams.defaultValues("trailerField"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "hashAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
					algorithmId: "1.3.14.3.2.26", // SHA-1
					algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
				});
			case "maskGenAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
					algorithmId: "1.2.840.113549.1.1.8", // MGF1
					algorithmParams: (new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
						algorithmId: "1.3.14.3.2.26", // SHA-1
						algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
					})).toSchema()
				});
			case "saltLength":
				return 20;
			case "trailerField":
				return 1;
			default:
				throw new Error(`Invalid member name for RSASSAPSSParams class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RSASSA-PSS-params  ::=  Sequence  {
	 *    hashAlgorithm      [0] HashAlgorithm DEFAULT sha1Identifier,
	 *    maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT mgf1SHA1Identifier,
	 *    saltLength         [2] Integer DEFAULT 20,
	 *    trailerField       [3] Integer DEFAULT 1  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [hashAlgorithm]
		 * @property {string} [maskGenAlgorithm]
		 * @property {string} [saltLength]
		 * @property {string} [trailerField]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					optional: true,
					value: [_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.hashAlgorithm || {})]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					optional: true,
					value: [_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.maskGenAlgorithm || {})]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					optional: true,
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.saltLength || "") })]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 3 // [3]
					},
					optional: true,
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.trailerField || "") })]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"hashAlgorithm",
			"maskGenAlgorithm",
			"saltLength",
			"trailerField"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RSASSAPSSParams.schema({
				names: {
					hashAlgorithm: {
						names: {
							blockName: "hashAlgorithm"
						}
					},
					maskGenAlgorithm: {
						names: {
							blockName: "maskGenAlgorithm"
						}
					},
					saltLength: "saltLength",
					trailerField: "trailerField"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RSASSAPSSParams");
		//endregion

		//region Get internal properties from parsed schema
		if("hashAlgorithm" in asn1.result)
			this.hashAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.hashAlgorithm });

		if("maskGenAlgorithm" in asn1.result)
			this.maskGenAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.maskGenAlgorithm });

		if("saltLength" in asn1.result)
			this.saltLength = asn1.result.saltLength.valueBlock.valueDec;

		if("trailerField" in asn1.result)
			this.trailerField = asn1.result.trailerField.valueBlock.valueDec;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];
		
		if(!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues("hashAlgorithm")))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [this.hashAlgorithm.toSchema()]
			}));
		}
		
		if(!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues("maskGenAlgorithm")))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: [this.maskGenAlgorithm.toSchema()]
			}));
		}
		
		if(this.saltLength !== RSASSAPSSParams.defaultValues("saltLength"))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 2 // [2]
				},
				value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.saltLength })]
			}));
		}
		
		if(this.trailerField !== RSASSAPSSParams.defaultValues("trailerField"))
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 3 // [3]
				},
				value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.trailerField })]
			}));
		}
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {};

		if(!this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues("hashAlgorithm")))
			object.hashAlgorithm = this.hashAlgorithm.toJSON();

		if(!this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues("maskGenAlgorithm")))
			object.maskGenAlgorithm = this.maskGenAlgorithm.toJSON();

		if(this.saltLength !== RSASSAPSSParams.defaultValues("saltLength"))
			object.saltLength = this.saltLength;

		if(this.trailerField !== RSASSAPSSParams.defaultValues("trailerField"))
			object.trailerField = this.trailerField;

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RecipientEncryptedKey.js":
/*!*********************************************************!*\
  !*** ./node_modules/pkijs/src/RecipientEncryptedKey.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RecipientEncryptedKey; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _KeyAgreeRecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KeyAgreeRecipientIdentifier.js */ "./node_modules/pkijs/src/KeyAgreeRecipientIdentifier.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class RecipientEncryptedKey
{
	//**********************************************************************************
	/**
	 * Constructor for RecipientEncryptedKey class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {KeyAgreeRecipientIdentifier}
		 * @desc rid
		 */
		this.rid = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "rid", RecipientEncryptedKey.defaultValues("rid"));
		/**
		 * @type {OctetString}
		 * @desc encryptedKey
		 */
		this.encryptedKey = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptedKey", RecipientEncryptedKey.defaultValues("encryptedKey"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "rid":
				return new _KeyAgreeRecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "encryptedKey":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			default:
				throw new Error(`Invalid member name for RecipientEncryptedKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "rid":
				return ((memberValue.variant === (-1)) && (("value" in memberValue) === false));
			case "encryptedKey":
				return (memberValue.isEqual(RecipientEncryptedKey.defaultValues("encryptedKey")));
			default:
				throw new Error(`Invalid member name for RecipientEncryptedKey class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RecipientEncryptedKey ::= SEQUENCE {
	 *    rid KeyAgreeRecipientIdentifier,
	 *    encryptedKey EncryptedKey }
	 *
	 * EncryptedKey ::= OCTET STRING
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [rid]
		 * @property {string} [encryptedKey]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_KeyAgreeRecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.rid || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.encryptedKey || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"rid",
			"encryptedKey"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RecipientEncryptedKey.schema({
				names: {
					rid: {
						names: {
							blockName: "rid"
						}
					},
					encryptedKey: "encryptedKey"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RecipientEncryptedKey");
		//endregion

		//region Get internal properties from parsed schema
		this.rid = new _KeyAgreeRecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.rid });
		this.encryptedKey = asn1.result.encryptedKey;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				this.rid.toSchema(),
				this.encryptedKey
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			rid: this.rid.toJSON(),
			encryptedKey: this.encryptedKey.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RecipientEncryptedKeys.js":
/*!**********************************************************!*\
  !*** ./node_modules/pkijs/src/RecipientEncryptedKeys.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RecipientEncryptedKeys; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _RecipientEncryptedKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RecipientEncryptedKey.js */ "./node_modules/pkijs/src/RecipientEncryptedKey.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class RecipientEncryptedKeys
{
	//**********************************************************************************
	/**
	 * Constructor for RecipientEncryptedKeys class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<RecipientEncryptedKey>}
		 * @desc encryptedKeys
		 */
		this.encryptedKeys = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encryptedKeys", RecipientEncryptedKeys.defaultValues("encryptedKeys"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "encryptedKeys":
				return [];
			default:
				throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "encryptedKeys":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RecipientEncryptedKeys ::= SEQUENCE OF RecipientEncryptedKey
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [RecipientEncryptedKeys]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.RecipientEncryptedKeys || ""),
					value: _RecipientEncryptedKey_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"RecipientEncryptedKeys"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RecipientEncryptedKeys.schema({
				names: {
					RecipientEncryptedKeys: "RecipientEncryptedKeys"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RecipientEncryptedKeys");
		//endregion

		//region Get internal properties from parsed schema
		this.encryptedKeys = Array.from(asn1.result.RecipientEncryptedKeys, element => new _RecipientEncryptedKey_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.encryptedKeys, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			encryptedKeys: Array.from(this.encryptedKeys, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RecipientIdentifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/pkijs/src/RecipientIdentifier.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RecipientIdentifier; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IssuerAndSerialNumber.js */ "./node_modules/pkijs/src/IssuerAndSerialNumber.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class RecipientIdentifier
{
	//**********************************************************************************
	/**
	 * Constructor for RecipientIdentifier class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc variant
		 */
		this.variant = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "variant", RecipientIdentifier.defaultValues("variant"));

		if("value" in parameters)
			/**
			 * @type {*}
			 * @desc value
			 */
			this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "value", RecipientIdentifier.defaultValues("value"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "variant":
				return (-1);
			case "value":
				return {};
			default:
				throw new Error(`Invalid member name for RecipientIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "variant":
				return (memberValue === (-1));
			case "values":
				return (Object.keys(memberValue).length === 0);
			default:
				throw new Error(`Invalid member name for RecipientIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RecipientIdentifier ::= CHOICE {
	 *    issuerAndSerialNumber IssuerAndSerialNumber,
	 *    subjectKeyIdentifier [0] SubjectKeyIdentifier }
	 *
	 * SubjectKeyIdentifier ::= OCTET STRING
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
			value: [
				_IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema({
					names: {
						blockName: (names.blockName || "")
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					}
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"blockName"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RecipientIdentifier.schema({
				names: {
					blockName: "blockName"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RecipientIdentifier");
		//endregion

		//region Get internal properties from parsed schema
		if(asn1.result.blockName.idBlock.tagClass === 1)
		{
			this.variant = 1;
			this.value = new _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.blockName });
		}
		else
		{
			this.variant = 2;
			this.value = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: asn1.result.blockName.valueBlock.valueHex }) ;
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		switch(this.variant)
		{
			case 1:
				return this.value.toSchema();
			case 2:
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					valueHex: this.value.valueBlock.valueHex
				});
			default:
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			variant: this.variant
		};

		if((this.variant === 1) || (this.variant === 2))
			_object.value = this.value.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RecipientInfo.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/RecipientInfo.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RecipientInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _KeyTransRecipientInfo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KeyTransRecipientInfo.js */ "./node_modules/pkijs/src/KeyTransRecipientInfo.js");
/* harmony import */ var _KeyAgreeRecipientInfo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KeyAgreeRecipientInfo.js */ "./node_modules/pkijs/src/KeyAgreeRecipientInfo.js");
/* harmony import */ var _KEKRecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./KEKRecipientInfo.js */ "./node_modules/pkijs/src/KEKRecipientInfo.js");
/* harmony import */ var _PasswordRecipientinfo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PasswordRecipientinfo.js */ "./node_modules/pkijs/src/PasswordRecipientinfo.js");
/* harmony import */ var _OtherRecipientInfo_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./OtherRecipientInfo.js */ "./node_modules/pkijs/src/OtherRecipientInfo.js");







//**************************************************************************************
/**
 * Class from RFC5652
 */
class RecipientInfo
{
	//**********************************************************************************
	/**
	 * Constructor for RecipientInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc variant
		 */
		this.variant = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "variant", RecipientInfo.defaultValues("variant"));

		if("value" in parameters)
			/**
			 * @type {*}
			 * @desc value
			 */
			this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "value", RecipientInfo.defaultValues("value"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "variant":
				return (-1);
			case "value":
				return {};
			default:
				throw new Error(`Invalid member name for RecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "variant":
				return (memberValue === RecipientInfo.defaultValues(memberName));
			case "value":
				return (Object.keys(memberValue).length === 0);
			default:
				throw new Error(`Invalid member name for RecipientInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RecipientInfo ::= CHOICE {
	 *    ktri KeyTransRecipientInfo,
	 *    kari [1] KeyAgreeRecipientInfo,
	 *    kekri [2] KEKRecipientInfo,
	 *    pwri [3] PasswordRecipientinfo,
	 *    ori [4] OtherRecipientInfo }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [type]
		 * @property {string} [setName]
		 * @property {string} [values]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
			value: [
				_KeyTransRecipientInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema({
					names: {
						blockName: (names.blockName || "")
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: _KeyAgreeRecipientInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema().valueBlock.value
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					value: _KEKRecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema().valueBlock.value
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 3 // [3]
					},
					value: _PasswordRecipientinfo_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema().valueBlock.value
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.blockName || ""),
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 4 // [4]
					},
					value: _OtherRecipientInfo_js__WEBPACK_IMPORTED_MODULE_6__["default"].schema().valueBlock.value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"blockName"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RecipientInfo.schema({
				names: {
					blockName: "blockName"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RecipientInfo");
		//endregion

		//region Get internal properties from parsed schema
		if(asn1.result.blockName.idBlock.tagClass === 1)
		{
			this.variant = 1;
			this.value = new _KeyTransRecipientInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.blockName });
		}
		else
		{
			//region Create "SEQUENCE" from "ASN1_CONSTRUCTED"
			const blockSequence = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: asn1.result.blockName.valueBlock.value
			});
			//endregion

			switch(asn1.result.blockName.idBlock.tagNumber)
			{
				case 1:
					this.variant = 2;
					this.value = new _KeyAgreeRecipientInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: blockSequence });
					break;
				case 2:
					this.variant = 3;
					this.value = new _KEKRecipientInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: blockSequence });
					break;
				case 3:
					this.variant = 4;
					this.value = new _PasswordRecipientinfo_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: blockSequence });
					break;
				case 4:
					this.variant = 5;
					this.value = new _OtherRecipientInfo_js__WEBPACK_IMPORTED_MODULE_6__["default"]({ schema: blockSequence });
					break;
				default:
					throw new Error("Incorrect structure of RecipientInfo block");
			}
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		const _schema = this.value.toSchema();

		switch(this.variant)
		{
			case 1:
				return _schema;
			case 2:
			case 3:
			case 4:
				//region Create "ASN1_CONSTRUCTED" from "SEQUENCE"
				_schema.idBlock.tagClass = 3; // CONTEXT-SPECIFIC
				_schema.idBlock.tagNumber = (this.variant - 1);
				//endregion

				return _schema;
			default:
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			variant: this.variant
		};

		if((this.variant >= 1) && (this.variant <= 4))
			_object.value = this.value.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RecipientKeyIdentifier.js":
/*!**********************************************************!*\
  !*** ./node_modules/pkijs/src/RecipientKeyIdentifier.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RecipientKeyIdentifier; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OtherKeyAttribute.js */ "./node_modules/pkijs/src/OtherKeyAttribute.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class RecipientKeyIdentifier
{
	//**********************************************************************************
	/**
	 * Constructor for RecipientKeyIdentifier class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {OctetString}
		 * @desc subjectKeyIdentifier
		 */
		this.subjectKeyIdentifier = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "subjectKeyIdentifier", RecipientKeyIdentifier.defaultValues("subjectKeyIdentifier"));

		if("date" in parameters)
			/**
			 * @type {GeneralizedTime}
			 * @desc date
			 */
			this.date = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "date", RecipientKeyIdentifier.defaultValues("date"));

		if("other" in parameters)
			/**
			 * @type {OtherKeyAttribute}
			 * @desc other
			 */
			this.other = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "other", RecipientKeyIdentifier.defaultValues("other"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "subjectKeyIdentifier":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "date":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]();
			case "other":
				return new _OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			default:
				throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "subjectKeyIdentifier":
				return (memberValue.isEqual(RecipientKeyIdentifier.defaultValues("subjectKeyIdentifier")));
			case "date":
				// noinspection OverlyComplexBooleanExpressionJS
				return ((memberValue.year === 0) &&
				(memberValue.month === 0) &&
				(memberValue.day === 0) &&
				(memberValue.hour === 0) &&
				(memberValue.minute === 0) &&
				(memberValue.second === 0) &&
				(memberValue.millisecond === 0));
			case "other":
				return ((memberValue.keyAttrId === "") && (("keyAttr" in memberValue) === false));
			default:
				throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RecipientKeyIdentifier ::= SEQUENCE {
	 *    subjectKeyIdentifier SubjectKeyIdentifier,
	 *    date GeneralizedTime OPTIONAL,
	 *    other OtherKeyAttribute OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [type]
		 * @property {string} [setName]
		 * @property {string} [values]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.subjectKeyIdentifier || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({
					optional: true,
					name: (names.date || "")
				}),
				_OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.other || {})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"subjectKeyIdentifier",
			"date",
			"other"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RecipientKeyIdentifier.schema({
				names: {
					subjectKeyIdentifier: "subjectKeyIdentifier",
					date: "date",
					other: {
						names: {
							blockName: "other"
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RecipientKeyIdentifier");
		//endregion

		//region Get internal properties from parsed schema
		this.subjectKeyIdentifier = asn1.result.subjectKeyIdentifier;

		if("date" in asn1.result)
			this.date = asn1.result.date;

		if("other" in asn1.result)
			this.other = new _OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.other });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(this.subjectKeyIdentifier);

		if("date" in this)
			outputArray.push(this.date);

		if("other" in this)
			outputArray.push(this.other.toSchema());
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			subjectKeyIdentifier: this.subjectKeyIdentifier.toJSON()
		};

		if("date" in this)
			_object.date = this.date;

		if("other" in this)
			_object.other = this.other.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RelativeDistinguishedNames.js":
/*!**************************************************************!*\
  !*** ./node_modules/pkijs/src/RelativeDistinguishedNames.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RelativeDistinguishedNames; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AttributeTypeAndValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AttributeTypeAndValue.js */ "./node_modules/pkijs/src/AttributeTypeAndValue.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class RelativeDistinguishedNames
{
	//**********************************************************************************
	/**
	 * Constructor for RelativeDistinguishedNames class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 * @property {Array.<AttributeTypeAndValue>} [typesAndValues] Array of "type and value" objects
	 * @property {ArrayBuffer} [valueBeforeDecode] Value of the RDN before decoding from schema
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<AttributeTypeAndValue>}
		 * @desc Array of "type and value" objects
		 */
		this.typesAndValues = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "typesAndValues", RelativeDistinguishedNames.defaultValues("typesAndValues"));
		/**
		 * @type {ArrayBuffer}
		 * @desc Value of the RDN before decoding from schema
		 */
		this.valueBeforeDecode = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "valueBeforeDecode", RelativeDistinguishedNames.defaultValues("valueBeforeDecode"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "typesAndValues":
				return [];
			case "valueBeforeDecode":
				return new ArrayBuffer(0);
			default:
				throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "typesAndValues":
				return (memberValue.length === 0);
			case "valueBeforeDecode":
				return (memberValue.byteLength === 0);
			default:
				throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RDNSequence ::= Sequence OF RelativeDistinguishedName
	 *
	 * RelativeDistinguishedName ::=
	 * SET SIZE (1..MAX) OF AttributeTypeAndValue
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName] Name for entire block
		 * @property {string} [repeatedSequence] Name for "repeatedSequence" block
		 * @property {string} [repeatedSet] Name for "repeatedSet" block
		 * @property {string} [typeAndValue] Name for "typeAndValue" block
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.repeatedSequence || ""),
					value: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
						value: [
							new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
								name: (names.repeatedSet || ""),
								value: _AttributeTypeAndValue_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.typeAndValue || {})
							})
						]
					})
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"RDN",
			"typesAndValues"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RelativeDistinguishedNames.schema({
				names: {
					blockName: "RDN",
					repeatedSet: "typesAndValues"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RelativeDistinguishedNames");
		//endregion

		//region Get internal properties from parsed schema
		if("typesAndValues" in asn1.result) // Could be a case when there is no "types and values"
			this.typesAndValues = Array.from(asn1.result.typesAndValues, element => new _AttributeTypeAndValue_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));

		// noinspection JSUnresolvedVariable
		this.valueBeforeDecode = asn1.result.RDN.valueBeforeDecode;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Decode stored TBS value
		if(this.valueBeforeDecode.byteLength === 0) // No stored encoded array, create "from scratch"
		{
			return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					value: Array.from(this.typesAndValues, element => element.toSchema())
				})]
			}));
		}

		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.valueBeforeDecode);
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return asn1.result;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			typesAndValues: Array.from(this.typesAndValues, element => element.toJSON())
		};
	}
	//**********************************************************************************
	/**
	 * Compare two RDN values, or RDN with ArrayBuffer value
	 * @param {(RelativeDistinguishedNames|ArrayBuffer)} compareTo The value compare to current
	 * @returns {boolean}
	 */
	isEqual(compareTo)
	{
		if(compareTo instanceof RelativeDistinguishedNames)
		{
			if(this.typesAndValues.length !== compareTo.typesAndValues.length)
				return false;

			for(const [index, typeAndValue] of this.typesAndValues.entries())
			{
				if(typeAndValue.isEqual(compareTo.typesAndValues[index]) === false)
					return false;
			}

			return true;
		}

		if(compareTo instanceof ArrayBuffer)
			return Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(this.valueBeforeDecode, compareTo);

		return false;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/Request.js":
/*!*******************************************!*\
  !*** ./node_modules/pkijs/src/Request.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Request; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _CertID_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CertID.js */ "./node_modules/pkijs/src/CertID.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/pkijs/src/Extension.js");




//**************************************************************************************
/**
 * Class from RFC6960
 */
class Request
{
	//**********************************************************************************
	/**
	 * Constructor for Request class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {CertID}
		 * @desc reqCert
		 */
		this.reqCert = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "reqCert", Request.defaultValues("reqCert"));

		if("singleRequestExtensions" in parameters)
			/**
			 * @type {Array.<Extension>}
			 * @desc singleRequestExtensions
			 */
			this.singleRequestExtensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "singleRequestExtensions", Request.defaultValues("singleRequestExtensions"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "reqCert":
				return new _CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "singleRequestExtensions":
				return [];
			default:
				throw new Error(`Invalid member name for Request class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "reqCert":
				return (memberValue.isEqual(Request.defaultValues(memberName)));
			case "singleRequestExtensions":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for Request class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * Request         ::=     SEQUENCE {
	 *    reqCert                     CertID,
	 *    singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [reqCert]
		 * @property {string} [extensions]
		 * @property {string} [singleRequestExtensions]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.reqCert || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [_Extension_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.extensions || {
						names: {
							blockName: (names.singleRequestExtensions || "")
						}
					})]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"reqCert",
			"singleRequestExtensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			Request.schema({
				names: {
					reqCert: {
						names: {
							blockName: "reqCert"
						}
					},
					singleRequestExtensions: {
						names: {
							blockName: "singleRequestExtensions"
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for Request");
		//endregion

		//region Get internal properties from parsed schema
		this.reqCert = new _CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.reqCert });

		if("singleRequestExtensions" in asn1.result)
			this.singleRequestExtensions = Array.from(asn1.result.singleRequestExtensions.valueBlock.value, element => new _Extension_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(this.reqCert.toSchema());

		if("singleRequestExtensions" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
						value: Array.from(this.singleRequestExtensions, element => element.toSchema())
					})
				]
			}));
		}
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			reqCert: this.reqCert.toJSON()
		};

		if("singleRequestExtensions" in this)
			_object.singleRequestExtensions = Array.from(this.singleRequestExtensions, element => element.toJSON());

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/ResponseBytes.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/ResponseBytes.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ResponseBytes; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC6960
 */
class ResponseBytes
{
	//**********************************************************************************
	/**
	 * Constructor for ResponseBytes class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc responseType
		 */
		this.responseType = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "responseType", ResponseBytes.defaultValues("responseType"));
		/**
		 * @type {OctetString}
		 * @desc response
		 */
		this.response = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "response", ResponseBytes.defaultValues("response"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "responseType":
				return "";
			case "response":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			default:
				throw new Error(`Invalid member name for ResponseBytes class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "responseType":
				return (memberValue === "");
			case "response":
				return (memberValue.isEqual(ResponseBytes.defaultValues(memberName)));
			default:
				throw new Error(`Invalid member name for ResponseBytes class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * ResponseBytes ::=       SEQUENCE {
	 *    responseType   OBJECT IDENTIFIER,
	 *    response       OCTET STRING }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [responseType]
		 * @property {string} [response]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.responseType || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.response || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"responseType",
			"response"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			ResponseBytes.schema({
				names: {
					responseType: "responseType",
					response: "response"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for ResponseBytes");
		//endregion

		//region Get internal properties from parsed schema
		this.responseType = asn1.result.responseType.valueBlock.toString();
		this.response = asn1.result.response;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.responseType }),
				this.response
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			responseType: this.responseType,
			response: this.response.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/ResponseData.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/ResponseData.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ResponseData; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");
/* harmony import */ var _SingleResponse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SingleResponse.js */ "./node_modules/pkijs/src/SingleResponse.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/pkijs/src/Extension.js");
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Extensions.js */ "./node_modules/pkijs/src/Extensions.js");






//**************************************************************************************
/**
 * Class from RFC6960
 */
class ResponseData
{
	//**********************************************************************************
	/**
	 * Constructor for ResponseData class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {ArrayBuffer}
		 * @desc tbs
		 */
		this.tbs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "tbs", ResponseData.defaultValues("tbs"));
		/**
		 * @type {Object}
		 * @desc responderID
		 */
		this.responderID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "responderID", ResponseData.defaultValues("responderID"));
		/**
		 * @type {Date}
		 * @desc producedAt
		 */
		this.producedAt = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "producedAt", ResponseData.defaultValues("producedAt"));
		/**
		 * @type {Array.<SingleResponse>}
		 * @desc responses
		 */
		this.responses = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "responses", ResponseData.defaultValues("responses"));

		if("responseExtensions" in parameters)
			/**
			 * @type {Array.<Extension>}
			 * @desc responseExtensions
			 */
			this.responseExtensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "responseExtensions", ResponseData.defaultValues("responseExtensions"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "tbs":
				return new ArrayBuffer(0);
			case "responderID":
				return {};
			case "producedAt":
				return new Date(0, 0, 0);
			case "responses":
			case "responseExtensions":
				return [];
			default:
				throw new Error(`Invalid member name for ResponseData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "tbs":
				return (memberValue.byteLength === 0);
			case "responderID":
				return (Object.keys(memberValue).length === 0);
			case "producedAt":
				return (memberValue === ResponseData.defaultValues(memberName));
			case "responses":
			case "responseExtensions":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for ResponseData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * ResponseData ::= SEQUENCE {
	 *    version              [0] EXPLICIT Version DEFAULT v1,
	 *    responderID              ResponderID,
	 *    producedAt               GeneralizedTime,
	 *    responses                SEQUENCE OF SingleResponse,
	 *    responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [ResponseDataByName]
		 * @property {string} [ResponseDataByKey]
		 * @property {string} [producedAt]
		 * @property {string} [response]
		 * @property {string} [extensions]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "ResponseData"),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "ResponseData.version") })]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							name: (names.responderID || "ResponseData.responderID"),
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 1 // [1]
							},
							value: [_RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.ResponseDataByName || {
								names: {
									blockName: "ResponseData.byName"
								}
							})]
						}),
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							name: (names.responderID || "ResponseData.responderID"),
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 2 // [2]
							},
							value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.ResponseDataByKey || "ResponseData.byKey") })]
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ name: (names.producedAt || "ResponseData.producedAt") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: "ResponseData.responses",
							value: _SingleResponse_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.response || {})
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [_Extensions_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.extensions || {
						names: {
							blockName: "ResponseData.responseExtensions"
						}
					})]
				}) // EXPLICIT SEQUENCE value
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"ResponseData",
			"ResponseData.version",
			"ResponseData.responderID",
			"ResponseData.producedAt",
			"ResponseData.responses",
			"ResponseData.responseExtensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			ResponseData.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for ResponseData");
		//endregion

		//region Get internal properties from parsed schema
		this.tbs = asn1.result.ResponseData.valueBeforeDecode;

		if("ResponseData.version" in asn1.result)
			this.version = asn1.result["ResponseData.version"].valueBlock.valueDec;

		if(asn1.result["ResponseData.responderID"].idBlock.tagNumber === 1)
			this.responderID = new _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result["ResponseData.responderID"].valueBlock.value[0] });
		else
			this.responderID = asn1.result["ResponseData.responderID"].valueBlock.value[0]; // OCTETSTRING

		this.producedAt = asn1.result["ResponseData.producedAt"].toDate();
		this.responses = Array.from(asn1.result["ResponseData.responses"], element => new _SingleResponse_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: element }));

		if("ResponseData.responseExtensions" in asn1.result)
			this.responseExtensions = Array.from(asn1.result["ResponseData.responseExtensions"].valueBlock.value, element => new _Extension_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @param {boolean} encodeFlag If param equal to false then create TBS schema via decoding stored value. In othe case create TBS schema via assembling from TBS parts.
	 * @returns {Object} asn1js object
	 */
	toSchema(encodeFlag = false)
	{
		//region Decode stored TBS value 
		let tbsSchema;
		
		if(encodeFlag === false)
		{
			if(this.tbs.length === 0) // No stored certificate TBS part
				return ResponseData.schema();
			
			tbsSchema = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.tbs).result;
		}
		//endregion 
		//region Create TBS schema via assembling from TBS parts
		else
		{
			const outputArray = [];
			
			if("version" in this)
			{
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version })]
				}));
			}
			
			if(this.responderID instanceof _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_2__["default"])
			{
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [this.responderID.toSchema()]
				}));
			}
			else
			{
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					value: [this.responderID]
				}));
			}
			
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueDate: this.producedAt }));

			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: Array.from(this.responses, element => element.toSchema())
			}));
			
			if("responseExtensions" in this)
			{
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
						value: Array.from(this.responseExtensions, element => element.toSchema())
					})]
				}));
			}
			
			tbsSchema = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: outputArray
			});
		}
		//endregion 
		
		//region Construct and return new ASN.1 schema for this object 
		return tbsSchema;
		//endregion 
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {};

		if("version" in this)
			_object.version = this.version;

		if("responderID" in this)
			_object.responderID = this.responderID;

		if("producedAt" in this)
			_object.producedAt = this.producedAt;

		if("responses" in this)
			_object.responses = Array.from(this.responses, element => element.toJSON());

		if("responseExtensions" in this)
			_object.responseExtensions = Array.from(this.responseExtensions, element => element.toJSON());

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RevocationInfoChoices.js":
/*!*********************************************************!*\
  !*** ./node_modules/pkijs/src/RevocationInfoChoices.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RevocationInfoChoices; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _CertificateRevocationList_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CertificateRevocationList.js */ "./node_modules/pkijs/src/CertificateRevocationList.js");
/* harmony import */ var _OtherRevocationInfoFormat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OtherRevocationInfoFormat.js */ "./node_modules/pkijs/src/OtherRevocationInfoFormat.js");




//**************************************************************************************
/**
 * Class from RFC5652
 */
class RevocationInfoChoices 
{
	//**********************************************************************************
	/**
	 * Constructor for RevocationInfoChoices class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<CertificateRevocationList>}
		 * @desc crls
		 */
		this.crls = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "crls", RevocationInfoChoices.defaultValues("crls"));
		/**
		 * @type {Array.<OtherRevocationInfoFormat>}
		 * @desc otherRevocationInfos
		 */
		this.otherRevocationInfos = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "otherRevocationInfos", RevocationInfoChoices.defaultValues("otherRevocationInfos"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "crls":
				return [];
			case "otherRevocationInfos":
				return [];
			default:
				throw new Error(`Invalid member name for RevocationInfoChoices class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * RevocationInfoChoices ::= SET OF RevocationInfoChoice
	 *
	 * RevocationInfoChoice ::= CHOICE {
	 *    crl CertificateList,
	 *    other [1] IMPLICIT OtherRevocationInfoFormat }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [crls]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.crls || ""),
					value: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
						value: [
							_CertificateRevocationList_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(),
							new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
								idBlock: {
									tagClass: 3, // CONTEXT-SPECIFIC
									tagNumber: 1 // [1]
								},
								value: [
									new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"](),
									new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]()
								]
							})
						]
					})
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"crls"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RevocationInfoChoices.schema({
				names: {
					crls: "crls"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RevocationInfoChoices");
		//endregion
		
		//region Get internal properties from parsed schema
		for(const element of asn1.result.crls)
		{
			if(element.idBlock.tagClass === 1)
				this.crls.push(new _CertificateRevocationList_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
			else
				this.otherRevocationInfos.push(new _OtherRevocationInfoFormat_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: element }));
		}
		
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output set
		const outputArray = [];
		
		outputArray.push(...Array.from(this.crls, element => element.toSchema()));
		
		outputArray.push(...Array.from(this.otherRevocationInfos, element =>
		{
			const schema = element.toSchema();
			
			schema.idBlock.tagClass = 3;
			schema.idBlock.tagNumber = 1;
			
			return schema;
		}));
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			crls: Array.from(this.crls, element => element.toJSON()),
			otherRevocationInfos: Array.from(this.otherRevocationInfos, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/RevokedCertificate.js":
/*!******************************************************!*\
  !*** ./node_modules/pkijs/src/RevokedCertificate.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RevokedCertificate; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _Time_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Time.js */ "./node_modules/pkijs/src/Time.js");
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Extensions.js */ "./node_modules/pkijs/src/Extensions.js");




//**************************************************************************************
/**
 * Class from RFC5280
 */
class RevokedCertificate
{
	//**********************************************************************************
	/**
	 * Constructor for RevokedCertificate class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Integer}
		 * @desc userCertificate
		 */
		this.userCertificate = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "userCertificate", RevokedCertificate.defaultValues("userCertificate"));
		/**
		 * @type {Time}
		 * @desc revocationDate
		 */
		this.revocationDate = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "revocationDate", RevokedCertificate.defaultValues("revocationDate"));

		if("crlEntryExtensions" in parameters)
			/**
			 * @type {Extensions}
			 * @desc crlEntryExtensions
			 */
			this.crlEntryExtensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "crlEntryExtensions", RevokedCertificate.defaultValues("crlEntryExtensions"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "userCertificate":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "revocationDate":
				return new _Time_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "crlEntryExtensions":
				return new _Extensions_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			default:
				throw new Error(`Invalid member name for RevokedCertificate class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * revokedCertificates     SEQUENCE OF SEQUENCE  {
     *        userCertificate         CertificateSerialNumber,
     *        revocationDate          Time,
     *        crlEntryExtensions      Extensions OPTIONAL
     *                                 -- if present, version MUST be v2
     *                             }  OPTIONAL,
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [userCertificate]
		 * @property {string} [revocationDate]
		 * @property {string} [crlEntryExtensions]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.userCertificate || "userCertificate") }),
				_Time_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema({
					names: {
						utcTimeName: (names.revocationDate || "revocationDate"),
						generalTimeName: (names.revocationDate || "revocationDate")
					}
				}),
				_Extensions_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema({
					names: {
						blockName: (names.crlEntryExtensions || "crlEntryExtensions")
					}
				}, true)
			]
		});
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"userCertificate",
			"revocationDate",
			"crlEntryExtensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			RevokedCertificate.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for RevokedCertificate");
		//endregion

		//region Get internal properties from parsed schema
		this.userCertificate = asn1.result.userCertificate;
		this.revocationDate = new _Time_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.revocationDate });

		if("crlEntryExtensions" in asn1.result)
			this.crlEntryExtensions = new _Extensions_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.crlEntryExtensions });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [
			this.userCertificate,
			this.revocationDate.toSchema()
		];

		if("crlEntryExtensions" in this)
			outputArray.push(this.crlEntryExtensions.toSchema());
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const object = {
			userCertificate: this.userCertificate.toJSON(),
			revocationDate: this.revocationDate.toJSON
		};

		if("crlEntryExtensions" in this)
			object.crlEntryExtensions = this.crlEntryExtensions.toJSON();

		return object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/SafeBag.js":
/*!*******************************************!*\
  !*** ./node_modules/pkijs/src/SafeBag.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SafeBag; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");
/* harmony import */ var _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PrivateKeyInfo.js */ "./node_modules/pkijs/src/PrivateKeyInfo.js");
/* harmony import */ var _PKCS8ShroudedKeyBag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PKCS8ShroudedKeyBag.js */ "./node_modules/pkijs/src/PKCS8ShroudedKeyBag.js");
/* harmony import */ var _CertBag_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CertBag.js */ "./node_modules/pkijs/src/CertBag.js");
/* harmony import */ var _CRLBag_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CRLBag.js */ "./node_modules/pkijs/src/CRLBag.js");
/* harmony import */ var _SecretBag_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SecretBag.js */ "./node_modules/pkijs/src/SecretBag.js");
/* harmony import */ var _SafeContents_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SafeContents.js */ "./node_modules/pkijs/src/SafeContents.js");









//**************************************************************************************
/**
 * Class from RFC7292
 */
class SafeBag
{
	//**********************************************************************************
	/**
	 * Constructor for SafeBag class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc bagId
		 */
		this.bagId = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "bagId", SafeBag.defaultValues("bagId"));
		/**
		 * @type {*}
		 * @desc bagValue
		 */
		this.bagValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "bagValue", SafeBag.defaultValues("bagValue"));
		
		if("bagAttributes" in parameters)
			/**
			 * @type {Array.<Attribute>}
			 * @desc bagAttributes
			 */
			this.bagAttributes = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "bagAttributes", SafeBag.defaultValues("bagAttributes"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "bagId":
				return "";
			case "bagValue":
				return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]());
			case "bagAttributes":
				return [];
			default:
				throw new Error(`Invalid member name for SafeBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "bagId":
				return (memberValue === "");
			case "bagValue":
				return (memberValue instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]);
			case "bagAttributes":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for SafeBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SafeBag ::= SEQUENCE {
	 *    bagId	      	BAG-TYPE.&id ({PKCS12BagSet}),
	 *    bagValue      [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),
	 *    bagAttributes SET OF PKCS12Attribute OPTIONAL
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [bagId]
		 * @property {string} [bagValue]
		 * @property {string} [bagAttributes]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.bagId || "bagId") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.bagValue || "bagValue") })] // EXPLICIT ANY value
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					optional: true,
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.bagAttributes || "bagAttributes"),
							value: _Attribute_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"bagId",
			"bagValue",
			"bagAttributes"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			SafeBag.schema({
				names: {
					bagId: "bagId",
					bagValue: "bagValue",
					bagAttributes: "bagAttributes"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for SafeBag");
		//endregion
		
		//region Get internal properties from parsed schema
		this.bagId = asn1.result.bagId.valueBlock.toString();
		
		switch(this.bagId)
		{
			case "1.2.840.113549.1.12.10.1.1": // keyBag
				this.bagValue = new _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result.bagValue });
				break;
			case "1.2.840.113549.1.12.10.1.2": // pkcs8ShroudedKeyBag
				this.bagValue = new _PKCS8ShroudedKeyBag_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result.bagValue });
				break;
			case "1.2.840.113549.1.12.10.1.3": // certBag
				this.bagValue = new _CertBag_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result.bagValue });
				break;
			case "1.2.840.113549.1.12.10.1.4": // crlBag
				this.bagValue = new _CRLBag_js__WEBPACK_IMPORTED_MODULE_6__["default"]({ schema: asn1.result.bagValue });
				break;
			case "1.2.840.113549.1.12.10.1.5": // secretBag
				this.bagValue = new _SecretBag_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: asn1.result.bagValue });
				break;
			case "1.2.840.113549.1.12.10.1.6": // safeContentsBag
				this.bagValue = new _SafeContents_js__WEBPACK_IMPORTED_MODULE_8__["default"]({ schema: asn1.result.bagValue });
				break;
			default:
				throw new Error(`Invalid "bagId" for SafeBag: ${this.bagId}`);
		}
		
		if("bagAttributes" in asn1.result)
			this.bagAttributes = Array.from(asn1.result.bagAttributes, element => new _Attribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		const outputArray = [
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.bagId }),
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [this.bagValue.toSchema()]
			})
		];
		
		if("bagAttributes" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
				value: Array.from(this.bagAttributes, element => element.toSchema())
			}));
		}
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const output = {
			bagId: this.bagId,
			bagValue: this.bagValue.toJSON()
		};
		
		if("bagAttributes" in this)
			output.bagAttributes = Array.from(this.bagAttributes, element => element.toJSON());
		
		return output;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/SafeContents.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/SafeContents.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SafeContents; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _SafeBag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SafeBag.js */ "./node_modules/pkijs/src/SafeBag.js");



//**************************************************************************************
/**
 * Class from RFC7292
 */
class SafeContents
{
	//**********************************************************************************
	/**
	 * Constructor for SafeContents class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<SafeBag>}
		 * @desc safeBags
		 */
		this.safeBags = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "safeBags", SafeContents.defaultValues("safeBags"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "safeBags":
				return [];
			default:
				throw new Error(`Invalid member name for SafeContents class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "safeBags":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for SafeContents class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SafeContents ::= SEQUENCE OF SafeBag
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [safeBags]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.safeBags || ""),
					value: _SafeBag_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"safeBags"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			SafeContents.schema({
				names: {
					safeBags: "safeBags"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for SafeContents");
		//endregion
		
		//region Get internal properties from parsed schema
		this.safeBags = Array.from(asn1.result.safeBags, element => new _SafeBag_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.safeBags, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			safeBags: Array.from(this.safeBags, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/SecretBag.js":
/*!*********************************************!*\
  !*** ./node_modules/pkijs/src/SecretBag.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SecretBag; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC7292
 */
class SecretBag
{
	//**********************************************************************************
	/**
	 * Constructor for SecretBag class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc secretTypeId
		 */
		this.secretTypeId = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "secretTypeId", SecretBag.defaultValues("secretTypeId"));
		/**
		 * @type {*}
		 * @desc secretValue
		 */
		this.secretValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "secretValue", SecretBag.defaultValues("secretValue"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "secretTypeId":
				return "";
			case "secretValue":
				return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]());
			default:
				throw new Error(`Invalid member name for SecretBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "secretTypeId":
				return (memberValue === "");
			case "secretValue":
				return (memberValue instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]);
			default:
				throw new Error(`Invalid member name for SecretBag class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SecretBag ::= SEQUENCE {
	 *    secretTypeId BAG-TYPE.&id ({SecretTypes}),
	 *    secretValue  [0] EXPLICIT BAG-TYPE.&Type ({SecretTypes}{@secretTypeId})
	 * }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [id]
		 * @property {string} [value]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.id || "id") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]({ name: (names.value || "value") })] // EXPLICIT ANY value
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"secretTypeId",
			"secretValue"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			SecretBag.schema({
				names: {
					id: "secretTypeId",
					value: "secretValue"
				}
			})
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for SecretBag");
		//endregion
		
		//region Get internal properties from parsed schema
		this.secretTypeId = asn1.result.secretTypeId.valueBlock.toString();
		this.secretValue = asn1.result.secretValue;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.secretTypeId }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [this.secretValue.toSchema()]
				})
			]
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			secretTypeId: this.secretTypeId,
			secretValue: this.secretValue.toJSON()
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/Signature.js":
/*!*********************************************!*\
  !*** ./node_modules/pkijs/src/Signature.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Signature; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Certificate.js */ "./node_modules/pkijs/src/Certificate.js");




//**************************************************************************************
/**
 * Class from RFC6960
 */
class Signature
{
	//**********************************************************************************
	/**
	 * Constructor for Signature class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc signatureAlgorithm
		 */
		this.signatureAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureAlgorithm", Signature.defaultValues("signatureAlgorithm"));
		/**
		 * @type {BitString}
		 * @desc signature
		 */
		this.signature = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signature", Signature.defaultValues("signature"));

		if("certs" in parameters)
			/**
			 * @type {Array.<Certificate>}
			 * @desc certs
			 */
			this.certs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certs", Signature.defaultValues("certs"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "signatureAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "signature":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]();
			case "certs":
				return [];
			default:
				throw new Error(`Invalid member name for Signature class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "signatureAlgorithm":
				return ((memberValue.algorithmId === "") && (("algorithmParams" in memberValue) === false));
			case "signature":
				return (memberValue.isEqual(Signature.defaultValues(memberName)));
			case "certs":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for Signature class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * Signature       ::=     SEQUENCE {
	 *    signatureAlgorithm      AlgorithmIdentifier,
	 *    signature               BIT STRING,
	 *    certs               [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [signatureAlgorithm]
		 * @property {string} [signature]
		 * @property {string} [certs]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.signatureAlgorithm || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["BitString"]({ name: (names.signature || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
							value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
								name: (names.certs || ""),
								value: _Certificate_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.certs || {})
							})]
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"signatureAlgorithm",
			"signature",
			"certs"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			Signature.schema({
				names: {
					signatureAlgorithm: {
						names: {
							blockName: "signatureAlgorithm"
						}
					},
					signature: "signature",
					certs: "certs"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for Signature");
		//endregion

		//region Get internal properties from parsed schema
		this.signatureAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.signatureAlgorithm });
		this.signature = asn1.result.signature;

		if("certs" in asn1.result)
			this.certs = Array.from(asn1.result.certs, element => new _Certificate_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array of output sequence
		const outputArray = [];

		outputArray.push(this.signatureAlgorithm.toSchema());
		outputArray.push(this.signature);

		if("certs" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
						value: Array.from(this.certs, element => element.toSchema())
					})
				]
			}));
		}
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			signatureAlgorithm: this.signatureAlgorithm.toJSON(),
			signature: this.signature.toJSON()
		};

		if("certs" in this)
			_object.certs = Array.from(this.certs, element => element.toJSON());

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/SignedAndUnsignedAttributes.js":
/*!***************************************************************!*\
  !*** ./node_modules/pkijs/src/SignedAndUnsignedAttributes.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SignedAndUnsignedAttributes; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");



//**************************************************************************************
/**
 * Class from RFC5652
 */
class SignedAndUnsignedAttributes
{
	//**********************************************************************************
	/**
	 * Constructor for SignedAndUnsignedAttributes class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc type
		 */
		this.type = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "type", SignedAndUnsignedAttributes.defaultValues("type"));
		/**
		 * @type {Array}
		 * @desc attributes
		 */
		this.attributes = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "attributes", SignedAndUnsignedAttributes.defaultValues("attributes"));
		/**
		 * @type {ArrayBuffer}
		 * @desc encodedValue Need to have it in order to successfully process with signature verification
		 */
		this.encodedValue = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encodedValue", SignedAndUnsignedAttributes.defaultValues("encodedValue"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "type":
				return (-1);
			case "attributes":
				return [];
			case "encodedValue":
				return new ArrayBuffer(0);
			default:
				throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "type":
				return (memberValue === SignedAndUnsignedAttributes.defaultValues("type"));
			case "attributes":
				return (memberValue.length === 0);
			case "encodedValue":
				return (memberValue.byteLength === 0);
			default:
				throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SignedAttributes ::= SET SIZE (1..MAX) OF Attribute
	 *
	 * UnsignedAttributes ::= SET SIZE (1..MAX) OF Attribute
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {number} [tagNumber]
		 * @property {string} [attributes]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
			name: (names.blockName || ""),
			optional: true,
			idBlock: {
				tagClass: 3, // CONTEXT-SPECIFIC
				tagNumber: names.tagNumber // "SignedAttributes" = 0, "UnsignedAttributes" = 1
			},
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.attributes || ""),
					value: _Attribute_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"attributes"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			SignedAndUnsignedAttributes.schema({
				names: {
					tagNumber: this.type,
					attributes: "attributes"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for SignedAndUnsignedAttributes");
		//endregion

		//region Get internal properties from parsed schema
		this.type = asn1.result.idBlock.tagNumber;
		this.encodedValue = asn1.result.valueBeforeDecode;

		//region Change type from "[0]" to "SET" accordingly to standard
		const encodedView = new Uint8Array(this.encodedValue);
		encodedView[0] = 0x31;
		//endregion

		if(("attributes" in asn1.result) === false)
		{
			if(this.type === 0)
				throw new Error("Wrong structure of SignedUnsignedAttributes");
			else
				return; // Not so important in case of "UnsignedAttributes"
		}

		this.attributes = Array.from(asn1.result.attributes, element => new _Attribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		if(SignedAndUnsignedAttributes.compareWithDefault("type", this.type) || SignedAndUnsignedAttributes.compareWithDefault("attributes", this.attributes))
			throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class");
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
			optional: true,
			idBlock: {
				tagClass: 3, // CONTEXT-SPECIFIC
				tagNumber: this.type // "SignedAttributes" = 0, "UnsignedAttributes" = 1
			},
			value: Array.from(this.attributes, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		if(SignedAndUnsignedAttributes.compareWithDefault("type", this.type) || SignedAndUnsignedAttributes.compareWithDefault("attributes", this.attributes))
			throw new Error("Incorrectly initialized \"SignedAndUnsignedAttributes\" class");
		
		return {
			type: this.type,
			attributes: Array.from(this.attributes, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/SignedCertificateTimestampList.js":
/*!******************************************************************!*\
  !*** ./node_modules/pkijs/src/SignedCertificateTimestampList.js ***!
  \******************************************************************/
/*! exports provided: SignedCertificateTimestamp, default, verifySCTsForCertificate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignedCertificateTimestamp", function() { return SignedCertificateTimestamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SignedCertificateTimestampList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifySCTsForCertificate", function() { return verifySCTsForCertificate; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var bytestreamjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bytestreamjs */ "./node_modules/bytestreamjs/src/bytestream.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PublicKeyInfo.js */ "./node_modules/pkijs/src/PublicKeyInfo.js");





//**************************************************************************************
class SignedCertificateTimestamp
{
	//**********************************************************************************
	/**
	 * Constructor for SignedCertificateTimestamp class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", SignedCertificateTimestamp.defaultValues("version"));
		/**
		 * @type {ArrayBuffer}
		 * @desc logID
		 */
		this.logID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "logID", SignedCertificateTimestamp.defaultValues("logID"));
		/**
		 * @type {Date}
		 * @desc timestamp
		 */
		this.timestamp = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "timestamp", SignedCertificateTimestamp.defaultValues("timestamp"));
		/**
		 * @type {ArrayBuffer}
		 * @desc extensions
		 */
		this.extensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "extensions", SignedCertificateTimestamp.defaultValues("extensions"));
		/**
		 * @type {string}
		 * @desc hashAlgorithm
		 */
		this.hashAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "hashAlgorithm", SignedCertificateTimestamp.defaultValues("hashAlgorithm"));
		/**
		 * @type {string}
		 * @desc signatureAlgorithm
		 */
		this.signatureAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureAlgorithm", SignedCertificateTimestamp.defaultValues("signatureAlgorithm"));
		/**
		 * @type {Object}
		 * @desc signature
		 */
		this.signature = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signature", SignedCertificateTimestamp.defaultValues("signature"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
		
		//region If input argument array contains "stream"
		if("stream" in parameters)
			this.fromStream(parameters.stream);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "logID":
			case "extensions":
				return new ArrayBuffer(0);
			case "timestamp":
				return new Date(0);
			case "hashAlgorithm":
			case "signatureAlgorithm":
				return "";
			case "signature":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
			default:
				throw new Error(`Invalid member name for SignedCertificateTimestamp class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		if((schema instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["RawData"]) === false)
			throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");
		
		const seqStream = new bytestreamjs__WEBPACK_IMPORTED_MODULE_2__["SeqStream"]({
			stream: new bytestreamjs__WEBPACK_IMPORTED_MODULE_2__["ByteStream"]({
				buffer: schema.data
			})
		});
		
		this.fromStream(seqStream);
	}
	//**********************************************************************************
	/**
	 * Convert SeqStream data into current class
	 * @param {!SeqStream} stream
	 */
	fromStream(stream)
	{
		const blockLength = stream.getUint16();
		
		this.version = (stream.getBlock(1))[0];
		
		if(this.version === 0)
		{
			this.logID = (new Uint8Array(stream.getBlock(32))).buffer.slice(0);
			this.timestamp = new Date(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilFromBase"])(new Uint8Array(stream.getBlock(8)), 8));
			
			//region Extensions
			const extensionsLength = stream.getUint16();
			this.extensions = (new Uint8Array(stream.getBlock(extensionsLength))).buffer.slice(0);
			//endregion
			
			//region Hash algorithm
			switch((stream.getBlock(1))[0])
			{
				case 0:
					this.hashAlgorithm = "none";
					break;
				case 1:
					this.hashAlgorithm = "md5";
					break;
				case 2:
					this.hashAlgorithm = "sha1";
					break;
				case 3:
					this.hashAlgorithm = "sha224";
					break;
				case 4:
					this.hashAlgorithm = "sha256";
					break;
				case 5:
					this.hashAlgorithm = "sha384";
					break;
				case 6:
					this.hashAlgorithm = "sha512";
					break;
				default:
					throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
			}
			//endregion
			
			//region Signature algorithm
			switch((stream.getBlock(1))[0])
			{
				case 0:
					this.signatureAlgorithm = "anonymous";
					break;
				case 1:
					this.signatureAlgorithm = "rsa";
					break;
				case 2:
					this.signatureAlgorithm = "dsa";
					break;
				case 3:
					this.signatureAlgorithm = "ecdsa";
					break;
				default:
					throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
			}
			//endregion
			
			//region Signature
			const signatureLength = stream.getUint16();
			const signatureData = (new Uint8Array(stream.getBlock(signatureLength))).buffer.slice(0);
			
			const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](signatureData);
			if(asn1.offset === (-1))
				throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
			
			this.signature = asn1.result;
			//endregion
			
			if(blockLength !== (47 + extensionsLength + signatureLength))
				throw new Error("Object's stream was not correct for SignedCertificateTimestamp");
		}
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		const stream = this.toStream();
		
		return new asn1js__WEBPACK_IMPORTED_MODULE_0__["RawData"]({ data: stream.stream.buffer });
	}
	//**********************************************************************************
	/**
	 * Convert current object to SeqStream data
	 * @returns {SeqStream} SeqStream object
	 */
	toStream()
	{
		const stream = new bytestreamjs__WEBPACK_IMPORTED_MODULE_2__["SeqStream"]();
		
		stream.appendUint16(47 + this.extensions.byteLength + this.signature.valueBeforeDecode.byteLength);
		stream.appendChar(this.version);
		stream.appendView(new Uint8Array(this.logID));
		
		const timeBuffer = new ArrayBuffer(8);
		const timeView = new Uint8Array(timeBuffer);
		
		const baseArray = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilToBase"])(this.timestamp.valueOf(), 8);
		timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
		
		stream.appendView(timeView);
		stream.appendUint16(this.extensions.byteLength);
		
		if(this.extensions.byteLength)
			stream.appendView(new Uint8Array(this.extensions));
		
		let _hashAlgorithm;
		
		switch(this.hashAlgorithm.toLowerCase())
		{
			case "none":
				_hashAlgorithm = 0;
				break;
			case "md5":
				_hashAlgorithm = 1;
				break;
			case "sha1":
				_hashAlgorithm = 2;
				break;
			case "sha224":
				_hashAlgorithm = 3;
				break;
			case "sha256":
				_hashAlgorithm = 4;
				break;
			case "sha384":
				_hashAlgorithm = 5;
				break;
			case "sha512":
				_hashAlgorithm = 6;
				break;
			default:
				throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`);
		}
		
		stream.appendChar(_hashAlgorithm);
		
		let _signatureAlgorithm;
		
		switch(this.signatureAlgorithm.toLowerCase())
		{
			case "anonymous":
				_signatureAlgorithm = 0;
				break;
			case "rsa":
				_signatureAlgorithm = 1;
				break;
			case "dsa":
				_signatureAlgorithm = 2;
				break;
			case "ecdsa":
				_signatureAlgorithm = 3;
				break;
			default:
				throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`);
		}
		
		stream.appendChar(_signatureAlgorithm);
		
		const _signature = this.signature.toBER(false);
		
		stream.appendUint16(_signature.byteLength);
		stream.appendView(new Uint8Array(_signature));
		
		return stream;
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			version: this.version,
			logID: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["bufferToHexCodes"])(this.logID),
			timestamp: this.timestamp,
			extensions: Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["bufferToHexCodes"])(this.extensions),
			hashAlgorithm: this.hashAlgorithm,
			signatureAlgorithm: this.signatureAlgorithm,
			signature: this.signature.toJSON()
		};
	}
	//**********************************************************************************
	/**
	 * Verify SignedCertificateTimestamp for specific input data
	 * @param {Object[]} logs Array of objects with information about each CT Log (like here: https://ct.grahamedgecombe.com/logs.json)
	 * @param {String} logs.log_id Identifier of the CT Log encoded in BASE-64 format
	 * @param {String} logs.key Public key of the CT Log encoded in BASE-64 format
	 * @param {ArrayBuffer} data Data to verify signature against. Could be encoded Certificate or encoded PreCert
	 * @param {Number} [dataType=0] Type = 0 (data is encoded Certificate), type = 1 (data is encoded PreCert)
	 * @return {Promise<void>}
	 */
	async verify(logs, data, dataType = 0)
	{
		//region Initial variables
		let logId = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["toBase64"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["arrayBufferToString"])(this.logID));
		
		let publicKeyBase64 = null;
		let publicKeyInfo;
		
		let stream = new bytestreamjs__WEBPACK_IMPORTED_MODULE_2__["SeqStream"]();
		//endregion
		
		//region Found and init public key
		for(const log of logs)
		{
			if(log.log_id === logId)
			{
				publicKeyBase64 = log.key;
				break;
			}
		}
		
		if(publicKeyBase64 === null)
			throw new Error(`Public key not found for CT with logId: ${logId}`);
		
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["stringToArrayBuffer"])(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["fromBase64"])(publicKeyBase64)));
		if(asn1.offset === (-1))
			throw new Error(`Incorrect key value for CT Log with logId: ${logId}`);
		
		publicKeyInfo = new _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result });
		//endregion
		
		//region Initialize signed data block
		stream.appendChar(0x00); // sct_version
		stream.appendChar(0x00); // signature_type = certificate_timestamp
		
		const timeBuffer = new ArrayBuffer(8);
		const timeView = new Uint8Array(timeBuffer);
		
		const baseArray = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilToBase"])(this.timestamp.valueOf(), 8);
		timeView.set(new Uint8Array(baseArray), 8 - baseArray.byteLength);
		
		stream.appendView(timeView);
		
		stream.appendUint16(dataType);
		
		if(dataType === 0)
			stream.appendUint24(data.byteLength);
		
		stream.appendView(new Uint8Array(data));
		
		stream.appendUint16(this.extensions.byteLength);
		
		if(this.extensions.byteLength !== 0)
			stream.appendView(new Uint8Array(this.extensions));
		//endregion
		
		//region Perform verification
		return Object(_common_js__WEBPACK_IMPORTED_MODULE_3__["getEngine"])().subtle.verifyWithPublicKey(
			stream._stream._buffer.slice(0, stream._length),
			{ valueBlock: { valueHex: this.signature.toBER(false) } },
			publicKeyInfo,
			{ algorithmId: "" },
			"SHA-256"
		);
		//endregion
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Class from RFC6962
 */
class SignedCertificateTimestampList
{
	//**********************************************************************************
	/**
	 * Constructor for SignedCertificateTimestampList class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<SignedCertificateTimestamp>}
		 * @desc timestamps
		 */
		this.timestamps = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "timestamps", SignedCertificateTimestampList.defaultValues("timestamps"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "timestamps":
				return [];
			default:
				throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "timestamps":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for SignedCertificateTimestampList class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SignedCertificateTimestampList ::= OCTET STRING
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [optional]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		if(("optional" in names) === false)
			names.optional = false;
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({
			name: (names.blockName || "SignedCertificateTimestampList"),
			optional: names.optional
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Check the schema is valid
		if((schema instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]) === false)
			throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
		//endregion
		
		//region Get internal properties from parsed schema
		const seqStream = new bytestreamjs__WEBPACK_IMPORTED_MODULE_2__["SeqStream"]({
			stream: new bytestreamjs__WEBPACK_IMPORTED_MODULE_2__["ByteStream"]({
				buffer: schema.valueBlock.valueHex
			})
		});
		
		let dataLength = seqStream.getUint16();
		if(dataLength !== seqStream.length)
			throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");
		
		while(seqStream.length)
			this.timestamps.push(new SignedCertificateTimestamp({ stream: seqStream }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Initial variables
		const stream = new bytestreamjs__WEBPACK_IMPORTED_MODULE_2__["SeqStream"]();
		
		let overallLength = 0;
		
		const timestampsData = [];
		//endregion
		
		//region Get overall length
		for(const timestamp of this.timestamps)
		{
			const timestampStream = timestamp.toStream();
			timestampsData.push(timestampStream);
			overallLength += timestampStream.stream.buffer.byteLength;
		}
		//endregion
		
		stream.appendUint16(overallLength);
		
		//region Set data from all timestamps
		for(const timestamp of timestampsData)
			stream.appendView(timestamp.stream.view);
		//endregion
		
		return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: stream.stream.buffer.slice(0) });
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			timestamps: Array.from(this.timestamps, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************
/**
 * Verify SignedCertificateTimestamp for specific certificate content
 * @param {Certificate} certificate Certificate for which verification would be performed
 * @param {Certificate} issuerCertificate Certificate of the issuer of target certificate
 * @param {Object[]} logs Array of objects with information about each CT Log (like here: https://ct.grahamedgecombe.com/logs.json)
 * @param {String} logs.log_id Identifier of the CT Log encoded in BASE-64 format
 * @param {String} logs.key Public key of the CT Log encoded in BASE-64 format
 * @param {Number} [index=-1] Index of SignedCertificateTimestamp inside SignedCertificateTimestampList (for -1 would verify all)
 * @return {Array} Array of verification results
 */
async function verifySCTsForCertificate(certificate, issuerCertificate, logs, index = (-1))
{
	//region Initial variables
	let parsedValue = null;
	let tbs;
	let issuerId;
	
	const stream = new bytestreamjs__WEBPACK_IMPORTED_MODULE_2__["SeqStream"]();
	
	let preCert;
	//endregion
	
	//region Get a "crypto" extension
	const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_3__["getCrypto"])();
	if(typeof crypto === "undefined")
		return Promise.reject("Unable to create WebCrypto object");
	//endregion
	
	//region Remove certificate extension
	for(let i = 0; i < certificate.extensions.length; i++)
	{
		switch(certificate.extensions[i].extnID)
		{
			case "1.3.6.1.4.1.11129.2.4.2":
				{
					parsedValue = certificate.extensions[i].parsedValue;
					
					if(parsedValue.timestamps.length === 0)
						throw new Error("Nothing to verify in the certificate");
					
					certificate.extensions.splice(i, 1);
				}
				break;
			default:
		}
	}
	//endregion
	
	//region Check we do have what to verify
	if(parsedValue === null)
		throw new Error("No SignedCertificateTimestampList extension in the specified certificate");
	//endregion
	
	//region Prepare modifier TBS value
	tbs = certificate.encodeTBS().toBER(false);
	//endregion
	
	//region Initialize "issuer_key_hash" value
	issuerId = await crypto.digest({ name: "SHA-256" }, new Uint8Array(issuerCertificate.subjectPublicKeyInfo.toSchema().toBER(false)));
	//endregion
	
	//region Make final "PreCert" value
	stream.appendView(new Uint8Array(issuerId));
	stream.appendUint24(tbs.byteLength);
	stream.appendView(new Uint8Array(tbs));
	
	preCert = stream._stream._buffer.slice(0, stream._length);
	//endregion
	
	//region Call verification function for specified index
	if(index === (-1))
	{
		const verifyArray = [];
		
		for(const timestamp of parsedValue.timestamps)
		{
			const verifyResult = await timestamp.verify(logs, preCert, 1);
			verifyArray.push(verifyResult);
		}
		
		return verifyArray;
	}
	
	if(index >= parsedValue.timestamps.length)
		index = (parsedValue.timestamps.length - 1);
	
	return [await parsedValue.timestamps[index].verify(logs, preCert, 1)];
	//endregion
}
//**********************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/SignedData.js":
/*!**********************************************!*\
  !*** ./node_modules/pkijs/src/SignedData.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SignedData; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _EncapsulatedContentInfo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EncapsulatedContentInfo.js */ "./node_modules/pkijs/src/EncapsulatedContentInfo.js");
/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Certificate.js */ "./node_modules/pkijs/src/Certificate.js");
/* harmony import */ var _CertificateRevocationList_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CertificateRevocationList.js */ "./node_modules/pkijs/src/CertificateRevocationList.js");
/* harmony import */ var _OtherRevocationInfoFormat_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./OtherRevocationInfoFormat.js */ "./node_modules/pkijs/src/OtherRevocationInfoFormat.js");
/* harmony import */ var _SignerInfo_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SignerInfo.js */ "./node_modules/pkijs/src/SignerInfo.js");
/* harmony import */ var _CertificateSet_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CertificateSet.js */ "./node_modules/pkijs/src/CertificateSet.js");
/* harmony import */ var _RevocationInfoChoices_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./RevocationInfoChoices.js */ "./node_modules/pkijs/src/RevocationInfoChoices.js");
/* harmony import */ var _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./IssuerAndSerialNumber.js */ "./node_modules/pkijs/src/IssuerAndSerialNumber.js");
/* harmony import */ var _TSTInfo_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TSTInfo.js */ "./node_modules/pkijs/src/TSTInfo.js");
/* harmony import */ var _CertificateChainValidationEngine_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CertificateChainValidationEngine.js */ "./node_modules/pkijs/src/CertificateChainValidationEngine.js");
/* harmony import */ var _BasicOCSPResponse_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./BasicOCSPResponse.js */ "./node_modules/pkijs/src/BasicOCSPResponse.js");
/* harmony import */ var _OtherCertificateFormat_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./OtherCertificateFormat.js */ "./node_modules/pkijs/src/OtherCertificateFormat.js");
/* harmony import */ var _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./AttributeCertificateV1.js */ "./node_modules/pkijs/src/AttributeCertificateV1.js");
/* harmony import */ var _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./AttributeCertificateV2.js */ "./node_modules/pkijs/src/AttributeCertificateV2.js");


















//**************************************************************************************
/**
 * Class from RFC5652
 */
class SignedData 
{

	//**********************************************************************************
	/**
	 * Constructor for SignedData class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", SignedData.defaultValues("version"));
		/**
		 * @type {Array.<AlgorithmIdentifier>}
		 * @desc digestAlgorithms
		 */
		this.digestAlgorithms = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "digestAlgorithms", SignedData.defaultValues("digestAlgorithms"));
		/**
		 * @type {EncapsulatedContentInfo}
		 * @desc encapContentInfo
		 */
		this.encapContentInfo = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "encapContentInfo", SignedData.defaultValues("encapContentInfo"));
		
		if("certificates" in parameters)
			/**
			 * @type {Array.<Certificate|OtherCertificateFormat>}
			 * @desc certificates
			 */
			this.certificates = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certificates", SignedData.defaultValues("certificates"));
		
		if("crls" in parameters)
			/**
			 * @type {Array.<CertificateRevocationList|OtherRevocationInfoFormat>}
			 * @desc crls
			 */
			this.crls = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "crls", SignedData.defaultValues("crls"));
		
		if("ocsps" in parameters)
			/**
			 * @type {Array.<BasicOCSPResponse>}
			 * @desc crls
			 */
			this.ocsps = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "ocsps", SignedData.defaultValues("ocsps"));

		/**
		 * @type {Array.<SignerInfo>}
		 * @desc signerInfos
		 */
		this.signerInfos = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signerInfos", SignedData.defaultValues("signerInfos"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "digestAlgorithms":
				return [];
			case "encapContentInfo":
				return new _EncapsulatedContentInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			case "certificates":
				return [];
			case "crls":
				return [];
			case "ocsps":
				return [];
			case "signerInfos":
				return [];
			default:
				throw new Error(`Invalid member name for SignedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
				return (memberValue === SignedData.defaultValues("version"));
			case "encapContentInfo":
				return new _EncapsulatedContentInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			case "digestAlgorithms":
			case "certificates":
			case "crls":
			case "ocsps":
			case "signerInfos":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for SignedData class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SignedData ::= SEQUENCE {
	 *    version CMSVersion,
	 *    digestAlgorithms DigestAlgorithmIdentifiers,
	 *    encapContentInfo EncapsulatedContentInfo,
	 *    certificates [0] IMPLICIT CertificateSet OPTIONAL,
	 *    crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
	 *    signerInfos SignerInfos }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [optional]
		 * @property {string} [digestAlgorithms]
		 * @property {string} [encapContentInfo]
		 * @property {string} [certificates]
		 * @property {string} [crls]
		 * @property {string} [signerInfos]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		if(("optional" in names) === false)
			names.optional = false;
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "SignedData"),
			optional: names.optional,
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "SignedData.version") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.digestAlgorithms || "SignedData.digestAlgorithms"),
							value: _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema()
						})
					]
				}),
				_EncapsulatedContentInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.encapContentInfo || {
					names: {
						blockName: "SignedData.encapContentInfo"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					name: (names.certificates || "SignedData.certificates"),
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: _CertificateSet_js__WEBPACK_IMPORTED_MODULE_9__["default"].schema().valueBlock.value
				}), // IMPLICIT CertificateSet
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: _RevocationInfoChoices_js__WEBPACK_IMPORTED_MODULE_10__["default"].schema(names.crls || {
						names: {
							crls: "SignedData.crls"
						}
					}).valueBlock.value
				}), // IMPLICIT RevocationInfoChoices
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.signerInfos || "SignedData.signerInfos"),
							value: _SignerInfo_js__WEBPACK_IMPORTED_MODULE_8__["default"].schema()
						})
					]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"SignedData.version",
			"SignedData.digestAlgorithms",
			"SignedData.encapContentInfo",
			"SignedData.certificates",
			"SignedData.crls",
			"SignedData.signerInfos"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			SignedData.schema()
		);
		
		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for SignedData");
		//endregion
		
		//region Get internal properties from parsed schema
		this.version = asn1.result["SignedData.version"].valueBlock.valueDec;
		
		if("SignedData.digestAlgorithms" in asn1.result) // Could be empty SET of digest algorithms
			this.digestAlgorithms = Array.from(asn1.result["SignedData.digestAlgorithms"], algorithm => new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: algorithm }));
		
		this.encapContentInfo = new _EncapsulatedContentInfo_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result["SignedData.encapContentInfo"] });
		
		if("SignedData.certificates" in asn1.result)
		{
			const certificateSet = new _CertificateSet_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
				schema: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
					value: asn1.result["SignedData.certificates"].valueBlock.value
				})
			});
			this.certificates = certificateSet.certificates.slice(0); // Copy all just for making comfortable access
		}
		
		if("SignedData.crls" in asn1.result)
		{
			this.crls = Array.from(asn1.result["SignedData.crls"], crl =>
			{
				if(crl.idBlock.tagClass === 1)
					return new _CertificateRevocationList_js__WEBPACK_IMPORTED_MODULE_6__["default"]({ schema: crl });
				
				//region Create SEQUENCE from [1]
				crl.idBlock.tagClass = 1; // UNIVERSAL
				crl.idBlock.tagNumber = 16; // SEQUENCE
				//endregion
				
				return new _OtherRevocationInfoFormat_js__WEBPACK_IMPORTED_MODULE_7__["default"]({ schema: crl });
			});
		}
		
		if("SignedData.signerInfos" in asn1.result) // Could be empty SET SignerInfos
			this.signerInfos = Array.from(asn1.result["SignedData.signerInfos"], signerInfoSchema => new _SignerInfo_js__WEBPACK_IMPORTED_MODULE_8__["default"]({ schema: signerInfoSchema }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema(encodeFlag = false)
	{
		//region Create array for output sequence
		const outputArray = [];
		
		// IF ((certificates is present) AND
		// 	(any certificates with a type of other are present)) OR
		// 	((crls is present) AND
		// 	(any crls with a type of other are present))
		// THEN version MUST be 5
		// ELSE
		// 	IF (certificates is present) AND
		// 			(any version 2 attribute certificates are present)
		// 	THEN version MUST be 4
		// 	ELSE
		// 			IF ((certificates is present) AND
		// 				(any version 1 attribute certificates are present)) OR
		// 				(any SignerInfo structures are version 3) OR
		// 				(encapContentInfo eContentType is other than id-data)
		// 			THEN version MUST be 3
		// 			ELSE version MUST be 1
		if ((this.certificates && this.certificates.length && this.certificates.some(o => o instanceof _OtherCertificateFormat_js__WEBPACK_IMPORTED_MODULE_15__["default"]))
			|| (this.crls && this.crls.length && this.crls.some(o => o instanceof _OtherRevocationInfoFormat_js__WEBPACK_IMPORTED_MODULE_7__["default"]))) {
			this.version = 5;
		} else if (this.certificates && this.certificates.length && this.certificates.some(o => o instanceof _AttributeCertificateV2_js__WEBPACK_IMPORTED_MODULE_17__["default"])) {
			this.version = 4;
		} else if ((this.certificates && this.certificates.length && this.certificates.some(o => o instanceof _AttributeCertificateV1_js__WEBPACK_IMPORTED_MODULE_16__["default"]))
			|| this.signerInfos.some(o => o.version === 3)
			|| this.encapContentInfo.eContentType !== SignedData.ID_DATA) {
			this.version = 3;
		} else {
			this.version = 1;
		}

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
		
		//region Create array of digest algorithms
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
			value: Array.from(this.digestAlgorithms, algorithm => algorithm.toSchema(encodeFlag))
		}));
		//endregion
		
		outputArray.push(this.encapContentInfo.toSchema());
		
		if("certificates" in this)
		{
			const certificateSet = new _CertificateSet_js__WEBPACK_IMPORTED_MODULE_9__["default"]({ certificates: this.certificates });
			const certificateSetSchema = certificateSet.toSchema();
			
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3,
					tagNumber: 0
				},
				value: certificateSetSchema.valueBlock.value
			}));
		}
		
		if("crls" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.crls, crl =>
				{
					if(crl instanceof _OtherRevocationInfoFormat_js__WEBPACK_IMPORTED_MODULE_7__["default"])
					{
						const crlSchema = crl.toSchema(encodeFlag);
						
						crlSchema.idBlock.tagClass = 3;
						crlSchema.idBlock.tagNumber = 1;
						
						return crlSchema;
					}
					
					return crl.toSchema(encodeFlag);
				})
			}));
		}
		
		//region Create array of signer infos
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Set"]({
			value: Array.from(this.signerInfos, signerInfo => signerInfo.toSchema(encodeFlag))
		}));
		//endregion
		//endregion
		
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			version: this.version,
			digestAlgorithms: Array.from(this.digestAlgorithms, algorithm => algorithm.toJSON()),
			encapContentInfo: this.encapContentInfo.toJSON()
		};
		
		if("certificates" in this)
			_object.certificates = Array.from(this.certificates, certificate => certificate.toJSON());
		
		if("crls" in this)
			_object.crls = Array.from(this.crls, crl => crl.toJSON());
		
		_object.signerInfos = Array.from(this.signerInfos, signerInfo => signerInfo.toJSON());
		
		return _object;
	}
	//**********************************************************************************
	/**
	 * Verify current SignedData value
	 * @param {Object} [param={}]
	 * @param {Number} [param.signer = -1] Index of the signer which information we need to verify
	 * @param {ArrayBuffer} [param.data=new ArrayBuffer(0)]
	 * @param {Array.<Certificate>} [param.trustedCerts=[]]
	 * @param {Date} [param.checkDate=new Date()]
	 * @param {Boolean} [param.checkChain=false]
	 * @param {Boolean} [param.extendedMode=false]
	 * @param {?Function} [findOrigin=null]
	 * @param {?Function} [findIssuer=null]
	 */
	verify({
		signer = (-1),
		data = (new ArrayBuffer(0)),
		trustedCerts = [],
		checkDate = (new Date()),
		checkChain = false,
		extendedMode = false,
		passedWhenNotRevValues = false,
		findOrigin = null,
		findIssuer = null
	} = {})
	{
		//region Global variables
		let sequence = Promise.resolve();
		
		let messageDigestValue = new ArrayBuffer(0);
		
		let shaAlgorithm = "";
		
		let signerCertificate = {};
		
		let timestampSerial = null;
		
		let certificatePath = [];
		
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		//endregion
		
		//region Get a "crypto" extension
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion
		
		//region Get a signer number
		if(signer === (-1))
		{
			if(extendedMode)
			{
				return Promise.reject({
					date: checkDate,
					code: 1,
					message: "Unable to get signer index from input parameters",
					signatureVerified: null,
					signerCertificate: null,
					signerCertificateVerified: null
				});
			}
			
			return Promise.reject("Unable to get signer index from input parameters");
		}
		//endregion
		
		//region Check that certificates field was included in signed data
		if(("certificates" in this) === false)
		{
			if(extendedMode)
			{
				return Promise.reject({
					date: checkDate,
					code: 2,
					message: "No certificates attached to this signed data",
					signatureVerified: null,
					signerCertificate: null,
					signerCertificateVerified: null
				});
			}
			
			return Promise.reject("No certificates attached to this signed data");
		}
		//endregion
		
		//region Find a certificate for specified signer
		if(this.signerInfos[signer].sid instanceof _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_11__["default"])
		{
			sequence = sequence.then(() =>
			{
				for(const certificate of this.certificates)
				{
					if((certificate instanceof _Certificate_js__WEBPACK_IMPORTED_MODULE_5__["default"]) === false)
						continue;
					
					if((certificate.issuer.isEqual(this.signerInfos[signer].sid.issuer)) &&
						(certificate.serialNumber.isEqual(this.signerInfos[signer].sid.serialNumber)))
					{
						signerCertificate = certificate;
						return Promise.resolve();
					}
				}
				
				if(extendedMode)
				{
					return Promise.reject({
						date: checkDate,
						code: 3,
						message: "Unable to find signer certificate",
						signatureVerified: null,
						signerCertificate: null,
						signerCertificateVerified: null
					});
				}
				
				return Promise.reject("Unable to find signer certificate");
			});
		}
		else // Find by SubjectKeyIdentifier
		{
			sequence = (async () => {
				try {
					const sid = this.signerInfos[signer].sid;
					const keyId = sid.idBlock.isConstructed
						? sid.valueBlock.value[0].valueBlock.valueHex // EXPLICIT OCTET STRING
						: sid.valueBlock.valueHex; // IMPLICIT OCTET STRING

					for (const certificate of this.certificates) {
						if (!(certificate instanceof _Certificate_js__WEBPACK_IMPORTED_MODULE_5__["default"])) {
							continue;
						}
					
						const digest = await crypto.digest({ name: "sha-1" }, new Uint8Array(certificate.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex));
						if(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(digest, keyId))
						{
							signerCertificate = certificate;
							break;
						}
					}
					
					if (!signerCertificate) {
						throw new Error("Signing certificate not found");
					}
				}
				catch (e) {
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 3,
							message: "Unable to find signer certificate",
							signatureVerified: null,
							signerCertificate: null,
							signerCertificateVerified: null
						});
					}
					
					throw "Unable to find signer certificate";
				}
			})();
		}
		//endregion
		
		//region Verify internal digest in case of "tSTInfo" content type
		sequence = sequence.then(() =>
		{
			if(this.encapContentInfo.eContentType === "1.2.840.113549.1.9.16.1.4")
			{
				//region Check "eContent" precense
				if(("eContent" in this.encapContentInfo) === false)
					return false;
				//endregion
				
				//region Initialize TST_INFO value
				const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.encapContentInfo.eContent.valueBlock.valueHex);
				let tstInfo;
				
				try
				{
					tstInfo = new _TSTInfo_js__WEBPACK_IMPORTED_MODULE_12__["default"]({ schema: asn1.result });
				}
				catch(ex)
				{
					return false;
				}
				//endregion
				
				//region Change "checkDate" and append "timestampSerial"
				checkDate = tstInfo.genTime;
				timestampSerial = tstInfo.serialNumber.valueBlock.valueHex;
				//endregion
				
				//region Check that we do have detached data content
				if(data.byteLength === 0)
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 4,
							message: "Missed detached data input array",
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: null
						});
					}
					
					return Promise.reject("Missed detached data input array");
				}
				//endregion
				
				return tstInfo.verify({ data });
			}
			
			return true;
		});
		//endregion
		
		//region Make additional verification for signer's certificate
		function checkCA(cert)
		{
			/// <param name="cert" type="in_window.org.pkijs.simpl.CERT">Certificate to find CA flag for</param>
			
			//region Do not include signer's certificate
			if((cert.issuer.isEqual(signerCertificate.issuer) === true) && (cert.serialNumber.isEqual(signerCertificate.serialNumber) === true))
				return null;
			//endregion
			
			let isCA = false;
			
			if("extensions" in cert)
			{
				for(const extension of cert.extensions)
				{
					if(extension.extnID === "2.5.29.19") // BasicConstraints
					{
						if("cA" in extension.parsedValue)
						{
							if(extension.parsedValue.cA === true)
								isCA = true;
						}
					}
				}
			}
			
			if(isCA)
				return cert;
			
			return null;
		}
		
		if(checkChain)
		{
			sequence = sequence.then(result =>
			{
				//region Verify result of previous operation
				if(result === false)
					return false;
				//endregion
				
				const promiseResults = Array.from(this.certificates.filter(certificate => (certificate instanceof _Certificate_js__WEBPACK_IMPORTED_MODULE_5__["default"])), certificate => checkCA(certificate));
				
				const certificateChainValidationEngineParameters = {
					checkDate,
					certs: Array.from(promiseResults.filter(_result => (_result !== null))),
					trustedCerts
				};
				
				if(findIssuer !== null)
					certificateChainValidationEngineParameters.findIssuer = findIssuer;
				
				if(findOrigin !== null)
					certificateChainValidationEngineParameters.findOrigin = findOrigin;
				
				const certificateChainEngine = new _CertificateChainValidationEngine_js__WEBPACK_IMPORTED_MODULE_13__["default"](certificateChainValidationEngineParameters);
				
				certificateChainEngine.certs.push(signerCertificate);
				
				if("crls" in this)
				{
					for(const crl of this.crls)
					{
						if("thisUpdate" in crl)
							certificateChainEngine.crls.push(crl);
						else // Assumed "revocation value" has "OtherRevocationInfoFormat"
						{
							if(crl.otherRevInfoFormat === "1.3.6.1.5.5.7.48.1.1") // Basic OCSP response
								certificateChainEngine.ocsps.push(new _BasicOCSPResponse_js__WEBPACK_IMPORTED_MODULE_14__["default"]({ schema: crl.otherRevInfo }));
						}
					}
				}
				
				if("ocsps" in this)
					certificateChainEngine.ocsps.push(...(this.ocsps));
				
				return certificateChainEngine.verify({ passedWhenNotRevValues }).then(verificationResult =>
				{
					if("certificatePath" in verificationResult)
						certificatePath = verificationResult.certificatePath;
					
					if(verificationResult.result === true)
						return Promise.resolve(true);
					
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 5,
							message: `Validation of signer's certificate failed: ${verificationResult.resultMessage}`,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: false
						});
					}
					
					return Promise.reject("Validation of signer's certificate failed");
				}, error =>
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 5,
							message: `Validation of signer's certificate failed with error: ${((error instanceof Object) ? error.resultMessage : error)}`,
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: false
						});
					}
					
					return Promise.reject(`Validation of signer's certificate failed with error: ${((error instanceof Object) ? error.resultMessage : error)}`);
				});
			});
		}
		//endregion
		
		//region Find signer's hashing algorithm
		sequence = sequence.then(result =>
		{
			//region Verify result of previous operation
			if(result === false)
				return false;
			//endregion
			
			const signerInfoHashAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(this.signerInfos[signer].digestAlgorithm.algorithmId);
			if(("name" in signerInfoHashAlgorithm) === false)
			{
				if(extendedMode)
				{
					return Promise.reject({
						date: checkDate,
						code: 7,
						message: `Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`,
						signatureVerified: null,
						signerCertificate,
						signerCertificateVerified: true
					});
				}
				
				return Promise.reject(`Unsupported signature algorithm: ${this.signerInfos[signer].digestAlgorithm.algorithmId}`);
			}
			
			shaAlgorithm = signerInfoHashAlgorithm.name;
			
			return true;
		});
		//endregion
		
		//region Create correct data block for verification
		sequence = sequence.then(result =>
		{
			//region Verify result of previous operation
			if(result === false)
				return false;
			//endregion
			
			if("eContent" in this.encapContentInfo) // Attached data
			{
				if((this.encapContentInfo.eContent.idBlock.tagClass === 1) &&
					(this.encapContentInfo.eContent.idBlock.tagNumber === 4))
				{
					if(this.encapContentInfo.eContent.idBlock.isConstructed === false)
						data = this.encapContentInfo.eContent.valueBlock.valueHex;
					else
					{
						for(const contentValue of this.encapContentInfo.eContent.valueBlock.value)
							data = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(data, contentValue.valueBlock.valueHex);
					}
				}
				else
					data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
			}
			else // Detached data
			{
				if(data.byteLength === 0) // Check that "data" already provided by function parameter
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 8,
							message: "Missed detached data input array",
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: true
						});
					}
					
					return Promise.reject("Missed detached data input array");
				}
			}
			
			if("signedAttrs" in this.signerInfos[signer])
			{
				//region Check mandatory attributes
				let foundContentType = false;
				let foundMessageDigest = false;
				
				for(const attribute of this.signerInfos[signer].signedAttrs.attributes)
				{
					//region Check that "content-type" attribute exists
					if(attribute.type === "1.2.840.113549.1.9.3")
						foundContentType = true;
					//endregion
					
					//region Check that "message-digest" attribute exists
					if(attribute.type === "1.2.840.113549.1.9.4")
					{
						foundMessageDigest = true;
						messageDigestValue = attribute.values[0].valueBlock.valueHex;
					}
					//endregion
					
					//region Speed-up searching
					if(foundContentType && foundMessageDigest)
						break;
					//endregion
				}
				
				if(foundContentType === false)
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 9,
							message: "Attribute \"content-type\" is a mandatory attribute for \"signed attributes\"",
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: true
						});
					}
					
					return Promise.reject("Attribute \"content-type\" is a mandatory attribute for \"signed attributes\"");
				}
				
				if(foundMessageDigest === false)
				{
					if(extendedMode)
					{
						return Promise.reject({
							date: checkDate,
							code: 10,
							message: "Attribute \"message-digest\" is a mandatory attribute for \"signed attributes\"",
							signatureVerified: null,
							signerCertificate,
							signerCertificateVerified: true
						});
					}
					
					return Promise.reject("Attribute \"message-digest\" is a mandatory attribute for \"signed attributes\"");
				}
				//endregion
			}
			
			return true;
		});
		//endregion
		
		//region Verify "message-digest" attribute in case of "signedAttrs"
		sequence = sequence.then(result =>
		{
			//region Verify result of previous operation
			if(result === false)
				return false;
			//endregion
			
			if("signedAttrs" in this.signerInfos[signer])
				return crypto.digest(shaAlgorithm, new Uint8Array(data));
			
			return true;
		}).then(
			/**
			 * @param {ArrayBuffer} result
			 */
			result =>
			{
				//region Verify result of previous operation
				if(result === false)
					return false;
				//endregion
				
				if("signedAttrs" in this.signerInfos[signer])
				{
					if(Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(result, messageDigestValue))
					{
						data = this.signerInfos[signer].signedAttrs.encodedValue;
						return true;
					}
					
					return false;
				}
				
				return true;
			});
		//endregion
		
		sequence = sequence.then(result =>
		{
			//region Verify result of previous operation
			if(result === false)
				return false;
			//endregion
			
			return engine.subtle.verifyWithPublicKey(data, this.signerInfos[signer].signature, signerCertificate.subjectPublicKeyInfo, signerCertificate.signatureAlgorithm, shaAlgorithm);
		});
		
		//region Make a final result
		sequence = sequence.then(result =>
		{
			if(extendedMode)
			{
				return {
					date: checkDate,
					code: 14,
					message: "",
					signatureVerified: result,
					signerCertificate,
					timestampSerial,
					signerCertificateVerified: true,
					certificatePath
				};
			}
			
			return result;
		}, error =>
		{
			if(extendedMode)
			{
				if("code" in error)
					return Promise.reject(error);
				
				return Promise.reject({
					date: checkDate,
					code: 15,
					message: `Error during verification: ${error.message}`,
					signatureVerified: null,
					signerCertificate,
					timestampSerial,
					signerCertificateVerified: true
				});
			}
			
			return Promise.reject(error);
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
	/**
	 * Signing current SignedData
	 * @param {key} privateKey Private key for "subjectPublicKeyInfo" structure
	 * @param {number} signerIndex Index number (starting from 0) of signer index to make signature for
	 * @param {string} [hashAlgorithm="SHA-1"] Hashing algorithm. Default SHA-1
	 * @param {ArrayBuffer} [data] Detached data
	 * @returns {*}
	 */
	sign(privateKey, signerIndex, hashAlgorithm = "SHA-1", data = (new ArrayBuffer(0)))
	{
		//region Initial checking
		if(typeof privateKey === "undefined")
			return Promise.reject("Need to provide a private key for signing");
		//endregion
		
		//region Initial variables
		let sequence = Promise.resolve();
		let parameters;
		
		const engine = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getEngine"])();
		//endregion
		
		//region Simple check for supported algorithm
		const hashAlgorithmOID = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getOIDByAlgorithm"])({ name: hashAlgorithm });
		if(hashAlgorithmOID === "")
			return Promise.reject(`Unsupported hash algorithm: ${hashAlgorithm}`);
		//endregion
		
		//region Append information about hash algorithm
		if((this.digestAlgorithms.filter(algorithm => algorithm.algorithmId === hashAlgorithmOID)).length === 0)
		{
			this.digestAlgorithms.push(new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
				algorithmId: hashAlgorithmOID,
				algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
			}));
		}
		
		this.signerInfos[signerIndex].digestAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
			algorithmId: hashAlgorithmOID,
			algorithmParams: new asn1js__WEBPACK_IMPORTED_MODULE_0__["Null"]()
		});
		//endregion
		
		//region Get a "default parameters" for current algorithm and set correct signature algorithm
		sequence = sequence.then(() => engine.subtle.getSignatureParameters(privateKey, hashAlgorithm));
		
		sequence = sequence.then(result =>
		{
			parameters = result.parameters;
			this.signerInfos[signerIndex].signatureAlgorithm = result.signatureAlgorithm;
		});
		//endregion
		
		//region Create TBS data for signing
		sequence = sequence.then(() =>
		{
			if("signedAttrs" in this.signerInfos[signerIndex])
			{
				if(this.signerInfos[signerIndex].signedAttrs.encodedValue.byteLength !== 0)
					data = this.signerInfos[signerIndex].signedAttrs.encodedValue;
				else
				{
					data = this.signerInfos[signerIndex].signedAttrs.toSchema(true).toBER(false);
					
					//region Change type from "[0]" to "SET" acordingly to standard
					const view = new Uint8Array(data);
					view[0] = 0x31;
					//endregion
				}
			}
			else
			{
				if("eContent" in this.encapContentInfo) // Attached data
				{
					if((this.encapContentInfo.eContent.idBlock.tagClass === 1) &&
						(this.encapContentInfo.eContent.idBlock.tagNumber === 4))
					{
						if(this.encapContentInfo.eContent.idBlock.isConstructed === false)
							data = this.encapContentInfo.eContent.valueBlock.valueHex;
						else
						{
							for(const content of this.encapContentInfo.eContent.valueBlock.value)
								data = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(data, content.valueBlock.valueHex);
						}
					}
					else
						data = this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;
				}
				else // Detached data
				{
					if(data.byteLength === 0) // Check that "data" already provided by function parameter
						return Promise.reject("Missed detached data input array");
				}
			}
			
			return Promise.resolve();
		});
		//endregion
		
		//region Signing TBS data on provided private key
		sequence = sequence.then(() => engine.subtle.signWithPrivateKey(data, privateKey, parameters));
		
		sequence = sequence.then(result =>
		{
			this.signerInfos[signerIndex].signature = new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ valueHex: result });
			
			return result;
		});
		//endregion
		
		return sequence;
	}
	//**********************************************************************************
}

SignedData.ID_DATA = "1.2.840.113549.1.7.1";
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/SignerInfo.js":
/*!**********************************************!*\
  !*** ./node_modules/pkijs/src/SignerInfo.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SignerInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony import */ var _SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SignedAndUnsignedAttributes.js */ "./node_modules/pkijs/src/SignedAndUnsignedAttributes.js");
/* harmony import */ var _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./IssuerAndSerialNumber.js */ "./node_modules/pkijs/src/IssuerAndSerialNumber.js");





//**************************************************************************************
/**
 * Class from RFC5652
 */
class SignerInfo 
{
	//**********************************************************************************
	/**
	 * Constructor for SignerInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {string}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", SignerInfo.defaultValues("version"));
		/**
		 * @type {Object}
		 * @desc sid
		 */
		this.sid = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "sid", SignerInfo.defaultValues("sid"));
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc digestAlgorithm
		 */
		this.digestAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "digestAlgorithm", SignerInfo.defaultValues("digestAlgorithm"));
		
		if("signedAttrs" in parameters)
			/**
			 * @type {SignedAndUnsignedAttributes}
			 * @desc signedAttrs
			 */
			this.signedAttrs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signedAttrs", SignerInfo.defaultValues("signedAttrs"));
		
		/**
		 * @type {AlgorithmIdentifier}
		 * @desc digestAlgorithm
		 */
		this.signatureAlgorithm = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signatureAlgorithm", SignerInfo.defaultValues("signatureAlgorithm"));
		/**
		 * @type {OctetString}
		 * @desc signature
		 */
		this.signature = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "signature", SignerInfo.defaultValues("signature"));
		
		if("unsignedAttrs" in parameters)
			/**
			 * @type {SignedAndUnsignedAttributes}
			 * @desc unsignedAttrs
			 */
			this.unsignedAttrs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "unsignedAttrs", SignerInfo.defaultValues("unsignedAttrs"));
		//endregion
		
		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "sid":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]();
			case "digestAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "signedAttrs":
				return new _SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ type: 0 });
			case "signatureAlgorithm":
				return new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "signature":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]();
			case "unsignedAttrs":
				return new _SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ type: 1 });
			default:
				throw new Error(`Invalid member name for SignerInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
				return (SignerInfo.defaultValues("version") === memberValue);
			case "sid":
				return (memberValue instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]);
			case "digestAlgorithm":
				if((memberValue instanceof _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]) === false)
					return false;

				return memberValue.isEqual(SignerInfo.defaultValues("digestAlgorithm"));
			case "signedAttrs":
				return ((_SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("type", memberValue.type))
				&& (_SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("attributes", memberValue.attributes))
				&& (_SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("encodedValue", memberValue.encodedValue)));
			case "signatureAlgorithm":
				if((memberValue instanceof _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]) === false)
					return false;

				return memberValue.isEqual(SignerInfo.defaultValues("signatureAlgorithm"));
			case "signature":
			case "unsignedAttrs":
				return ((_SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("type", memberValue.type))
				&& (_SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("attributes", memberValue.attributes))
				&& (_SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("encodedValue", memberValue.encodedValue)));
			default:
				throw new Error(`Invalid member name for SignerInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SignerInfo ::= SEQUENCE {
	 *    version CMSVersion,
	 *    sid SignerIdentifier,
	 *    digestAlgorithm DigestAlgorithmIdentifier,
	 *    signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
	 *    signatureAlgorithm SignatureAlgorithmIdentifier,
	 *    signature SignatureValue,
	 *    unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }
	 *
	 * SignerIdentifier ::= CHOICE {
	 *    issuerAndSerialNumber IssuerAndSerialNumber,
	 *    subjectKeyIdentifier [0] SubjectKeyIdentifier }
	 *
	 * SubjectKeyIdentifier ::= OCTET STRING
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{

		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [sid]
		 * @property {string} [digestAlgorithm]
		 * @property {string} [signedAttrs]
		 * @property {string} [signatureAlgorithm]
		 * @property {string} [signature]
		 * @property {string} [unsignedAttrs]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (
			new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				name: "SignerInfo",
				value: [
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "SignerInfo.version") }),
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
						value: [
							_IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.sid || {
								names: {
									blockName: "SignerInfo.sid"
								}
							}),
							new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
								value: [
									new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
										optional: true,
										name: (names.sid || "SignerInfo.sid"),
										idBlock: {
											tagClass: 3, // CONTEXT-SPECIFIC
											tagNumber: 0 // [0]
										},
										value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]()]
									}),
									new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
										optional: true,
										name: (names.sid || "SignerInfo.sid"),
										idBlock: {
											tagClass: 3, // CONTEXT-SPECIFIC
											tagNumber: 0 // [0]
										},
										value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]()]
									}),
								]
							}),
						]
					}),
					_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.digestAlgorithm || {
						names: {
							blockName: "SignerInfo.digestAlgorithm"
						}
					}),
					_SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.signedAttrs || {
						names: {
							blockName: "SignerInfo.signedAttrs",
							tagNumber: 0
						}
					}),
					_AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.signatureAlgorithm || {
						names: {
							blockName: "SignerInfo.signatureAlgorithm"
						}
					}),
					new asn1js__WEBPACK_IMPORTED_MODULE_0__["OctetString"]({ name: (names.signature || "SignerInfo.signature") }),
					_SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.unsignedAttrs || {
						names: {
							blockName: "SignerInfo.unsignedAttrs",
							tagNumber: 1
						}
					})
				]
			})
		);
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"SignerInfo.version",
			"SignerInfo.sid",
			"SignerInfo.digestAlgorithm",
			"SignerInfo.signedAttrs",
			"SignerInfo.signatureAlgorithm",
			"SignerInfo.signature",
			"SignerInfo.unsignedAttrs"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			SignerInfo.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for SignerInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result["SignerInfo.version"].valueBlock.valueDec;

		const currentSid = asn1.result["SignerInfo.sid"];
		if(currentSid.idBlock.tagClass === 1)
			this.sid = new _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: currentSid });
		else
			this.sid = currentSid;

		this.digestAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result["SignerInfo.digestAlgorithm"] });
		if("SignerInfo.signedAttrs" in asn1.result)
			this.signedAttrs = new _SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ type: 0, schema: asn1.result["SignerInfo.signedAttrs"] });
		
		this.signatureAlgorithm = new _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result["SignerInfo.signatureAlgorithm"] });
		this.signature = asn1.result["SignerInfo.signature"];
		if("SignerInfo.unsignedAttrs" in asn1.result)
			this.unsignedAttrs = new _SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ type: 1, schema: asn1.result["SignerInfo.unsignedAttrs"] });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		if(SignerInfo.compareWithDefault("sid", this.sid))
			throw new Error("Incorrectly initialized \"SignerInfo\" class");
		
		//region Create array for output sequence 
		const outputArray = [];
		
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
		
		if(this.sid instanceof _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_4__["default"])
			outputArray.push(this.sid.toSchema());
		else
			outputArray.push(this.sid);
		
		outputArray.push(this.digestAlgorithm.toSchema());
		
		if("signedAttrs" in this)
		{
			if(SignerInfo.compareWithDefault("signedAttrs", this.signedAttrs) === false)
				outputArray.push(this.signedAttrs.toSchema());
		}
		
		outputArray.push(this.signatureAlgorithm.toSchema());
		outputArray.push(this.signature);
		
		if("unsignedAttrs" in this)
		{
			if(SignerInfo.compareWithDefault("unsignedAttrs", this.unsignedAttrs) === false)
				outputArray.push(this.unsignedAttrs.toSchema());
		}
		//endregion 
		
		//region Construct and return new ASN.1 schema for this object 
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion 
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		if(SignerInfo.compareWithDefault("sid", this.sid))
			throw new Error("Incorrectly initialized \"SignerInfo\" class");
		
		const _object = {
			version: this.version
		};

		if(!(this.sid instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]))
			_object.sid = this.sid.toJSON();

		_object.digestAlgorithm = this.digestAlgorithm.toJSON();

		if(SignerInfo.compareWithDefault("signedAttrs", this.signedAttrs) === false)
			_object.signedAttrs = this.signedAttrs.toJSON();

		_object.signatureAlgorithm = this.signatureAlgorithm.toJSON();
		_object.signature = this.signature.toJSON();

		if(SignerInfo.compareWithDefault("unsignedAttrs", this.unsignedAttrs) === false)
			_object.unsignedAttrs = this.unsignedAttrs.toJSON();

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/SingleResponse.js":
/*!**************************************************!*\
  !*** ./node_modules/pkijs/src/SingleResponse.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SingleResponse; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _CertID_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CertID.js */ "./node_modules/pkijs/src/CertID.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/pkijs/src/Extension.js");
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Extensions.js */ "./node_modules/pkijs/src/Extensions.js");





//**************************************************************************************
/**
 * Class from RFC6960
 */
class SingleResponse
{
	//**********************************************************************************
	/**
	 * Constructor for SingleResponse class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {CertID}
		 * @desc certID
		 */
		this.certID = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certID", SingleResponse.defaultValues("certID"));
		/**
		 * @type {Object}
		 * @desc certStatus
		 */
		this.certStatus = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certStatus", SingleResponse.defaultValues("certStatus"));
		/**
		 * @type {Date}
		 * @desc thisUpdate
		 */
		this.thisUpdate = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "thisUpdate", SingleResponse.defaultValues("thisUpdate"));

		if("nextUpdate" in parameters)
			/**
			 * @type {Date}
			 * @desc nextUpdate
			 */
			this.nextUpdate = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "nextUpdate", SingleResponse.defaultValues("nextUpdate"));

		if("singleExtensions" in parameters)
			/**
			 * @type {Array.<Extension>}
			 * @desc singleExtensions
			 */
			this.singleExtensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "singleExtensions", SingleResponse.defaultValues("singleExtensions"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "certID":
				return new _CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "certStatus":
				return {};
			case "thisUpdate":
			case "nextUpdate":
				return new Date(0, 0, 0);
			case "singleExtensions":
				return [];
			default:
				throw new Error(`Invalid member name for SingleResponse class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "certID":
				// noinspection OverlyComplexBooleanExpressionJS
				return ((_CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm)) &&
						(_CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("issuerNameHash", memberValue.issuerNameHash)) &&
						(_CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("issuerKeyHash", memberValue.issuerKeyHash)) &&
						(_CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("serialNumber", memberValue.serialNumber)));
			case "certStatus":
				return (Object.keys(memberValue).length === 0);
			case "thisUpdate":
			case "nextUpdate":
				return (memberValue === SingleResponse.defaultValues(memberName));
			default:
				throw new Error(`Invalid member name for SingleResponse class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SingleResponse ::= SEQUENCE {
	 *    certID                       CertID,
	 *    certStatus                   CertStatus,
	 *    thisUpdate                   GeneralizedTime,
	 *    nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
	 *    singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
	 *
	 * CertStatus ::= CHOICE {
	 *    good        [0]     IMPLICIT NULL,
	 *    revoked     [1]     IMPLICIT RevokedInfo,
	 *    unknown     [2]     IMPLICIT UnknownInfo }
	 *
	 * RevokedInfo ::= SEQUENCE {
	 *    revocationTime              GeneralizedTime,
	 *    revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
	 *
	 * UnknownInfo ::= NULL
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [certID]
		 * @property {string} [certStatus]
		 * @property {string} [thisUpdate]
		 * @property {string} [nextUpdate]
		 * @property {string} [singleExtensions]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				_CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.certID || {}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
							name: (names.certStatus || ""),
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 0 // [0]
							},
							lenBlockLength: 1 // The length contains one byte 0x00
						}), // IMPLICIT NULL (no "valueBlock")
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
							name: (names.certStatus || ""),
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 1 // [1]
							},
							value: [
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"](),
								new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
									optional: true,
									idBlock: {
										tagClass: 3, // CONTEXT-SPECIFIC
										tagNumber: 0 // [0]
									},
									value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Enumerated"]()]
								})
							]
						}),
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Primitive"]({
							name: (names.certStatus || ""),
							idBlock: {
								tagClass: 3, // CONTEXT-SPECIFIC
								tagNumber: 2 // [2]
							},
							lenBlock: { length: 1 }
						}) // IMPLICIT NULL (no "valueBlock")
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ name: (names.thisUpdate || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ name: (names.nextUpdate || "") })]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [_Extensions_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.singleExtensions || {})]
				}) // EXPLICIT SEQUENCE value
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"certID",
			"certStatus",
			"thisUpdate",
			"nextUpdate",
			"singleExtensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			SingleResponse.schema({
				names: {
					certID: {
						names: {
							blockName: "certID"
						}
					},
					certStatus: "certStatus",
					thisUpdate: "thisUpdate",
					nextUpdate: "nextUpdate",
					singleExtensions: {
						names: {
							blockName:
								"singleExtensions"
						}
					}
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for SingleResponse");
		//endregion

		//region Get internal properties from parsed schema
		this.certID = new _CertID_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result.certID });
		this.certStatus = asn1.result.certStatus;
		this.thisUpdate = asn1.result.thisUpdate.toDate();
		if("nextUpdate" in asn1.result)
			this.nextUpdate = asn1.result.nextUpdate.toDate();

		if("singleExtensions" in asn1.result)
			this.singleExtensions = Array.from(asn1.result.singleExtensions.valueBlock.value, element => new _Extension_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create value array for output sequence
		const outputArray = [];

		outputArray.push(this.certID.toSchema());
		outputArray.push(this.certStatus);
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueDate: this.thisUpdate }));
		if("nextUpdate" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueDate: this.nextUpdate })]
			}));
		}

		if("singleExtensions" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: Array.from(this.singleExtensions, element => element.toSchema())
			}));
		}
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			certID: this.certID.toJSON(),
			certStatus: this.certStatus.toJSON(),
			thisUpdate: this.thisUpdate
		};

		if("nextUpdate" in this)
			_object.nextUpdate = this.nextUpdate;

		if("singleExtensions" in this)
			_object.singleExtensions = Array.from(this.singleExtensions, element => element.toJSON());

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/SubjectDirectoryAttributes.js":
/*!**************************************************************!*\
  !*** ./node_modules/pkijs/src/SubjectDirectoryAttributes.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SubjectDirectoryAttributes; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");



//**************************************************************************************
/**
 * Class from RFC5280
 */
class SubjectDirectoryAttributes
{
	//**********************************************************************************
	/**
	 * Constructor for SubjectDirectoryAttributes class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {Array.<Attribute>}
		 * @desc attributes
		 */
		this.attributes = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "attributes", SubjectDirectoryAttributes.defaultValues("attributes"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "attributes":
				return [];
			default:
				throw new Error(`Invalid member name for SubjectDirectoryAttributes class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * SubjectDirectoryAttributes ::= SEQUENCE SIZE (1..MAX) OF Attribute
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [utcTimeName] Name for "utcTimeName" choice
		 * @property {string} [generalTimeName] Name for "generalTimeName" choice
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || ""),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
					name: (names.attributes || ""),
					value: _Attribute_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema()
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"attributes"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			SubjectDirectoryAttributes.schema({
				names: {
					attributes: "attributes"
				}
			})
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");
		//endregion

		//region Get internal properties from parsed schema
		this.attributes = Array.from(asn1.result.attributes, element => new _Attribute_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: Array.from(this.attributes, element => element.toSchema())
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			attributes: Array.from(this.attributes, element => element.toJSON())
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/TBSRequest.js":
/*!**********************************************!*\
  !*** ./node_modules/pkijs/src/TBSRequest.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TBSRequest; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");
/* harmony import */ var _Request_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Request.js */ "./node_modules/pkijs/src/Request.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/pkijs/src/Extension.js");
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Extensions.js */ "./node_modules/pkijs/src/Extensions.js");






//**************************************************************************************
/**
 * Class from RFC6960
 */
class TBSRequest
{
	//**********************************************************************************
	/**
	 * Constructor for TBSRequest class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {ArrayBuffer}
		 * @desc tbs
		 */
		this.tbs = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "tbs", TBSRequest.defaultValues("tbs"));

		if("version" in parameters)
			/**
			 * @type {number}
			 * @desc version
			 */
			this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", TBSRequest.defaultValues("version"));

		if("requestorName" in parameters)
			/**
			 * @type {GeneralName}
			 * @desc requestorName
			 */
			this.requestorName = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "requestorName", TBSRequest.defaultValues("requestorName"));

		/**
		 * @type {Array.<Request>}
		 * @desc requestList
		 */
		this.requestList = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "requestList", TBSRequest.defaultValues("requestList"));

		if("requestExtensions" in parameters)
			/**
			 * @type {Array.<Extension>}
			 * @desc requestExtensions
			 */
			this.requestExtensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "requestExtensions", TBSRequest.defaultValues("requestExtensions"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "tbs":
				return new ArrayBuffer(0);
			case "version":
				return 0;
			case "requestorName":
				return new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "requestList":
			case "requestExtensions":
				return [];
			default:
				throw new Error(`Invalid member name for TBSRequest class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "tbs":
				return (memberValue.byteLength === 0);
			case "version":
				return (memberValue === TBSRequest.defaultValues(memberName));
			case "requestorName":
				return ((memberValue.type === _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].defaultValues("type")) && (Object.keys(memberValue.value).length === 0));
			case "requestList":
			case "requestExtensions":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for TBSRequest class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * TBSRequest      ::=     SEQUENCE {
	 *    version             [0]     EXPLICIT Version DEFAULT v1,
	 *    requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
	 *    requestList                 SEQUENCE OF Request,
	 *    requestExtensions   [2]     EXPLICIT Extensions OPTIONAL }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [TBSRequestVersion]
		 * @property {string} [requestorName]
		 * @property {string} [requestList]
		 * @property {string} [requests]
		 * @property {string} [requestNames]
		 * @property {string} [extensions]
		 * @property {string} [requestExtensions]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "TBSRequest"),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.TBSRequestVersion || "TBSRequest.version") })]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [_GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.requestorName || {
						names: {
							blockName: "TBSRequest.requestorName"
						}
					})]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
					name: (names.requestList || "TBSRequest.requestList"),
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.requests || "TBSRequest.requests"),
							value: _Request_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.requestNames || {})
						})
					]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					value: [_Extensions_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.extensions || {
						names: {
							blockName: (names.requestExtensions || "TBSRequest.requestExtensions")
						}
					})]
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"TBSRequest",
			"TBSRequest.version",
			"TBSRequest.requestorName",
			"TBSRequest.requests",
			"TBSRequest.requestExtensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			TBSRequest.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for TBSRequest");
		//endregion

		//region Get internal properties from parsed schema
		this.tbs = asn1.result.TBSRequest.valueBeforeDecode;

		if("TBSRequest.version" in asn1.result)
			this.version = asn1.result["TBSRequest.version"].valueBlock.valueDec;
		if("TBSRequest.requestorName" in asn1.result)
			this.requestorName = new _GeneralName_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result["TBSRequest.requestorName"] });

		this.requestList = Array.from(asn1.result["TBSRequest.requests"], element => new _Request_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: element }));

		if("TBSRequest.requestExtensions" in asn1.result)
			this.requestExtensions = Array.from(asn1.result["TBSRequest.requestExtensions"].valueBlock.value, element => new _Extension_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @param {boolean} encodeFlag If param equal to false then create TBS schema via decoding stored value. In othe case create TBS schema via assembling from TBS parts.
	 * @returns {Object} asn1js object
	 */
	toSchema(encodeFlag = false)
	{
		//region Decode stored TBS value
		let tbsSchema;

		if(encodeFlag === false)
		{
			if(this.tbs.byteLength === 0) // No stored TBS part
				return TBSRequest.schema();

			tbsSchema = asn1js__WEBPACK_IMPORTED_MODULE_0__["fromBER"](this.tbs).result;
		}
		//endregion
		//region Create TBS schema via assembling from TBS parts
		else
		{
			const outputArray = [];

			if("version" in this)
			{
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version })]
				}));
			}

			if("requestorName" in this)
			{
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [this.requestorName.toSchema()]
				}));
			}

			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: Array.from(this.requestList, element => element.toSchema())
			}));

			if("requestExtensions" in this)
			{
				outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 2 // [2]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
							value: Array.from(this.requestExtensions, element => element.toSchema())
						})
					]
				}));
			}

			tbsSchema = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
				value: outputArray
			});
		}
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return tbsSchema;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {};

		if("version" in this)
			_object.version = this.version;

		if("requestorName" in this)
			_object.requestorName = this.requestorName.toJSON();

		_object.requestList = Array.from(this.requestList, element => element.toJSON());

		if("requestExtensions" in this)
			_object.requestExtensions = Array.from(this.requestExtensions, element => element.toJSON());

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/TSTInfo.js":
/*!*******************************************!*\
  !*** ./node_modules/pkijs/src/TSTInfo.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TSTInfo; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony import */ var _MessageImprint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MessageImprint.js */ "./node_modules/pkijs/src/MessageImprint.js");
/* harmony import */ var _Accuracy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Accuracy.js */ "./node_modules/pkijs/src/Accuracy.js");
/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/pkijs/src/Extension.js");







//**************************************************************************************
/**
 * Class from RFC3161
 */
class TSTInfo
{
	//**********************************************************************************
	/**
	 * Constructor for TSTInfo class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", TSTInfo.defaultValues("version"));
		/**
		 * @type {string}
		 * @desc policy
		 */
		this.policy = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "policy", TSTInfo.defaultValues("policy"));
		/**
		 * @type {MessageImprint}
		 * @desc messageImprint
		 */
		this.messageImprint = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "messageImprint", TSTInfo.defaultValues("messageImprint"));
		/**
		 * @type {Integer}
		 * @desc serialNumber
		 */
		this.serialNumber = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "serialNumber", TSTInfo.defaultValues("serialNumber"));
		/**
		 * @type {Date}
		 * @desc genTime
		 */
		this.genTime = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "genTime", TSTInfo.defaultValues("genTime"));

		if("accuracy" in parameters)
			/**
			 * @type {Accuracy}
			 * @desc accuracy
			 */
			this.accuracy = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "accuracy", TSTInfo.defaultValues("accuracy"));

		if("ordering" in parameters)
			/**
			 * @type {boolean}
			 * @desc ordering
			 */
			this.ordering = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "ordering", TSTInfo.defaultValues("ordering"));

		if("nonce" in parameters)
			/**
			 * @type {Integer}
			 * @desc nonce
			 */
			this.nonce = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "nonce", TSTInfo.defaultValues("nonce"));

		if("tsa" in parameters)
			/**
			 * @type {GeneralName}
			 * @desc tsa
			 */
			this.tsa = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "tsa", TSTInfo.defaultValues("tsa"));

		if("extensions" in parameters)
			/**
			 * @type {Array.<Extension>}
			 * @desc extensions
			 */
			this.extensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "extensions", TSTInfo.defaultValues("extensions"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "policy":
				return "";
			case "messageImprint":
				return new _MessageImprint_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			case "serialNumber":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "genTime":
				return new Date(0, 0, 0);
			case "accuracy":
				return new _Accuracy_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
			case "ordering":
				return false;
			case "nonce":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "tsa":
				return new _GeneralName_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
			case "extensions":
				return [];
			default:
				throw new Error(`Invalid member name for TSTInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
			case "policy":
			case "genTime":
			case "ordering":
				return (memberValue === TSTInfo.defaultValues(memberName));
			case "messageImprint":
				return ((_MessageImprint_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm)) &&
						(_MessageImprint_js__WEBPACK_IMPORTED_MODULE_3__["default"].compareWithDefault("hashedMessage", memberValue.hashedMessage)));
			case "serialNumber":
			case "nonce":
				return (memberValue.isEqual(TSTInfo.defaultValues(memberName)));
			case "accuracy":
				return ((_Accuracy_js__WEBPACK_IMPORTED_MODULE_4__["default"].compareWithDefault("seconds", memberValue.seconds)) &&
						(_Accuracy_js__WEBPACK_IMPORTED_MODULE_4__["default"].compareWithDefault("millis", memberValue.millis)) &&
						(_Accuracy_js__WEBPACK_IMPORTED_MODULE_4__["default"].compareWithDefault("micros", memberValue.micros)));
			case "tsa":
				return ((_GeneralName_js__WEBPACK_IMPORTED_MODULE_5__["default"].compareWithDefault("type", memberValue.type)) &&
						(_GeneralName_js__WEBPACK_IMPORTED_MODULE_5__["default"].compareWithDefault("value", memberValue.value)));
			case "extensions":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for TSTInfo class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * TSTInfo ::= SEQUENCE  {
	 *   version                      INTEGER  { v1(1) },
	 *   policy                       TSAPolicyId,
	 *   messageImprint               MessageImprint,
	 *   serialNumber                 INTEGER,
	 *   genTime                      GeneralizedTime,
	 *   accuracy                     Accuracy                 OPTIONAL,
	 *   ordering                     BOOLEAN             DEFAULT FALSE,
	 *   nonce                        INTEGER                  OPTIONAL,
	 *   tsa                          [0] GeneralName          OPTIONAL,
	 *   extensions                   [1] IMPLICIT Extensions  OPTIONAL  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [version]
		 * @property {string} [policy]
		 * @property {string} [messageImprint]
		 * @property {string} [serialNumber]
		 * @property {string} [genTime]
		 * @property {string} [accuracy]
		 * @property {string} [ordering]
		 * @property {string} [nonce]
		 * @property {string} [tsa]
		 * @property {string} [extensions]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "TSTInfo"),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "TSTInfo.version") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ name: (names.policy || "TSTInfo.policy") }),
				_MessageImprint_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.messageImprint || {
					names: {
						blockName: "TSTInfo.messageImprint"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.serialNumber || "TSTInfo.serialNumber") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ name: (names.genTime || "TSTInfo.genTime") }),
				_Accuracy_js__WEBPACK_IMPORTED_MODULE_4__["default"].schema(names.accuracy || {
					names: {
						blockName: "TSTInfo.accuracy"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Boolean"]({
					name: (names.ordering || "TSTInfo.ordering"),
					optional: true
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
					name: (names.nonce || "TSTInfo.nonce"),
					optional: true
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [_GeneralName_js__WEBPACK_IMPORTED_MODULE_5__["default"].schema(names.tsa || {
						names: {
							blockName: "TSTInfo.tsa"
						}
					})]
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 1 // [1]
					},
					value: [
						new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
							name: (names.extensions || "TSTInfo.extensions"),
							value: _Extension_js__WEBPACK_IMPORTED_MODULE_6__["default"].schema(names.extension || {})
						})
					]
				}) // IMPLICIT Extensions
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"TSTInfo.version",
			"TSTInfo.policy",
			"TSTInfo.messageImprint",
			"TSTInfo.serialNumber",
			"TSTInfo.genTime",
			"TSTInfo.accuracy",
			"TSTInfo.ordering",
			"TSTInfo.nonce",
			"TSTInfo.tsa",
			"TSTInfo.extensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			TSTInfo.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for TSTInfo");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result["TSTInfo.version"].valueBlock.valueDec;
		this.policy = asn1.result["TSTInfo.policy"].valueBlock.toString();
		this.messageImprint = new _MessageImprint_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result["TSTInfo.messageImprint"] });
		this.serialNumber = asn1.result["TSTInfo.serialNumber"];
		this.genTime = asn1.result["TSTInfo.genTime"].toDate();
		if("TSTInfo.accuracy" in asn1.result)
			this.accuracy = new _Accuracy_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: asn1.result["TSTInfo.accuracy"] });
		if("TSTInfo.ordering" in asn1.result)
			this.ordering = asn1.result["TSTInfo.ordering"].valueBlock.value;
		if("TSTInfo.nonce" in asn1.result)
			this.nonce = asn1.result["TSTInfo.nonce"];
		if("TSTInfo.tsa" in asn1.result)
			this.tsa = new _GeneralName_js__WEBPACK_IMPORTED_MODULE_5__["default"]({ schema: asn1.result["TSTInfo.tsa"] });
		if("TSTInfo.extensions" in asn1.result)
			this.extensions = Array.from(asn1.result["TSTInfo.extensions"], element => new _Extension_js__WEBPACK_IMPORTED_MODULE_6__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.policy }));
		outputArray.push(this.messageImprint.toSchema());
		outputArray.push(this.serialNumber);
		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueDate: this.genTime }));
		if("accuracy" in this)
			outputArray.push(this.accuracy.toSchema());
		if("ordering" in this)
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Boolean"]({ value: this.ordering }));
		if("nonce" in this)
			outputArray.push(this.nonce);
		if("tsa" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: [this.tsa.toSchema()]
			}));
		}

		//region Create array of extensions
		if("extensions" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				optional: true,
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 1 // [1]
				},
				value: Array.from(this.extensions, element => element.toSchema())
			}));
		}
		//endregion
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			version: this.version,
			policy: this.policy,
			messageImprint: this.messageImprint.toJSON(),
			serialNumber: this.serialNumber.toJSON(),
			genTime: this.genTime
		};

		if("accuracy" in this)
			_object.accuracy = this.accuracy.toJSON();

		if("ordering" in this)
			_object.ordering = this.ordering;

		if("nonce" in this)
			_object.nonce = this.nonce.toJSON();

		if("tsa" in this)
			_object.tsa = this.tsa.toJSON();

		if("extensions" in this)
			_object.extensions = Array.from(this.extensions, element => element.toJSON());

		return _object;
	}
	//**********************************************************************************
	/**
	 * Verify current TST Info value
	 * @param {{data: ArrayBuffer, notBefore: Date, notAfter: Date}} parameters Input parameters
	 * @returns {Promise}
	 */
	verify(parameters = {})
	{
		//region Initial variables
		let sequence = Promise.resolve();

		let data;

		let notBefore = null;
		let notAfter = null;
		//endregion

		//region Get a "crypto" extension
		const crypto = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getCrypto"])();
		if(typeof crypto === "undefined")
			return Promise.reject("Unable to create WebCrypto object");
		//endregion

		//region Get initial parameters
		if("data" in parameters)
			data = parameters.data;
		else
			return Promise.reject("\"data\" is a mandatory attribute for TST_INFO verification");

		if("notBefore" in parameters)
			notBefore = parameters.notBefore;

		if("notAfter" in parameters)
			notAfter = parameters.notAfter;
		//endregion

		//region Check date
		if(notBefore !== null)
		{
			if(this.genTime < notBefore)
				return Promise.reject("Generation time for TSTInfo object is less than notBefore value");
		}
		
		if(notAfter !== null)
		{
			if(this.genTime > notAfter)
				return Promise.reject("Generation time for TSTInfo object is more than notAfter value");
		}
		//endregion
		
		//region Find hashing algorithm
		const shaAlgorithm = Object(_common_js__WEBPACK_IMPORTED_MODULE_2__["getAlgorithmByOID"])(this.messageImprint.hashAlgorithm.algorithmId);
		if(("name" in shaAlgorithm) === false)
			return Promise.reject(`Unsupported signature algorithm: ${this.messageImprint.hashAlgorithm.algorithmId}`);
		//endregion

		//region Calculate message digest for input "data" buffer
		// noinspection JSCheckFunctionSignatures
		sequence = sequence.then(() =>
			crypto.digest(shaAlgorithm.name, new Uint8Array(data))
		).then(
			result => Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["isEqualBuffer"])(result, this.messageImprint.hashedMessage.valueBlock.valueHex)
		);
		//endregion

		return sequence;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/Time.js":
/*!****************************************!*\
  !*** ./node_modules/pkijs/src/Time.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Time; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");


//**************************************************************************************
/**
 * Class from RFC5280
 */
class Time
{
	//**********************************************************************************
	/**
	 * Constructor for Time class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 * @property {number} [type] 0 - UTCTime; 1 - GeneralizedTime; 2 - empty value
	 * @property {Date} [value] Value of the TIME class
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc 0 - UTCTime; 1 - GeneralizedTime; 2 - empty value
		 */
		this.type = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "type", Time.defaultValues("type"));
		/**
		 * @type {Date}
		 * @desc Value of the TIME class
		 */
		this.value = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "value", Time.defaultValues("value"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "type":
				return 0;
			case "value":
				return new Date(0, 0, 0);
			default:
				throw new Error(`Invalid member name for Time class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * Time ::= CHOICE {
     *   utcTime        UTCTime,
     *   generalTime    GeneralizedTime }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @param {boolean} optional Flag that current schema should be optional
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {}, optional = false)
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [utcTimeName] Name for "utcTimeName" choice
		 * @property {string} [generalTimeName] Name for "generalTimeName" choice
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Choice"]({
			optional,
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["UTCTime"]({ name: (names.utcTimeName || "") }),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ name: (names.generalTimeName || "") })
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"utcTimeName",
			"generalTimeName"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema, schema, Time.schema({
			names: {
				utcTimeName: "utcTimeName",
				generalTimeName: "generalTimeName"
			}
		}));

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for Time");
		//endregion

		//region Get internal properties from parsed schema
		if("utcTimeName" in asn1.result)
		{
			this.type = 0;
			this.value = asn1.result.utcTimeName.toDate();
		}
		if("generalTimeName" in asn1.result)
		{
			this.type = 1;
			this.value = asn1.result.generalTimeName.toDate();
		}
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Construct and return new ASN.1 schema for this object
		let result = {};

		if(this.type === 0)
			result = new asn1js__WEBPACK_IMPORTED_MODULE_0__["UTCTime"]({ valueDate: this.value });
		if(this.type === 1)
			result = new asn1js__WEBPACK_IMPORTED_MODULE_0__["GeneralizedTime"]({ valueDate: this.value });

		return result;
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		return {
			type: this.type,
			value: this.value
		};
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/TimeStampReq.js":
/*!************************************************!*\
  !*** ./node_modules/pkijs/src/TimeStampReq.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TimeStampReq; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _MessageImprint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MessageImprint.js */ "./node_modules/pkijs/src/MessageImprint.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/pkijs/src/Extension.js");




//**************************************************************************************
/**
 * Class from RFC3161
 */
class TimeStampReq
{
	//**********************************************************************************
	/**
	 * Constructor for TimeStampReq class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {number}
		 * @desc version
		 */
		this.version = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "version", TimeStampReq.defaultValues("version"));
		/**
		 * @type {MessageImprint}
		 * @desc messageImprint
		 */
		this.messageImprint = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "messageImprint", TimeStampReq.defaultValues("messageImprint"));

		if("reqPolicy" in parameters)
			/**
			 * @type {string}
			 * @desc reqPolicy
			 */
			this.reqPolicy = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "reqPolicy", TimeStampReq.defaultValues("reqPolicy"));

		if("nonce" in parameters)
			/**
			 * @type {Integer}
			 * @desc nonce
			 */
			this.nonce = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "nonce", TimeStampReq.defaultValues("nonce"));

		if("certReq" in parameters)
			/**
			 * @type {boolean}
			 * @desc certReq
			 */
			this.certReq = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "certReq", TimeStampReq.defaultValues("certReq"));

		if("extensions" in parameters)
			/**
			 * @type {Array.<Extension>}
			 * @desc extensions
			 */
			this.extensions = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "extensions", TimeStampReq.defaultValues("extensions"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "version":
				return 0;
			case "messageImprint":
				return new _MessageImprint_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "reqPolicy":
				return "";
			case "nonce":
				return new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]();
			case "certReq":
				return false;
			case "extensions":
				return [];
			default:
				throw new Error(`Invalid member name for TimeStampReq class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "version":
			case "reqPolicy":
			case "certReq":
				return (memberValue === TimeStampReq.defaultValues(memberName));
			case "messageImprint":
				return ((_MessageImprint_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("hashAlgorithm", memberValue.hashAlgorithm)) &&
						(_MessageImprint_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("hashedMessage", memberValue.hashedMessage)));
			case "nonce":
				return (memberValue.isEqual(TimeStampReq.defaultValues(memberName)));
			case "extensions":
				return (memberValue.length === 0);
			default:
				throw new Error(`Invalid member name for TimeStampReq class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * TimeStampReq ::= SEQUENCE  {
	 *    version               INTEGER  { v1(1) },
	 *    messageImprint        MessageImprint,
	 *    reqPolicy             TSAPolicyId              OPTIONAL,
	 *    nonce                 INTEGER                  OPTIONAL,
	 *    certReq               BOOLEAN                  DEFAULT FALSE,
	 *    extensions            [0] IMPLICIT Extensions  OPTIONAL  }
	 *
	 * TSAPolicyId ::= OBJECT IDENTIFIER
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [type]
		 * @property {string} [setName]
		 * @property {string} [values]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});
		
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "TimeStampReq"),
			value: [
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ name: (names.version || "TimeStampReq.version") }),
				_MessageImprint_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.messageImprint || {
					names: {
						blockName: "TimeStampReq.messageImprint"
					}
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({
					name: (names.reqPolicy || "TimeStampReq.reqPolicy"),
					optional: true
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({
					name: (names.nonce || "TimeStampReq.nonce"),
					optional: true
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Boolean"]({
					name: (names.certReq || "TimeStampReq.certReq"),
					optional: true
				}),
				new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
					optional: true,
					idBlock: {
						tagClass: 3, // CONTEXT-SPECIFIC
						tagNumber: 0 // [0]
					},
					value: [new asn1js__WEBPACK_IMPORTED_MODULE_0__["Repeated"]({
						name: (names.extensions || "TimeStampReq.extensions"),
						value: _Extension_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema()
					})]
				}) // IMPLICIT SEQUENCE value
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"TimeStampReq.version",
			"TimeStampReq.messageImprint",
			"TimeStampReq.reqPolicy",
			"TimeStampReq.nonce",
			"TimeStampReq.certReq",
			"TimeStampReq.extensions"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			TimeStampReq.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for TimeStampReq");
		//endregion

		//region Get internal properties from parsed schema
		this.version = asn1.result["TimeStampReq.version"].valueBlock.valueDec;
		this.messageImprint = new _MessageImprint_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result["TimeStampReq.messageImprint"] });
		if("TimeStampReq.reqPolicy" in asn1.result)
			this.reqPolicy = asn1.result["TimeStampReq.reqPolicy"].valueBlock.toString();
		if("TimeStampReq.nonce" in asn1.result)
			this.nonce = asn1.result["TimeStampReq.nonce"];
		if("TimeStampReq.certReq" in asn1.result)
			this.certReq = asn1.result["TimeStampReq.certReq"].valueBlock.value;
		if("TimeStampReq.extensions" in asn1.result)
			this.extensions = Array.from(asn1.result["TimeStampReq.extensions"], element => new _Extension_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: element }));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ value: this.version }));
		outputArray.push(this.messageImprint.toSchema());
		if("reqPolicy" in this)
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["ObjectIdentifier"]({ value: this.reqPolicy }));
		if("nonce" in this)
			outputArray.push(this.nonce);
		if(("certReq" in this) && (TimeStampReq.compareWithDefault("certReq", this.certReq) === false))
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Boolean"]({ value: this.certReq }));

		//region Create array of extensions
		if("extensions" in this)
		{
			outputArray.push(new asn1js__WEBPACK_IMPORTED_MODULE_0__["Constructed"]({
				idBlock: {
					tagClass: 3, // CONTEXT-SPECIFIC
					tagNumber: 0 // [0]
				},
				value: Array.from(this.extensions, element => element.toSchema())
			}));
		}
		//endregion
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			version: this.version,
			messageImprint: this.messageImprint.toJSON()
		};

		if("reqPolicy" in this)
			_object.reqPolicy = this.reqPolicy;

		if("nonce" in this)
			_object.nonce = this.nonce.toJSON();

		if(("certReq" in this) && (TimeStampReq.compareWithDefault("certReq", this.certReq) === false))
			_object.certReq = this.certReq;

		if("extensions" in this)
			_object.extensions = Array.from(this.extensions, element => element.toJSON());

		return _object;
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/TimeStampResp.js":
/*!*************************************************!*\
  !*** ./node_modules/pkijs/src/TimeStampResp.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TimeStampResp; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _PKIStatusInfo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PKIStatusInfo.js */ "./node_modules/pkijs/src/PKIStatusInfo.js");
/* harmony import */ var _ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ContentInfo.js */ "./node_modules/pkijs/src/ContentInfo.js");
/* harmony import */ var _SignedData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SignedData.js */ "./node_modules/pkijs/src/SignedData.js");





//**************************************************************************************
/**
 * Class from RFC3161
 */
class TimeStampResp
{
	//**********************************************************************************
	/**
	 * Constructor for TimeStampResp class
	 * @param {Object} [parameters={}]
	 * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from
	 */
	constructor(parameters = {})
	{
		//region Internal properties of the object
		/**
		 * @type {PKIStatusInfo}
		 * @desc status
		 */
		this.status = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "status", TimeStampResp.defaultValues("status"));

		if("timeStampToken" in parameters)
			/**
			 * @type {ContentInfo}
			 * @desc timeStampToken
			 */
			this.timeStampToken = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "timeStampToken", TimeStampResp.defaultValues("timeStampToken"));
		//endregion

		//region If input argument array contains "schema" for this object
		if("schema" in parameters)
			this.fromSchema(parameters.schema);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Return default values for all class members
	 * @param {string} memberName String name for a class member
	 */
	static defaultValues(memberName)
	{
		switch(memberName)
		{
			case "status":
				return new _PKIStatusInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
			case "timeStampToken":
				return new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
			default:
				throw new Error(`Invalid member name for TimeStampResp class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Compare values with default values for all class members
	 * @param {string} memberName String name for a class member
	 * @param {*} memberValue Value to compare with default value
	 */
	static compareWithDefault(memberName, memberValue)
	{
		switch(memberName)
		{
			case "status":
				return ((_PKIStatusInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"].compareWithDefault("status", memberValue.status)) &&
						(("statusStrings" in memberValue) === false) &&
						(("failInfo" in memberValue) === false));
			case "timeStampToken":
				return ((memberValue.contentType === "") &&
						(memberValue.content instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Any"]));
			default:
				throw new Error(`Invalid member name for TimeStampResp class: ${memberName}`);
		}
	}
	//**********************************************************************************
	/**
	 * Return value of pre-defined ASN.1 schema for current class
	 *
	 * ASN.1 schema:
	 * ```asn1
	 * TimeStampResp ::= SEQUENCE  {
	 *    status                  PKIStatusInfo,
	 *    timeStampToken          TimeStampToken     OPTIONAL  }
	 * ```
	 *
	 * @param {Object} parameters Input parameters for the schema
	 * @returns {Object} asn1js schema object
	 */
	static schema(parameters = {})
	{
		/**
		 * @type {Object}
		 * @property {string} [blockName]
		 * @property {string} [status]
		 * @property {string} [timeStampToken]
		 */
		const names = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["getParametersValue"])(parameters, "names", {});

		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			name: (names.blockName || "TimeStampResp"),
			value: [
				_PKIStatusInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"].schema(names.status || {
					names: {
						blockName: "TimeStampResp.status"
					}
				}),
				_ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"].schema(names.timeStampToken || {
					names: {
						blockName: "TimeStampResp.timeStampToken",
						optional: true
					}
				})
			]
		}));
	}
	//**********************************************************************************
	/**
	 * Convert parsed asn1js object into current class
	 * @param {!Object} schema
	 */
	fromSchema(schema)
	{
		//region Clear input data first
		Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["clearProps"])(schema, [
			"TimeStampResp.status",
			"TimeStampResp.timeStampToken"
		]);
		//endregion
		
		//region Check the schema is valid
		const asn1 = asn1js__WEBPACK_IMPORTED_MODULE_0__["compareSchema"](schema,
			schema,
			TimeStampResp.schema()
		);

		if(asn1.verified === false)
			throw new Error("Object's schema was not verified against input data for TimeStampResp");
		//endregion

		//region Get internal properties from parsed schema
		this.status = new _PKIStatusInfo_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ schema: asn1.result["TimeStampResp.status"] });
		if("TimeStampResp.timeStampToken" in asn1.result)
			this.timeStampToken = new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: asn1.result["TimeStampResp.timeStampToken"] });
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convert current object to asn1js object and set correct values
	 * @returns {Object} asn1js object
	 */
	toSchema()
	{
		//region Create array for output sequence
		const outputArray = [];

		outputArray.push(this.status.toSchema());
		if("timeStampToken" in this)
			outputArray.push(this.timeStampToken.toSchema());
		//endregion

		//region Construct and return new ASN.1 schema for this object
		return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
			value: outputArray
		}));
		//endregion
	}
	//**********************************************************************************
	/**
	 * Convertion for the class to JSON object
	 * @returns {Object}
	 */
	toJSON()
	{
		const _object = {
			status: this.status
		};

		if("timeStampToken" in this)
			_object.timeStampToken = this.timeStampToken.toJSON();

		return _object;
	}
	//**********************************************************************************
	/**
	 * Sign current TSP Response
	 * @param {Object} privateKey Private key for "subjectPublicKeyInfo" structure
	 * @param {string} [hashAlgorithm] Hashing algorithm. Default SHA-1
	 * @returns {Promise}
	 */
	sign(privateKey, hashAlgorithm)
	{
		//region Check that "timeStampToken" exists
		if(("timeStampToken" in this) === false)
			return Promise.reject("timeStampToken is absent in TSP response");
		//endregion

		//region Check that "timeStampToken" has a right internal format
		if(this.timeStampToken.contentType !== "1.2.840.113549.1.7.2") // Must be a CMS signed data
			return Promise.reject(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`);
		//endregion

		//region Sign internal signed data value
		const signed = new _ContentInfo_js__WEBPACK_IMPORTED_MODULE_3__["default"]({ schema: this.timeStampToken.content });

		return signed.sign(privateKey, 0, hashAlgorithm);
		//endregion
	}
	//**********************************************************************************
	/**
	 * Verify current TSP Response
	 * @param {Object} verificationParameters Input parameters for verification
	 * @returns {Promise}
	 */
	verify(verificationParameters = { signer: 0, trustedCerts: [], data: new ArrayBuffer(0) })
	{
		//region Check that "timeStampToken" exists
		if(("timeStampToken" in this) === false)
			return Promise.reject("timeStampToken is absent in TSP response");
		//endregion

		//region Check that "timeStampToken" has a right internal format
		if(this.timeStampToken.contentType !== "1.2.840.113549.1.7.2") // Must be a CMS signed data
			return Promise.reject(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`);
		//endregion

		//region Verify internal signed data value
		const signed = new _SignedData_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ schema: this.timeStampToken.content });

		return signed.verify(verificationParameters);
		//endregion
	}
	//**********************************************************************************
}
//**************************************************************************************


/***/ }),

/***/ "./node_modules/pkijs/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/pkijs/src/common.js ***!
  \******************************************/
/*! exports provided: setEngine, getEngine, getCrypto, getRandomValues, getOIDByAlgorithm, getAlgorithmParameters, createCMSECDSASignature, stringPrep, createECDSASignatureFromCMS, getAlgorithmByOID, getHashAlgorithm, kdfWithCounter, kdf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setEngine", function() { return setEngine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEngine", function() { return getEngine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCrypto", function() { return getCrypto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomValues", function() { return getRandomValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOIDByAlgorithm", function() { return getOIDByAlgorithm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAlgorithmParameters", function() { return getAlgorithmParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCMSECDSASignature", function() { return createCMSECDSASignature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringPrep", function() { return stringPrep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createECDSASignatureFromCMS", function() { return createECDSASignatureFromCMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAlgorithmByOID", function() { return getAlgorithmByOID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHashAlgorithm", function() { return getHashAlgorithm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kdfWithCounter", function() { return kdfWithCounter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kdf", function() { return kdf; });
/* harmony import */ var asn1js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");
/* harmony import */ var pvutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");
/* harmony import */ var _CryptoEngine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CryptoEngine.js */ "./node_modules/pkijs/src/CryptoEngine.js");



//**************************************************************************************
//region Crypto engine related function
//**************************************************************************************
let engine = {
	name: "none",
	crypto: null,
	subtle: null
};
//**************************************************************************************
function setEngine(name, crypto, subtle)
{
	//region We are in Node
	// noinspection JSUnresolvedVariable
	if((typeof process !== "undefined") && ("pid" in process) && (typeof global !== "undefined") && (typeof window === "undefined"))
	{
		// noinspection ES6ModulesDependencies, JSUnresolvedVariable
		if(typeof global[process.pid] === "undefined")
		{
			// noinspection JSUnresolvedVariable
			global[process.pid] = {};
		}
		else
		{
			// noinspection JSUnresolvedVariable
			if(typeof global[process.pid] !== "object")
			{
				// noinspection JSUnresolvedVariable
				throw new Error(`Name global.${process.pid} already exists and it is not an object`);
			}
		}
		
		// noinspection JSUnresolvedVariable
		if(typeof global[process.pid].pkijs === "undefined")
		{
			// noinspection JSUnresolvedVariable
			global[process.pid].pkijs = {};
		}
		else
		{
			// noinspection JSUnresolvedVariable
			if(typeof global[process.pid].pkijs !== "object")
			{
				// noinspection JSUnresolvedVariable
				throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);
			}
		}
		
		// noinspection JSUnresolvedVariable
		global[process.pid].pkijs.engine = {
			name: name,
			crypto: crypto,
			subtle: subtle
		};
	}
	//endregion
	//region We are in browser
	else
	{
		if(engine.name !== name)
		{
			engine = {
				name: name,
				crypto: crypto,
				subtle: subtle
			};
		}
	}
	//endregion
}
//**************************************************************************************
function getEngine()
{
	//region We are in Node
	// noinspection JSUnresolvedVariable
	if((typeof process !== "undefined") && ("pid" in process) && (typeof global !== "undefined") && (typeof window === "undefined"))
	{
		let _engine;
		
		try
		{
			// noinspection JSUnresolvedVariable
			_engine = global[process.pid].pkijs.engine;
		}
		catch(ex)
		{
			throw new Error("Please call \"setEngine\" before call to \"getEngine\"");
		}
		
		return _engine;
	}
	//endregion
	
	return engine;
}
//**************************************************************************************
(function initCryptoEngine()
{
	if(typeof self !== "undefined")
	{
		if("crypto" in self)
		{
			let engineName = "webcrypto";
			
			/**
			 * Standard crypto object
			 * @type {Object}
			 * @property {Object} [webkitSubtle] Subtle object from Apple
			 */
			const cryptoObject = self.crypto;
			let subtleObject;
			
			// Apple Safari support
			if("webkitSubtle" in self.crypto)
			{
				try
				{
					subtleObject = self.crypto.webkitSubtle;
				}
				catch(ex)
				{
					subtleObject = self.crypto.subtle;
				}
				
				engineName = "safari";
			}
			
			if("subtle" in self.crypto)
				subtleObject = self.crypto.subtle;


			if(typeof subtleObject === "undefined")
			{
				engine = {
					name: engineName,
					crypto: cryptoObject,
					subtle: null
				};
			}
			else
			{
				engine = {
					name: engineName,
					crypto: cryptoObject,
					subtle: new _CryptoEngine_js__WEBPACK_IMPORTED_MODULE_2__["default"]({name: engineName, crypto: self.crypto, subtle: subtleObject})
				};
			}
		}
	}
	
	setEngine(engine.name, engine.crypto, engine.subtle);
})();
//**************************************************************************************
//endregion
//**************************************************************************************
//region Declaration of common functions
//**************************************************************************************
/**
 * Get crypto subtle from current "crypto engine" or "undefined"
 * @returns {({decrypt, deriveKey, digest, encrypt, exportKey, generateKey, importKey, sign, unwrapKey, verify, wrapKey}|null)}
 */
function getCrypto()
{
	const _engine = getEngine();
	
	if(_engine.subtle !== null)
		return _engine.subtle;
	
	return undefined;
}
//**************************************************************************************
/**
 * Initialize input Uint8Array by random values (with help from current "crypto engine")
 * @param {!Uint8Array} view
 * @returns {*}
 */
function getRandomValues(view)
{
	return getEngine().subtle.getRandomValues(view);
}
//**************************************************************************************
/**
 * Get OID for each specific algorithm
 * @param {Object} algorithm
 * @returns {string}
 */
function getOIDByAlgorithm(algorithm)
{
	return getEngine().subtle.getOIDByAlgorithm(algorithm);
}
//**************************************************************************************
/**
 * Get default algorithm parameters for each kind of operation
 * @param {string} algorithmName Algorithm name to get common parameters for
 * @param {string} operation Kind of operation: "sign", "encrypt", "generatekey", "importkey", "exportkey", "verify"
 * @returns {*}
 */
function getAlgorithmParameters(algorithmName, operation)
{
	return getEngine().subtle.getAlgorithmParameters(algorithmName, operation);
}
//**************************************************************************************
/**
 * Create CMS ECDSA signature from WebCrypto ECDSA signature
 * @param {ArrayBuffer} signatureBuffer WebCrypto result of "sign" function
 * @returns {ArrayBuffer}
 */
function createCMSECDSASignature(signatureBuffer)
{
	//region Initial check for correct length
	if((signatureBuffer.byteLength % 2) !== 0)
		return new ArrayBuffer(0);
	//endregion
	
	//region Initial variables
	const length = signatureBuffer.byteLength / 2; // There are two equal parts inside incoming ArrayBuffer
	
	const rBuffer = new ArrayBuffer(length);
	const rView = new Uint8Array(rBuffer);
	rView.set(new Uint8Array(signatureBuffer, 0, length));
	
	const rInteger = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: rBuffer });
	
	const sBuffer = new ArrayBuffer(length);
	const sView = new Uint8Array(sBuffer);
	sView.set(new Uint8Array(signatureBuffer, length, length));
	
	const sInteger = new asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]({ valueHex: sBuffer });
	//endregion
	
	return (new asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]({
		value: [
			rInteger.convertToDER(),
			sInteger.convertToDER()
		]
	})).toBER(false);
}
//**************************************************************************************
/**
 * String preparation function. In a future here will be realization of algorithm from RFC4518
 * @param {string} inputString JavaScript string. As soon as for each ASN.1 string type we have a specific transformation function here we will work with pure JavaScript string
 * @returns {string} Formated string
 */
function stringPrep(inputString)
{
	//region Initial variables
	let isSpace = false;
	let cuttedResult = "";
	//endregion
	
	const result = inputString.trim(); // Trim input string
	
	//region Change all sequence of SPACE down to SPACE char
	for(let i = 0; i < result.length; i++)
	{
		if(result.charCodeAt(i) === 32)
		{
			if(isSpace === false)
				isSpace = true;
		}
		else
		{
			if(isSpace)
			{
				cuttedResult += " ";
				isSpace = false;
			}
			
			cuttedResult += result[i];
		}
	}
	//endregion
	
	return cuttedResult.toLowerCase();
}
//**************************************************************************************
/**
 * Create a single ArrayBuffer from CMS ECDSA signature
 * @param {Sequence} cmsSignature ASN.1 SEQUENCE contains CMS ECDSA signature
 * @returns {ArrayBuffer}
 */
function createECDSASignatureFromCMS(cmsSignature)
{
	//region Check input variables
	if((cmsSignature instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Sequence"]) === false)
		return new ArrayBuffer(0);
	
	if(cmsSignature.valueBlock.value.length !== 2)
		return new ArrayBuffer(0);
	
	if((cmsSignature.valueBlock.value[0] instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]) === false)
		return new ArrayBuffer(0);
	
	if((cmsSignature.valueBlock.value[1] instanceof asn1js__WEBPACK_IMPORTED_MODULE_0__["Integer"]) === false)
		return new ArrayBuffer(0);
	//endregion
	
	const rValue = cmsSignature.valueBlock.value[0].convertFromDER();
	const sValue = cmsSignature.valueBlock.value[1].convertFromDER();
	
	//region Check the lengths of two parts are equal
	switch(true)
	{
		case (rValue.valueBlock.valueHex.byteLength < sValue.valueBlock.valueHex.byteLength):
			{
				if((sValue.valueBlock.valueHex.byteLength - rValue.valueBlock.valueHex.byteLength) !== 1)
					throw new Error("Incorrect DER integer decoding");
				
				const correctedLength = sValue.valueBlock.valueHex.byteLength;
				
				const rValueView = new Uint8Array(rValue.valueBlock.valueHex);
				
				const rValueBufferCorrected = new ArrayBuffer(correctedLength);
				const rValueViewCorrected = new Uint8Array(rValueBufferCorrected);
				
				rValueViewCorrected.set(rValueView, 1);
				rValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here
				
				return Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(rValueBufferCorrected, sValue.valueBlock.valueHex);
			}
		case (rValue.valueBlock.valueHex.byteLength > sValue.valueBlock.valueHex.byteLength):
			{
				if((rValue.valueBlock.valueHex.byteLength - sValue.valueBlock.valueHex.byteLength) !== 1)
					throw new Error("Incorrect DER integer decoding");
				
				const correctedLength = rValue.valueBlock.valueHex.byteLength;
				
				const sValueView = new Uint8Array(sValue.valueBlock.valueHex);
				
				const sValueBufferCorrected = new ArrayBuffer(correctedLength);
				const sValueViewCorrected = new Uint8Array(sValueBufferCorrected);
				
				sValueViewCorrected.set(sValueView, 1);
				sValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here
				
				return Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(rValue.valueBlock.valueHex, sValueBufferCorrected);
			}
		default:
			{
				//region In case we have equal length and the length is not even with 2
				if(rValue.valueBlock.valueHex.byteLength % 2)
				{
					const correctedLength = (rValue.valueBlock.valueHex.byteLength + 1);
					
					const rValueView = new Uint8Array(rValue.valueBlock.valueHex);
					
					const rValueBufferCorrected = new ArrayBuffer(correctedLength);
					const rValueViewCorrected = new Uint8Array(rValueBufferCorrected);
					
					rValueViewCorrected.set(rValueView, 1);
					rValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here
					
					const sValueView = new Uint8Array(sValue.valueBlock.valueHex);
					
					const sValueBufferCorrected = new ArrayBuffer(correctedLength);
					const sValueViewCorrected = new Uint8Array(sValueBufferCorrected);
					
					sValueViewCorrected.set(sValueView, 1);
					sValueViewCorrected[0] = 0x00; // In order to be sure we do not have any garbage here
					
					return Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(rValueBufferCorrected, sValueBufferCorrected);
				}
				//endregion
			}
	}
	//endregion
	
	return Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(rValue.valueBlock.valueHex, sValue.valueBlock.valueHex);
}
//**************************************************************************************
/**
 * Get WebCrypto algorithm by wel-known OID
 * @param {string} oid well-known OID to search for
 * @returns {Object}
 */
function getAlgorithmByOID(oid)
{
	return getEngine().subtle.getAlgorithmByOID(oid);
}
//**************************************************************************************
/**
 * Getting hash algorithm by signature algorithm
 * @param {AlgorithmIdentifier} signatureAlgorithm Signature algorithm
 * @returns {string}
 */
function getHashAlgorithm(signatureAlgorithm)
{
	return getEngine().subtle.getHashAlgorithm(signatureAlgorithm);
}
//**************************************************************************************
/**
 * ANS X9.63 Key Derivation Function having a "Counter" as a parameter
 * @param {string} hashFunction Used hash function
 * @param {ArrayBuffer} Zbuffer ArrayBuffer containing ECDH shared secret to derive from
 * @param {number} Counter
 * @param {ArrayBuffer} SharedInfo Usually DER encoded "ECC_CMS_SharedInfo" structure
 */
function kdfWithCounter(hashFunction, Zbuffer, Counter, SharedInfo)
{
	//region Check of input parameters
	switch(hashFunction.toUpperCase())
	{
		case "SHA-1":
		case "SHA-256":
		case "SHA-384":
		case "SHA-512":
			break;
		default:
			return Promise.reject(`Unknown hash function: ${hashFunction}`);
	}
	
	if((Zbuffer instanceof ArrayBuffer) === false)
		return Promise.reject("Please set \"Zbuffer\" as \"ArrayBuffer\"");
	
	if(Zbuffer.byteLength === 0)
		return Promise.reject("\"Zbuffer\" has zero length, error");
	
	if((SharedInfo instanceof ArrayBuffer) === false)
		return Promise.reject("Please set \"SharedInfo\" as \"ArrayBuffer\"");
	
	if(Counter > 255)
		return Promise.reject("Please set \"Counter\" variable to value less or equal to 255");
	//endregion
	
	//region Initial variables
	const counterBuffer = new ArrayBuffer(4);
	const counterView = new Uint8Array(counterBuffer);
	counterView[0] = 0x00;
	counterView[1] = 0x00;
	counterView[2] = 0x00;
	counterView[3] = Counter;
	
	let combinedBuffer = new ArrayBuffer(0);
	//endregion
	
	//region Get a "crypto" extension
	const crypto = getCrypto();
	if(typeof crypto === "undefined")
		return Promise.reject("Unable to create WebCrypto object");
	//endregion
	
	//region Create a combined ArrayBuffer for digesting
	combinedBuffer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(combinedBuffer, Zbuffer);
	combinedBuffer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(combinedBuffer, counterBuffer);
	combinedBuffer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(combinedBuffer, SharedInfo);
	//endregion
	
	//region Return digest of combined ArrayBuffer and information about current counter
	return crypto.digest({
		name: hashFunction
	},
	combinedBuffer)
		.then(result =>
			({
				counter: Counter,
				result
			}));
	//endregion
}
//**************************************************************************************
/**
 * ANS X9.63 Key Derivation Function
 * @param {string} hashFunction Used hash function
 * @param {ArrayBuffer} Zbuffer ArrayBuffer containing ECDH shared secret to derive from
 * @param {number} keydatalen Length (!!! in BITS !!!) of used kew derivation function
 * @param {ArrayBuffer} SharedInfo Usually DER encoded "ECC_CMS_SharedInfo" structure
 */
function kdf(hashFunction, Zbuffer, keydatalen, SharedInfo)
{
	//region Initial variables
	let hashLength = 0;
	let maxCounter = 1;
	
	const kdfArray = [];
	//endregion
	
	//region Check of input parameters
	switch(hashFunction.toUpperCase())
	{
		case "SHA-1":
			hashLength = 160; // In bits
			break;
		case "SHA-256":
			hashLength = 256; // In bits
			break;
		case "SHA-384":
			hashLength = 384; // In bits
			break;
		case "SHA-512":
			hashLength = 512; // In bits
			break;
		default:
			return Promise.reject(`Unknown hash function: ${hashFunction}`);
	}
	
	if((Zbuffer instanceof ArrayBuffer) === false)
		return Promise.reject("Please set \"Zbuffer\" as \"ArrayBuffer\"");
	
	if(Zbuffer.byteLength === 0)
		return Promise.reject("\"Zbuffer\" has zero length, error");
	
	if((SharedInfo instanceof ArrayBuffer) === false)
		return Promise.reject("Please set \"SharedInfo\" as \"ArrayBuffer\"");
	//endregion
	
	//region Calculated maximum value of "Counter" variable
	const quotient = keydatalen / hashLength;
	
	if(Math.floor(quotient) > 0)
	{
		maxCounter = Math.floor(quotient);
		
		if((quotient - maxCounter) > 0)
			maxCounter++;
	}
	//endregion
	
	//region Create an array of "kdfWithCounter"
	for(let i = 1; i <= maxCounter; i++)
		kdfArray.push(kdfWithCounter(hashFunction, Zbuffer, i, SharedInfo));
	//endregion
	
	//region Return combined digest with specified length
	return Promise.all(kdfArray).then(incomingResult =>
	{
		//region Initial variables
		let combinedBuffer = new ArrayBuffer(0);
		let currentCounter = 1;
		let found = true;
		//endregion
		
		//region Combine all buffer together
		while(found)
		{
			found = false;
			
			for(const result of incomingResult)
			{
				if(result.counter === currentCounter)
				{
					combinedBuffer = Object(pvutils__WEBPACK_IMPORTED_MODULE_1__["utilConcatBuf"])(combinedBuffer, result.result);
					found = true;
					break;
				}
			}
			
			currentCounter++;
		}
		//endregion
		
		//region Create output buffer with specified length
		keydatalen >>= 3; // Divide by 8 since "keydatalen" is in bits
		
		if(combinedBuffer.byteLength > keydatalen)
		{
			const newBuffer = new ArrayBuffer(keydatalen);
			const newView = new Uint8Array(newBuffer);
			const combinedView = new Uint8Array(combinedBuffer);
			
			for(let i = 0; i < keydatalen; i++)
				newView[i] = combinedView[i];
			
			return newBuffer;
		}
		
		return combinedBuffer; // Since the situation when "combinedBuffer.byteLength < keydatalen" here we have only "combinedBuffer.byteLength === keydatalen"
		//endregion
	});
	//endregion
}
//**************************************************************************************
//endregion
//**************************************************************************************

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/pkijs/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/pkijs/src/index.js ***!
  \*****************************************/
/*! exports provided: setEngine, getEngine, getCrypto, getRandomValues, getOIDByAlgorithm, getAlgorithmParameters, createCMSECDSASignature, stringPrep, createECDSASignatureFromCMS, getAlgorithmByOID, getHashAlgorithm, kdfWithCounter, kdf, AccessDescription, Accuracy, AlgorithmIdentifier, AltName, Attribute, AttributeTypeAndValue, AuthenticatedSafe, AuthorityKeyIdentifier, BasicConstraints, BasicOCSPResponse, CRLBag, CRLDistributionPoints, CertBag, CertID, Certificate, CertificateChainValidationEngine, CertificatePolicies, CertificateRevocationList, CertificateSet, CertificationRequest, ContentInfo, CryptoEngine, DigestInfo, DistributionPoint, ECCCMSSharedInfo, ECPrivateKey, ECPublicKey, EncapsulatedContentInfo, EncryptedContentInfo, EncryptedData, EnvelopedData, ExtKeyUsage, Extension, Extensions, GeneralName, GeneralNames, GeneralSubtree, InfoAccess, IssuerAndSerialNumber, IssuingDistributionPoint, KEKIdentifier, KEKRecipientInfo, KeyAgreeRecipientIdentifier, KeyAgreeRecipientInfo, KeyBag, KeyTransRecipientInfo, MacData, MessageImprint, NameConstraints, OCSPRequest, OCSPResponse, OriginatorIdentifierOrKey, OriginatorInfo, OriginatorPublicKey, OtherCertificateFormat, OtherKeyAttribute, OtherPrimeInfo, OtherRecipientInfo, OtherRevocationInfoFormat, PBES2Params, PBKDF2Params, PFX, PKCS8ShroudedKeyBag, PKIStatusInfo, PasswordRecipientinfo, PolicyConstraints, PolicyInformation, PolicyMapping, PolicyMappings, PolicyQualifierInfo, PrivateKeyInfo, PrivateKeyUsagePeriod, PublicKeyInfo, RSAESOAEPParams, RSAPrivateKey, RSAPublicKey, RSASSAPSSParams, RecipientEncryptedKey, RecipientEncryptedKeys, RecipientIdentifier, RecipientInfo, RecipientKeyIdentifier, RelativeDistinguishedNames, Request, ResponseBytes, ResponseData, RevocationInfoChoices, RevokedCertificate, SafeBag, SafeContents, SecretBag, Signature, SignedAndUnsignedAttributes, SignedData, SignerInfo, SingleResponse, SubjectDirectoryAttributes, TBSRequest, TSTInfo, Time, TimeStampReq, TimeStampResp, SignedCertificateTimestampList, SignedCertificateTimestamp, verifySCTsForCertificate, CertificateTemplate, CAVersion, QCStatement, QCStatements, ECNamedCurves */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/pkijs/src/common.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setEngine", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["setEngine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getEngine", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["getEngine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCrypto", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["getCrypto"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getRandomValues", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["getRandomValues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOIDByAlgorithm", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["getOIDByAlgorithm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAlgorithmParameters", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["getAlgorithmParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCMSECDSASignature", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["createCMSECDSASignature"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stringPrep", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["stringPrep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createECDSASignatureFromCMS", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["createECDSASignatureFromCMS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAlgorithmByOID", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["getAlgorithmByOID"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHashAlgorithm", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["getHashAlgorithm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "kdfWithCounter", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["kdfWithCounter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "kdf", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__["kdf"]; });

/* harmony import */ var _AccessDescription_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AccessDescription.js */ "./node_modules/pkijs/src/AccessDescription.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AccessDescription", function() { return _AccessDescription_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _Accuracy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Accuracy.js */ "./node_modules/pkijs/src/Accuracy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Accuracy", function() { return _Accuracy_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AlgorithmIdentifier.js */ "./node_modules/pkijs/src/AlgorithmIdentifier.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AlgorithmIdentifier", function() { return _AlgorithmIdentifier_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _AltName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AltName.js */ "./node_modules/pkijs/src/AltName.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AltName", function() { return _AltName_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _Attribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Attribute.js */ "./node_modules/pkijs/src/Attribute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Attribute", function() { return _Attribute_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _AttributeTypeAndValue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AttributeTypeAndValue.js */ "./node_modules/pkijs/src/AttributeTypeAndValue.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AttributeTypeAndValue", function() { return _AttributeTypeAndValue_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _AuthenticatedSafe_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AuthenticatedSafe.js */ "./node_modules/pkijs/src/AuthenticatedSafe.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AuthenticatedSafe", function() { return _AuthenticatedSafe_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _AuthorityKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AuthorityKeyIdentifier.js */ "./node_modules/pkijs/src/AuthorityKeyIdentifier.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AuthorityKeyIdentifier", function() { return _AuthorityKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _BasicConstraints_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./BasicConstraints.js */ "./node_modules/pkijs/src/BasicConstraints.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BasicConstraints", function() { return _BasicConstraints_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _BasicOCSPResponse_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./BasicOCSPResponse.js */ "./node_modules/pkijs/src/BasicOCSPResponse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BasicOCSPResponse", function() { return _BasicOCSPResponse_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _CRLBag_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CRLBag.js */ "./node_modules/pkijs/src/CRLBag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CRLBag", function() { return _CRLBag_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _CRLDistributionPoints_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./CRLDistributionPoints.js */ "./node_modules/pkijs/src/CRLDistributionPoints.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CRLDistributionPoints", function() { return _CRLDistributionPoints_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _CertBag_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CertBag.js */ "./node_modules/pkijs/src/CertBag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CertBag", function() { return _CertBag_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _CertID_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./CertID.js */ "./node_modules/pkijs/src/CertID.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CertID", function() { return _CertID_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Certificate.js */ "./node_modules/pkijs/src/Certificate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Certificate", function() { return _Certificate_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _CertificateChainValidationEngine_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./CertificateChainValidationEngine.js */ "./node_modules/pkijs/src/CertificateChainValidationEngine.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CertificateChainValidationEngine", function() { return _CertificateChainValidationEngine_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _CertificatePolicies_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./CertificatePolicies.js */ "./node_modules/pkijs/src/CertificatePolicies.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CertificatePolicies", function() { return _CertificatePolicies_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _CertificateRevocationList_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./CertificateRevocationList.js */ "./node_modules/pkijs/src/CertificateRevocationList.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CertificateRevocationList", function() { return _CertificateRevocationList_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _CertificateSet_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./CertificateSet.js */ "./node_modules/pkijs/src/CertificateSet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CertificateSet", function() { return _CertificateSet_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _CertificationRequest_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./CertificationRequest.js */ "./node_modules/pkijs/src/CertificationRequest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CertificationRequest", function() { return _CertificationRequest_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _ContentInfo_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./ContentInfo.js */ "./node_modules/pkijs/src/ContentInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ContentInfo", function() { return _ContentInfo_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _CryptoEngine_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./CryptoEngine.js */ "./node_modules/pkijs/src/CryptoEngine.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CryptoEngine", function() { return _CryptoEngine_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _DigestInfo_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./DigestInfo.js */ "./node_modules/pkijs/src/DigestInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DigestInfo", function() { return _DigestInfo_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _DistributionPoint_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./DistributionPoint.js */ "./node_modules/pkijs/src/DistributionPoint.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DistributionPoint", function() { return _DistributionPoint_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _ECCCMSSharedInfo_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./ECCCMSSharedInfo.js */ "./node_modules/pkijs/src/ECCCMSSharedInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ECCCMSSharedInfo", function() { return _ECCCMSSharedInfo_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _ECPrivateKey_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./ECPrivateKey.js */ "./node_modules/pkijs/src/ECPrivateKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ECPrivateKey", function() { return _ECPrivateKey_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _ECPublicKey_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./ECPublicKey.js */ "./node_modules/pkijs/src/ECPublicKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ECPublicKey", function() { return _ECPublicKey_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _EncapsulatedContentInfo_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./EncapsulatedContentInfo.js */ "./node_modules/pkijs/src/EncapsulatedContentInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EncapsulatedContentInfo", function() { return _EncapsulatedContentInfo_js__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./EncryptedContentInfo.js */ "./node_modules/pkijs/src/EncryptedContentInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EncryptedContentInfo", function() { return _EncryptedContentInfo_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _EncryptedData_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./EncryptedData.js */ "./node_modules/pkijs/src/EncryptedData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EncryptedData", function() { return _EncryptedData_js__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _EnvelopedData_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./EnvelopedData.js */ "./node_modules/pkijs/src/EnvelopedData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EnvelopedData", function() { return _EnvelopedData_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _ExtKeyUsage_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./ExtKeyUsage.js */ "./node_modules/pkijs/src/ExtKeyUsage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExtKeyUsage", function() { return _ExtKeyUsage_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/pkijs/src/Extension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Extension", function() { return _Extension_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./Extensions.js */ "./node_modules/pkijs/src/Extensions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Extensions", function() { return _Extensions_js__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _GeneralName_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./GeneralName.js */ "./node_modules/pkijs/src/GeneralName.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeneralName", function() { return _GeneralName_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var _GeneralNames_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./GeneralNames.js */ "./node_modules/pkijs/src/GeneralNames.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeneralNames", function() { return _GeneralNames_js__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _GeneralSubtree_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./GeneralSubtree.js */ "./node_modules/pkijs/src/GeneralSubtree.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeneralSubtree", function() { return _GeneralSubtree_js__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _InfoAccess_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./InfoAccess.js */ "./node_modules/pkijs/src/InfoAccess.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InfoAccess", function() { return _InfoAccess_js__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./IssuerAndSerialNumber.js */ "./node_modules/pkijs/src/IssuerAndSerialNumber.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IssuerAndSerialNumber", function() { return _IssuerAndSerialNumber_js__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _IssuingDistributionPoint_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./IssuingDistributionPoint.js */ "./node_modules/pkijs/src/IssuingDistributionPoint.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IssuingDistributionPoint", function() { return _IssuingDistributionPoint_js__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _KEKIdentifier_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./KEKIdentifier.js */ "./node_modules/pkijs/src/KEKIdentifier.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KEKIdentifier", function() { return _KEKIdentifier_js__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _KEKRecipientInfo_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./KEKRecipientInfo.js */ "./node_modules/pkijs/src/KEKRecipientInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KEKRecipientInfo", function() { return _KEKRecipientInfo_js__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _KeyAgreeRecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./KeyAgreeRecipientIdentifier.js */ "./node_modules/pkijs/src/KeyAgreeRecipientIdentifier.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyAgreeRecipientIdentifier", function() { return _KeyAgreeRecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _KeyAgreeRecipientInfo_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./KeyAgreeRecipientInfo.js */ "./node_modules/pkijs/src/KeyAgreeRecipientInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyAgreeRecipientInfo", function() { return _KeyAgreeRecipientInfo_js__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _KeyBag_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./KeyBag.js */ "./node_modules/pkijs/src/KeyBag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyBag", function() { return _KeyBag_js__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _KeyTransRecipientInfo_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./KeyTransRecipientInfo.js */ "./node_modules/pkijs/src/KeyTransRecipientInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyTransRecipientInfo", function() { return _KeyTransRecipientInfo_js__WEBPACK_IMPORTED_MODULE_46__["default"]; });

/* harmony import */ var _MacData_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./MacData.js */ "./node_modules/pkijs/src/MacData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MacData", function() { return _MacData_js__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony import */ var _MessageImprint_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./MessageImprint.js */ "./node_modules/pkijs/src/MessageImprint.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MessageImprint", function() { return _MessageImprint_js__WEBPACK_IMPORTED_MODULE_48__["default"]; });

/* harmony import */ var _NameConstraints_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./NameConstraints.js */ "./node_modules/pkijs/src/NameConstraints.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NameConstraints", function() { return _NameConstraints_js__WEBPACK_IMPORTED_MODULE_49__["default"]; });

/* harmony import */ var _OCSPRequest_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./OCSPRequest.js */ "./node_modules/pkijs/src/OCSPRequest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OCSPRequest", function() { return _OCSPRequest_js__WEBPACK_IMPORTED_MODULE_50__["default"]; });

/* harmony import */ var _OCSPResponse_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./OCSPResponse.js */ "./node_modules/pkijs/src/OCSPResponse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OCSPResponse", function() { return _OCSPResponse_js__WEBPACK_IMPORTED_MODULE_51__["default"]; });

/* harmony import */ var _OriginatorIdentifierOrKey_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./OriginatorIdentifierOrKey.js */ "./node_modules/pkijs/src/OriginatorIdentifierOrKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OriginatorIdentifierOrKey", function() { return _OriginatorIdentifierOrKey_js__WEBPACK_IMPORTED_MODULE_52__["default"]; });

/* harmony import */ var _OriginatorInfo_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./OriginatorInfo.js */ "./node_modules/pkijs/src/OriginatorInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OriginatorInfo", function() { return _OriginatorInfo_js__WEBPACK_IMPORTED_MODULE_53__["default"]; });

/* harmony import */ var _OriginatorPublicKey_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./OriginatorPublicKey.js */ "./node_modules/pkijs/src/OriginatorPublicKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OriginatorPublicKey", function() { return _OriginatorPublicKey_js__WEBPACK_IMPORTED_MODULE_54__["default"]; });

/* harmony import */ var _OtherCertificateFormat_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./OtherCertificateFormat.js */ "./node_modules/pkijs/src/OtherCertificateFormat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OtherCertificateFormat", function() { return _OtherCertificateFormat_js__WEBPACK_IMPORTED_MODULE_55__["default"]; });

/* harmony import */ var _OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./OtherKeyAttribute.js */ "./node_modules/pkijs/src/OtherKeyAttribute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OtherKeyAttribute", function() { return _OtherKeyAttribute_js__WEBPACK_IMPORTED_MODULE_56__["default"]; });

/* harmony import */ var _OtherPrimeInfo_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./OtherPrimeInfo.js */ "./node_modules/pkijs/src/OtherPrimeInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OtherPrimeInfo", function() { return _OtherPrimeInfo_js__WEBPACK_IMPORTED_MODULE_57__["default"]; });

/* harmony import */ var _OtherRecipientInfo_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./OtherRecipientInfo.js */ "./node_modules/pkijs/src/OtherRecipientInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OtherRecipientInfo", function() { return _OtherRecipientInfo_js__WEBPACK_IMPORTED_MODULE_58__["default"]; });

/* harmony import */ var _OtherRevocationInfoFormat_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./OtherRevocationInfoFormat.js */ "./node_modules/pkijs/src/OtherRevocationInfoFormat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OtherRevocationInfoFormat", function() { return _OtherRevocationInfoFormat_js__WEBPACK_IMPORTED_MODULE_59__["default"]; });

/* harmony import */ var _PBES2Params_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./PBES2Params.js */ "./node_modules/pkijs/src/PBES2Params.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PBES2Params", function() { return _PBES2Params_js__WEBPACK_IMPORTED_MODULE_60__["default"]; });

/* harmony import */ var _PBKDF2Params_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./PBKDF2Params.js */ "./node_modules/pkijs/src/PBKDF2Params.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PBKDF2Params", function() { return _PBKDF2Params_js__WEBPACK_IMPORTED_MODULE_61__["default"]; });

/* harmony import */ var _PFX_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./PFX.js */ "./node_modules/pkijs/src/PFX.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PFX", function() { return _PFX_js__WEBPACK_IMPORTED_MODULE_62__["default"]; });

/* harmony import */ var _PKCS8ShroudedKeyBag_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./PKCS8ShroudedKeyBag.js */ "./node_modules/pkijs/src/PKCS8ShroudedKeyBag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PKCS8ShroudedKeyBag", function() { return _PKCS8ShroudedKeyBag_js__WEBPACK_IMPORTED_MODULE_63__["default"]; });

/* harmony import */ var _PKIStatusInfo_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./PKIStatusInfo.js */ "./node_modules/pkijs/src/PKIStatusInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PKIStatusInfo", function() { return _PKIStatusInfo_js__WEBPACK_IMPORTED_MODULE_64__["default"]; });

/* harmony import */ var _PasswordRecipientinfo_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./PasswordRecipientinfo.js */ "./node_modules/pkijs/src/PasswordRecipientinfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PasswordRecipientinfo", function() { return _PasswordRecipientinfo_js__WEBPACK_IMPORTED_MODULE_65__["default"]; });

/* harmony import */ var _PolicyConstraints_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./PolicyConstraints.js */ "./node_modules/pkijs/src/PolicyConstraints.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolicyConstraints", function() { return _PolicyConstraints_js__WEBPACK_IMPORTED_MODULE_66__["default"]; });

/* harmony import */ var _PolicyInformation_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./PolicyInformation.js */ "./node_modules/pkijs/src/PolicyInformation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolicyInformation", function() { return _PolicyInformation_js__WEBPACK_IMPORTED_MODULE_67__["default"]; });

/* harmony import */ var _PolicyMapping_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./PolicyMapping.js */ "./node_modules/pkijs/src/PolicyMapping.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolicyMapping", function() { return _PolicyMapping_js__WEBPACK_IMPORTED_MODULE_68__["default"]; });

/* harmony import */ var _PolicyMappings_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./PolicyMappings.js */ "./node_modules/pkijs/src/PolicyMappings.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolicyMappings", function() { return _PolicyMappings_js__WEBPACK_IMPORTED_MODULE_69__["default"]; });

/* harmony import */ var _PolicyQualifierInfo_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./PolicyQualifierInfo.js */ "./node_modules/pkijs/src/PolicyQualifierInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolicyQualifierInfo", function() { return _PolicyQualifierInfo_js__WEBPACK_IMPORTED_MODULE_70__["default"]; });

/* harmony import */ var _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./PrivateKeyInfo.js */ "./node_modules/pkijs/src/PrivateKeyInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PrivateKeyInfo", function() { return _PrivateKeyInfo_js__WEBPACK_IMPORTED_MODULE_71__["default"]; });

/* harmony import */ var _PrivateKeyUsagePeriod_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./PrivateKeyUsagePeriod.js */ "./node_modules/pkijs/src/PrivateKeyUsagePeriod.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PrivateKeyUsagePeriod", function() { return _PrivateKeyUsagePeriod_js__WEBPACK_IMPORTED_MODULE_72__["default"]; });

/* harmony import */ var _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./PublicKeyInfo.js */ "./node_modules/pkijs/src/PublicKeyInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PublicKeyInfo", function() { return _PublicKeyInfo_js__WEBPACK_IMPORTED_MODULE_73__["default"]; });

/* harmony import */ var _RSAESOAEPParams_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./RSAESOAEPParams.js */ "./node_modules/pkijs/src/RSAESOAEPParams.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RSAESOAEPParams", function() { return _RSAESOAEPParams_js__WEBPACK_IMPORTED_MODULE_74__["default"]; });

/* harmony import */ var _RSAPrivateKey_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./RSAPrivateKey.js */ "./node_modules/pkijs/src/RSAPrivateKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RSAPrivateKey", function() { return _RSAPrivateKey_js__WEBPACK_IMPORTED_MODULE_75__["default"]; });

/* harmony import */ var _RSAPublicKey_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./RSAPublicKey.js */ "./node_modules/pkijs/src/RSAPublicKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RSAPublicKey", function() { return _RSAPublicKey_js__WEBPACK_IMPORTED_MODULE_76__["default"]; });

/* harmony import */ var _RSASSAPSSParams_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./RSASSAPSSParams.js */ "./node_modules/pkijs/src/RSASSAPSSParams.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RSASSAPSSParams", function() { return _RSASSAPSSParams_js__WEBPACK_IMPORTED_MODULE_77__["default"]; });

/* harmony import */ var _RecipientEncryptedKey_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./RecipientEncryptedKey.js */ "./node_modules/pkijs/src/RecipientEncryptedKey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RecipientEncryptedKey", function() { return _RecipientEncryptedKey_js__WEBPACK_IMPORTED_MODULE_78__["default"]; });

/* harmony import */ var _RecipientEncryptedKeys_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./RecipientEncryptedKeys.js */ "./node_modules/pkijs/src/RecipientEncryptedKeys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RecipientEncryptedKeys", function() { return _RecipientEncryptedKeys_js__WEBPACK_IMPORTED_MODULE_79__["default"]; });

/* harmony import */ var _RecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./RecipientIdentifier.js */ "./node_modules/pkijs/src/RecipientIdentifier.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RecipientIdentifier", function() { return _RecipientIdentifier_js__WEBPACK_IMPORTED_MODULE_80__["default"]; });

/* harmony import */ var _RecipientInfo_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./RecipientInfo.js */ "./node_modules/pkijs/src/RecipientInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RecipientInfo", function() { return _RecipientInfo_js__WEBPACK_IMPORTED_MODULE_81__["default"]; });

/* harmony import */ var _RecipientKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./RecipientKeyIdentifier.js */ "./node_modules/pkijs/src/RecipientKeyIdentifier.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RecipientKeyIdentifier", function() { return _RecipientKeyIdentifier_js__WEBPACK_IMPORTED_MODULE_82__["default"]; });

/* harmony import */ var _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./RelativeDistinguishedNames.js */ "./node_modules/pkijs/src/RelativeDistinguishedNames.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RelativeDistinguishedNames", function() { return _RelativeDistinguishedNames_js__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony import */ var _Request_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./Request.js */ "./node_modules/pkijs/src/Request.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return _Request_js__WEBPACK_IMPORTED_MODULE_84__["default"]; });

/* harmony import */ var _ResponseBytes_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./ResponseBytes.js */ "./node_modules/pkijs/src/ResponseBytes.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ResponseBytes", function() { return _ResponseBytes_js__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony import */ var _ResponseData_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./ResponseData.js */ "./node_modules/pkijs/src/ResponseData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ResponseData", function() { return _ResponseData_js__WEBPACK_IMPORTED_MODULE_86__["default"]; });

/* harmony import */ var _RevocationInfoChoices_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./RevocationInfoChoices.js */ "./node_modules/pkijs/src/RevocationInfoChoices.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RevocationInfoChoices", function() { return _RevocationInfoChoices_js__WEBPACK_IMPORTED_MODULE_87__["default"]; });

/* harmony import */ var _RevokedCertificate_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./RevokedCertificate.js */ "./node_modules/pkijs/src/RevokedCertificate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RevokedCertificate", function() { return _RevokedCertificate_js__WEBPACK_IMPORTED_MODULE_88__["default"]; });

/* harmony import */ var _SafeBag_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./SafeBag.js */ "./node_modules/pkijs/src/SafeBag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SafeBag", function() { return _SafeBag_js__WEBPACK_IMPORTED_MODULE_89__["default"]; });

/* harmony import */ var _SafeContents_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./SafeContents.js */ "./node_modules/pkijs/src/SafeContents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SafeContents", function() { return _SafeContents_js__WEBPACK_IMPORTED_MODULE_90__["default"]; });

/* harmony import */ var _SecretBag_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./SecretBag.js */ "./node_modules/pkijs/src/SecretBag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SecretBag", function() { return _SecretBag_js__WEBPACK_IMPORTED_MODULE_91__["default"]; });

/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./Signature.js */ "./node_modules/pkijs/src/Signature.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Signature", function() { return _Signature_js__WEBPACK_IMPORTED_MODULE_92__["default"]; });

/* harmony import */ var _SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./SignedAndUnsignedAttributes.js */ "./node_modules/pkijs/src/SignedAndUnsignedAttributes.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SignedAndUnsignedAttributes", function() { return _SignedAndUnsignedAttributes_js__WEBPACK_IMPORTED_MODULE_93__["default"]; });

/* harmony import */ var _SignedData_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./SignedData.js */ "./node_modules/pkijs/src/SignedData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SignedData", function() { return _SignedData_js__WEBPACK_IMPORTED_MODULE_94__["default"]; });

/* harmony import */ var _SignerInfo_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./SignerInfo.js */ "./node_modules/pkijs/src/SignerInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SignerInfo", function() { return _SignerInfo_js__WEBPACK_IMPORTED_MODULE_95__["default"]; });

/* harmony import */ var _SingleResponse_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./SingleResponse.js */ "./node_modules/pkijs/src/SingleResponse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SingleResponse", function() { return _SingleResponse_js__WEBPACK_IMPORTED_MODULE_96__["default"]; });

/* harmony import */ var _SubjectDirectoryAttributes_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./SubjectDirectoryAttributes.js */ "./node_modules/pkijs/src/SubjectDirectoryAttributes.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SubjectDirectoryAttributes", function() { return _SubjectDirectoryAttributes_js__WEBPACK_IMPORTED_MODULE_97__["default"]; });

/* harmony import */ var _TBSRequest_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./TBSRequest.js */ "./node_modules/pkijs/src/TBSRequest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TBSRequest", function() { return _TBSRequest_js__WEBPACK_IMPORTED_MODULE_98__["default"]; });

/* harmony import */ var _TSTInfo_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./TSTInfo.js */ "./node_modules/pkijs/src/TSTInfo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TSTInfo", function() { return _TSTInfo_js__WEBPACK_IMPORTED_MODULE_99__["default"]; });

/* harmony import */ var _Time_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./Time.js */ "./node_modules/pkijs/src/Time.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Time", function() { return _Time_js__WEBPACK_IMPORTED_MODULE_100__["default"]; });

/* harmony import */ var _TimeStampReq_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./TimeStampReq.js */ "./node_modules/pkijs/src/TimeStampReq.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeStampReq", function() { return _TimeStampReq_js__WEBPACK_IMPORTED_MODULE_101__["default"]; });

/* harmony import */ var _TimeStampResp_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./TimeStampResp.js */ "./node_modules/pkijs/src/TimeStampResp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeStampResp", function() { return _TimeStampResp_js__WEBPACK_IMPORTED_MODULE_102__["default"]; });

/* harmony import */ var _SignedCertificateTimestampList_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./SignedCertificateTimestampList.js */ "./node_modules/pkijs/src/SignedCertificateTimestampList.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SignedCertificateTimestampList", function() { return _SignedCertificateTimestampList_js__WEBPACK_IMPORTED_MODULE_103__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SignedCertificateTimestamp", function() { return _SignedCertificateTimestampList_js__WEBPACK_IMPORTED_MODULE_103__["SignedCertificateTimestamp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "verifySCTsForCertificate", function() { return _SignedCertificateTimestampList_js__WEBPACK_IMPORTED_MODULE_103__["verifySCTsForCertificate"]; });

/* harmony import */ var _CertificateTemplate_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./CertificateTemplate.js */ "./node_modules/pkijs/src/CertificateTemplate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CertificateTemplate", function() { return _CertificateTemplate_js__WEBPACK_IMPORTED_MODULE_104__["default"]; });

/* harmony import */ var _CAVersion_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./CAVersion.js */ "./node_modules/pkijs/src/CAVersion.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CAVersion", function() { return _CAVersion_js__WEBPACK_IMPORTED_MODULE_105__["default"]; });

/* harmony import */ var _QCStatements_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./QCStatements.js */ "./node_modules/pkijs/src/QCStatements.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QCStatement", function() { return _QCStatements_js__WEBPACK_IMPORTED_MODULE_106__["QCStatement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QCStatements", function() { return _QCStatements_js__WEBPACK_IMPORTED_MODULE_106__["default"]; });

/* harmony import */ var _ECNamedCurves__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./ECNamedCurves */ "./node_modules/pkijs/src/ECNamedCurves.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ECNamedCurves", function() { return _ECNamedCurves__WEBPACK_IMPORTED_MODULE_107__["default"]; });





























































































































































































































/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/pvutils/build/utils.es.js":
/*!************************************************!*\
  !*** ./node_modules/pvutils/build/utils.es.js ***!
  \************************************************/
/*! exports provided: arrayBufferToString, bufferToHexCodes, checkBufferParams, clearProps, fromBase64, getParametersValue, getUTCDate, isEqualBuffer, nearestPowerOf2, padNumber, stringToArrayBuffer, toBase64, utilConcatBuf, utilConcatView, utilDecodeTC, utilEncodeTC, utilFromBase, utilToBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayBufferToString", function() { return arrayBufferToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToHexCodes", function() { return bufferToHexCodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkBufferParams", function() { return checkBufferParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearProps", function() { return clearProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromBase64", function() { return fromBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParametersValue", function() { return getParametersValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUTCDate", function() { return getUTCDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEqualBuffer", function() { return isEqualBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nearestPowerOf2", function() { return nearestPowerOf2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padNumber", function() { return padNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringToArrayBuffer", function() { return stringToArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toBase64", function() { return toBase64; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilConcatBuf", function() { return utilConcatBuf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilConcatView", function() { return utilConcatView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilDecodeTC", function() { return utilDecodeTC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilEncodeTC", function() { return utilEncodeTC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilFromBase", function() { return utilFromBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utilToBase", function() { return utilToBase; });
/*!
 Copyright (c) Peculiar Ventures, LLC
*/

function getUTCDate(date) {
    return new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
}
function getParametersValue(parameters, name, defaultValue) {
    var _a;
    if ((parameters instanceof Object) === false) {
        return defaultValue;
    }
    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
}
function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false) {
    let result = "";
    for (const item of (new Uint8Array(inputBuffer, inputOffset, inputLength))) {
        const str = item.toString(16).toUpperCase();
        if (str.length === 1) {
            result += "0";
        }
        result += str;
        if (insertSpace) {
            result += " ";
        }
    }
    return result.trim();
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof ArrayBuffer)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}
function utilFromBase(inputBuffer, inputBase) {
    let result = 0;
    if (inputBuffer.length === 1) {
        return inputBuffer[0];
    }
    for (let i = (inputBuffer.length - 1); i >= 0; i--) {
        result += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);
    }
    return result;
}
function utilToBase(value, base, reserved = (-1)) {
    const internalReserved = reserved;
    let internalValue = value;
    let result = 0;
    let biggest = Math.pow(2, base);
    for (let i = 1; i < 8; i++) {
        if (value < biggest) {
            let retBuf;
            if (internalReserved < 0) {
                retBuf = new ArrayBuffer(i);
                result = i;
            }
            else {
                if (internalReserved < i) {
                    return (new ArrayBuffer(0));
                }
                retBuf = new ArrayBuffer(internalReserved);
                result = internalReserved;
            }
            const retView = new Uint8Array(retBuf);
            for (let j = (i - 1); j >= 0; j--) {
                const basis = Math.pow(2, j * base);
                retView[result - j - 1] = Math.floor(internalValue / basis);
                internalValue -= (retView[result - j - 1]) * basis;
            }
            return retBuf;
        }
        biggest *= Math.pow(2, base);
    }
    return new ArrayBuffer(0);
}
function utilConcatBuf(...buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for (const buffer of buffers) {
        outputLength += buffer.byteLength;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const buffer of buffers) {
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
    }
    return retBuf;
}
function utilConcatView(...views) {
    let outputLength = 0;
    let prevLength = 0;
    for (const view of views) {
        outputLength += view.length;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const view of views) {
        retView.set(view, prevLength);
        prevLength += view.length;
    }
    return retView;
}
function utilDecodeTC() {
    const buf = new Uint8Array(this.valueHex);
    if (this.valueHex.byteLength >= 2) {
        const condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);
        const condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);
        if (condition1 || condition2) {
            this.warnings.push("Needlessly long format");
        }
    }
    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const bigIntView = new Uint8Array(bigIntBuffer);
    for (let i = 0; i < this.valueHex.byteLength; i++) {
        bigIntView[i] = 0;
    }
    bigIntView[0] = (buf[0] & 0x80);
    const bigInt = utilFromBase(bigIntView, 8);
    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const smallIntView = new Uint8Array(smallIntBuffer);
    for (let j = 0; j < this.valueHex.byteLength; j++) {
        smallIntView[j] = buf[j];
    }
    smallIntView[0] &= 0x7F;
    const smallInt = utilFromBase(smallIntView, 8);
    return (smallInt - bigInt);
}
function utilEncodeTC(value) {
    const modValue = (value < 0) ? (value * (-1)) : value;
    let bigInt = 128;
    for (let i = 1; i < 8; i++) {
        if (modValue <= bigInt) {
            if (value < 0) {
                const smallInt = bigInt - modValue;
                const retBuf = utilToBase(smallInt, 8, i);
                const retView = new Uint8Array(retBuf);
                retView[0] |= 0x80;
                return retBuf;
            }
            let retBuf = utilToBase(modValue, 8, i);
            let retView = new Uint8Array(retBuf);
            if (retView[0] & 0x80) {
                const tempBuf = retBuf.slice(0);
                const tempView = new Uint8Array(tempBuf);
                retBuf = new ArrayBuffer(retBuf.byteLength + 1);
                retView = new Uint8Array(retBuf);
                for (let k = 0; k < tempBuf.byteLength; k++) {
                    retView[k + 1] = tempView[k];
                }
                retView[0] = 0x00;
            }
            return retBuf;
        }
        bigInt *= Math.pow(2, 8);
    }
    return (new ArrayBuffer(0));
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
        return false;
    }
    const view1 = new Uint8Array(inputBuffer1);
    const view2 = new Uint8Array(inputBuffer2);
    for (let i = 0; i < view1.length; i++) {
        if (view1[i] !== view2[i]) {
            return false;
        }
    }
    return true;
}
function padNumber(inputNumber, fullLength) {
    const str = inputNumber.toString(10);
    if (fullLength < str.length) {
        return "";
    }
    const dif = fullLength - str.length;
    const padding = new Array(dif);
    for (let i = 0; i < dif; i++) {
        padding[i] = "0";
    }
    const paddingString = padding.join("");
    return paddingString.concat(str);
}
const base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
    let i = 0;
    let flag1 = 0;
    let flag2 = 0;
    let output = "";
    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
    if (skipLeadingZeros) {
        let nonZeroPosition = 0;
        for (let i = 0; i < input.length; i++) {
            if (input.charCodeAt(i) !== 0) {
                nonZeroPosition = i;
                break;
            }
        }
        input = input.slice(nonZeroPosition);
    }
    while (i < input.length) {
        const chr1 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag1 = 1;
        }
        const chr2 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag2 = 1;
        }
        const chr3 = input.charCodeAt(i++);
        const enc1 = chr1 >> 2;
        const enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);
        let enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);
        let enc4 = chr3 & 0x3F;
        if (flag1 === 1) {
            enc3 = enc4 = 64;
        }
        else {
            if (flag2 === 1) {
                enc4 = 64;
            }
        }
        if (skipPadding) {
            if (enc3 === 64) {
                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
            }
            else {
                if (enc4 === 64) {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
                }
                else {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
                }
            }
        }
        else {
            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        }
    }
    return output;
}
function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
    const template = (useUrlTemplate) ? base64UrlTemplate : base64Template;
    function indexOf(toSearch) {
        for (let i = 0; i < 64; i++) {
            if (template.charAt(i) === toSearch)
                return i;
        }
        return 64;
    }
    function test(incoming) {
        return ((incoming === 64) ? 0x00 : incoming);
    }
    let i = 0;
    let output = "";
    while (i < input.length) {
        const enc1 = indexOf(input.charAt(i++));
        const enc2 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const enc3 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const enc4 = (i >= input.length) ? 0x00 : indexOf(input.charAt(i++));
        const chr1 = (test(enc1) << 2) | (test(enc2) >> 4);
        const chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);
        const chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    if (cutTailZeros) {
        const outputLength = output.length;
        let nonZeroStart = (-1);
        for (let i = (outputLength - 1); i >= 0; i--) {
            if (output.charCodeAt(i) !== 0) {
                nonZeroStart = i;
                break;
            }
        }
        if (nonZeroStart !== (-1)) {
            output = output.slice(0, nonZeroStart + 1);
        }
        else {
            output = "";
        }
    }
    return output;
}
function arrayBufferToString(buffer) {
    let resultString = "";
    const view = new Uint8Array(buffer);
    for (const element of view) {
        resultString += String.fromCharCode(element);
    }
    return resultString;
}
function stringToArrayBuffer(str) {
    const stringLength = str.length;
    const resultBuffer = new ArrayBuffer(stringLength);
    const resultView = new Uint8Array(resultBuffer);
    for (let i = 0; i < stringLength; i++) {
        resultView[i] = str.charCodeAt(i);
    }
    return resultBuffer;
}
const log2 = Math.log(2);
function nearestPowerOf2(length) {
    const base = (Math.log(length) / log2);
    const floor = Math.floor(base);
    const round = Math.round(base);
    return ((floor === round) ? floor : round);
}
function clearProps(object, propsArray) {
    for (const prop of propsArray) {
        delete object[prop];
    }
}




/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/i18n/strings.js":
/*!*****************************!*\
  !*** ./src/i18n/strings.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const strings = exports.strings = {
  ux: {
    upload: 'Upload Certificate'
  },

  names: {
    // Directory Pilot Attributes
    '0.9.2342.19200300.100.1.1': {
      short: 'uid',
      long: 'User ID'
    },
    '0.9.2342.19200300.100.1.25': {
      short: 'dc',
      long: 'Domain Component'
    },

    // PKCS-9
    '1.2.840.113549.1.9.1': {
      short: 'e',
      long: 'Email Address'
    },

    // Incorporated Locations
    '1.3.6.1.4.1.311.60.2.1.1': {
      short: undefined,
      long: 'Inc. Locality'
    },
    '1.3.6.1.4.1.311.60.2.1.2': {
      short: undefined,
      long: 'Inc. State / Province'
    },
    '1.3.6.1.4.1.311.60.2.1.3': {
      short: undefined,
      long: 'Inc. Country'
    },

    // microsoft cryptographic extensions
    '1.3.6.1.4.1.311.21.7': {
      name: {
        short: 'Certificate Template',
        long: 'Microsoft Certificate Template'
      }
    },
    '1.3.6.1.4.1.311.21.10': {
      name: {
        short: 'Certificate Policies',
        long: 'Microsoft Certificate Policies'
      }
    },

    // certificate extensions
    '1.3.6.1.4.1.11129.2.4.2': {
      name: {
        short: 'Embedded SCTs',
        long: 'Embedded Signed Certificate Timestamps'
      }
    },
    '1.3.6.1.5.5.7.1.1': {
      name: {
        short: undefined,
        long: 'Authority Information Access'
      }
    },
    '1.3.6.1.5.5.7.1.24': {
      name: {
        short: 'OCSP Stapling',
        long: 'Online Certificate Status Protocol Stapling'
      }
    },

    // X.500 attribute types
    '2.5.4.1': {
      short: undefined,
      long: 'Aliased Entry'
    },
    '2.5.4.2': {
      short: undefined,
      long: 'Knowledge Information'
    },
    '2.5.4.3': {
      short: 'cn',
      long: 'Common Name'
    },
    '2.5.4.4': {
      short: 'sn',
      long: 'Surname'
    },
    '2.5.4.5': {
      short: 'serialNumber',
      long: 'Serial Number'
    },
    '2.5.4.6': {
      short: 'c',
      long: 'Country'
    },
    '2.5.4.7': {
      short: 'l',
      long: 'Locality'
    },
    '2.5.4.8': {
      short: 's',
      long: 'State / Province'
    },
    '2.5.4.9': {
      short: 'street',
      long: 'Stress Address'
    },
    '2.5.4.10': {
      short: 'o',
      long: 'Organization'
    },
    '2.5.4.11': {
      short: 'ou',
      long: 'Organizational Unit'
    },
    '2.5.4.12': {
      short: 't',
      long: 'Title'
    },
    '2.5.4.13': {
      short: 'description',
      long: 'Description'
    },
    '2.5.4.14': {
      short: undefined,
      long: 'Search Guide'
    },
    '2.5.4.15': {
      short: undefined,
      long: 'Business Category'
    },
    '2.5.4.16': {
      short: undefined,
      long: 'Postal Address'
    },
    '2.5.4.17': {
      short: 'postalCode',
      long: 'Postal Code'
    },
    '2.5.4.18': {
      short: 'POBox',
      long: 'PO Box'
    },
    '2.5.4.19': {
      short: undefined,
      long: 'Physical Delivery Office Name'
    },
    '2.5.4.20': {
      short: 'phone',
      long: 'Phone Number'
    },
    '2.5.4.21': {
      short: undefined,
      long: 'Telex Number'
    },
    '2.5.4.22': {
      short: undefined,
      long: 'Teletex Terminal Identifier'
    },
    '2.5.4.23': {
      short: undefined,
      long: 'Fax Number'
    },
    '2.5.4.24': {
      short: undefined,
      long: 'X.121 Address'
    },
    '2.5.4.25': {
      short: undefined,
      long: 'International ISDN Number'
    },
    '2.5.4.26': {
      short: undefined,
      long: 'Registered Address'
    },
    '2.5.4.27': {
      short: undefined,
      long: 'Destination Indicator'
    },
    '2.5.4.28': {
      short: undefined,
      long: 'Preferred Delivery Method'
    },
    '2.5.4.29': {
      short: undefined,
      long: 'Presentation Address'
    },
    '2.5.4.30': {
      short: undefined,
      long: 'Supported Application Context'
    },
    '2.5.4.31': {
      short: undefined,
      long: 'Member'
    },
    '2.5.4.32': {
      short: undefined,
      long: 'Owner'
    },
    '2.5.4.33': {
      short: undefined,
      long: 'Role Occupant'
    },
    '2.5.4.34': {
      short: undefined,
      long: 'See Also'
    },
    '2.5.4.35': {
      short: undefined,
      long: 'User Password'
    },
    '2.5.4.36': {
      short: undefined,
      long: 'User Certificate'
    },
    '2.5.4.37': {
      short: undefined,
      long: 'CA Certificate'
    },
    '2.5.4.38': {
      short: undefined,
      long: 'Authority Revocation List'
    },
    '2.5.4.39': {
      short: undefined,
      long: 'Certificate Revocation List'
    },
    '2.5.4.40': {
      short: undefined,
      long: 'Cross-certificate Pair'
    },
    '2.5.4.41': {
      short: undefined,
      long: 'Name'
    },
    '2.5.4.42': {
      short: 'g',
      long: 'Given Name'
    },
    '2.5.4.43': {
      short: 'i',
      long: 'Initials'
    },
    '2.5.4.44': {
      short: undefined,
      long: 'Generation Qualifier'
    },
    '2.5.4.45': {
      short: undefined,
      long: 'Unique Identifier'
    },
    '2.5.4.46': {
      short: undefined,
      long: 'DN Qualifier'
    },
    '2.5.4.47': {
      short: undefined,
      long: 'Enhanced Search Guide'
    },
    '2.5.4.48': {
      short: undefined,
      long: 'Protocol Information'
    },
    '2.5.4.49': {
      short: 'dn',
      long: 'Distinguished Name'
    },
    '2.5.4.50': {
      short: undefined,
      long: 'Unique Member'
    },
    '2.5.4.51': {
      short: undefined,
      long: 'House Identifier'
    },
    '2.5.4.52': {
      short: undefined,
      long: 'Supported Algorithms'
    },
    '2.5.4.53': {
      short: undefined,
      long: 'Delta Revocation List'
    },
    '2.5.4.58': {
      short: undefined,
      long: 'Attribute Certificate Attribute' // huh
    },
    '2.5.4.65': {
      short: undefined,
      long: 'Pseudonym'
    },

    // extensions
    '2.5.29.14': {
      name: {
        short: 'Subject Key ID',
        long: 'Subject Key Identifier'
      }
    },
    '2.5.29.15': {
      name: {
        short: undefined,
        long: 'Key Usages'
      }
    },
    '2.5.29.17': {
      name: {
        short: 'Subject Alt Names',
        long: 'Subject Alternative Names'
      }
    },
    '2.5.29.19': {
      name: {
        short: undefined,
        long: 'Basic Constraints'
      }
    },
    '2.5.29.31': {
      name: {
        short: 'CRL Endpoints',
        long: 'Certificate Revocation List Endpoints'
      }
    },
    '2.5.29.32': {
      name: {
        short: undefined,
        long: 'Certificate Policies'
      }
    },
    '2.5.29.35': {
      name: {
        short: 'Authority Key ID',
        long: 'Authority Key Identifier'
      }
    },
    '2.5.29.37': {
      name: {
        short: undefined,
        long: 'Extended Key Usages'
      }
    }
  },

  keyUsages: ['CRL Signing', 'Certificate Signing', 'Key Agreement', 'Data Encipherment', 'Key Encipherment', 'Non-Repudiation', 'Digital Signature'],

  san: ['Other Name', 'RFC 822 Name', 'DNS Name', 'X.400 Address', 'Directory Name', 'EDI Party Name', 'URI', 'IP Address', 'Registered ID'],

  eKU: {
    '1.3.6.1.4.1.311.10.3.1': 'Certificate Trust List (CTL) Signing',
    '1.3.6.1.4.1.311.10.3.2': 'Timestamp Signing',
    '1.3.6.1.4.1.311.10.3.4': 'EFS Encryption',
    '1.3.6.1.4.1.311.10.3.4.1': 'EFS Recovery',
    '1.3.6.1.4.1.311.10.3.5': 'Windows Hardware Quality Labs (WHQL) Cryptography',
    '1.3.6.1.4.1.311.10.3.7': 'Windows NT 5 Cryptography',
    '1.3.6.1.4.1.311.10.3.8': 'Windows NT Embedded Cryptography',
    '1.3.6.1.4.1.311.10.3.10': 'Qualified Subordination',
    '1.3.6.1.4.1.311.10.3.11': 'Escrowed Key Recovery',
    '1.3.6.1.4.1.311.10.3.12': 'Document Signing',
    '1.3.6.1.4.1.311.10.5.1': 'Digital Rights Management',
    '1.3.6.1.4.1.311.10.6.1': 'Key Pack Licenses',
    '1.3.6.1.4.1.311.10.6.2': 'License Server',
    '1.3.6.1.4.1.311.20.2.1': 'Enrollment Agent',
    '1.3.6.1.4.1.311.20.2.2': 'Smartcard Login',
    '1.3.6.1.4.1.311.21.5': 'Certificate Authority Private Key Archival',
    '1.3.6.1.4.1.311.21.6': 'Key Recovery Agent',
    '1.3.6.1.4.1.311.21.19': 'Directory Service Email Replication',
    '1.3.6.1.5.5.7.3.1': 'Server Authentication',
    '1.3.6.1.5.5.7.3.2': 'Client Authentication',
    '1.3.6.1.5.5.7.3.3': 'Code Signing',
    '1.3.6.1.5.5.7.3.4': 'E-mail Protection',
    '1.3.6.1.5.5.7.3.5': 'IPsec End System',
    '1.3.6.1.5.5.7.3.6': 'IPsec Tunnel',
    '1.3.6.1.5.5.7.3.7': 'IPSec User',
    '1.3.6.1.5.5.7.3.8': 'Timestamping',
    '1.3.6.1.5.5.7.3.9': 'OCSP Signing',
    '1.3.6.1.5.5.8.2.2': 'Internet Key Exchange (IKE)'
  },

  signature: {
    '1.2.840.113549.1.1.5': 'SHA-1 with RSA Encryption',
    '1.2.840.113549.1.1.11': 'SHA-256 with RSA Encryption',
    '1.2.840.113549.1.1.12': 'SHA-384 with RSA Encryption',
    '1.2.840.113549.1.1.13': 'SHA-512 with RSA Encryption',
    '1.2.840.10040.4.3': 'DSA with SHA-1',
    '2.16.840.1.101.3.4.3.2': 'DSA with SHA-256',
    '1.2.840.10045.4.1': 'ECDSA with SHA-1',
    '1.2.840.10045.4.3.2': 'ECDSA with SHA-256',
    '1.2.840.10045.4.3.3': 'ECDSA with SHA-384',
    '1.2.840.10045.4.3.4': 'ECDSA with SHA-512'
  },

  aia: {
    '1.3.6.1.5.5.7.48.1': 'Online Certificate Status Protocol (OCSP)',
    '1.3.6.1.5.5.7.48.2': 'CA Issuers'
  },

  // this includes qualifiers as well
  cps: {
    '0.4.0.194112.1.4': {
      name: 'ETSI EN-319-411-2',
      value: undefined
    },
    '1.3.6.1.4.1': {
      name: 'Statement Identifier',
      value: undefined
    },
    '1.3.6.1.5.5.7.2.1': {
      name: 'Practices Statement',
      value: undefined
    },
    '1.3.6.1.5.5.7.2.2': {
      name: 'User Notice',
      value: undefined
    },
    '2.16.840': {
      name: 'ANSI Organizational Identifier',
      value: undefined
    },
    '2.23.140.1.1': {
      name: 'Certificate Type',
      value: 'Extended Validation'
    },
    '2.23.140.1.2.1': {
      name: 'Certificate Type',
      value: 'Domain Validation'
    },
    '2.23.140.1.2.2': {
      name: 'Certificate Type',
      value: 'Organization Validation'
    },
    '2.23.140.1.2.3': {
      name: 'Certificate Type',
      value: 'Individual Validation'
    },
    '2.23.140.1.3': {
      name: 'Certificate Type',
      value: 'Extended Validation (Code Signing)'
    },
    '2.23.140.1.31': {
      name: 'Certificate Type',
      value: '.onion Extended Validation'
    },
    '2.23.140.2.1': {
      name: 'Certificate Type',
      value: 'Test Certificate'
    }
  },

  microsoftCertificateTypes: {
    'Administrator': 'Administrator',
    'CA': 'Root Certification Authority',
    'CAExchange': 'CA Exchange',
    'CEPEncryption': 'CEP Encryption',
    'CertificateRequestAgent': 'Certificate Request Agent',
    'ClientAuth': 'Authenticated Session',
    'CodeSigning': 'Code Signing',
    'CrossCA': 'Cross Certification Authority',
    'CTLSigning': 'Trust List Signing',
    'DirectoryEmailReplication': 'Directory Email Replication',
    'DomainController': 'Domain Controller',
    'DomainControllerAuthentication': 'Domain Controller Authentication',
    'EFS': 'Basic EFS',
    'EFSRecovery': 'EFS Recovery Agent',
    'EnrollmentAgent': 'Enrollment Agent',
    'EnrollmentAgentOffline': 'Exchange Enrollment Agent (Offline request)',
    'ExchangeUser': 'Exchange User',
    'ExchangeUserSignature': 'Exchange Signature Only',
    'IPSECIntermediateOffline': 'IPSec (Offline request)',
    'IPSECIntermediateOnline': 'IPSEC',
    'KerberosAuthentication': 'Kerberos Authentication',
    'KeyRecoveryAgent': 'Key Recovery Agent',
    'Machine': 'Computer',
    'MachineEnrollmentAgent': 'Enrollment Agent (Computer)',
    'OCSPResponseSigning': 'OCSP Response Signing',
    'OfflineRouter': 'Router (Offline request)',
    'RASAndIASServer': 'RAS and IAS Server',
    'SmartcardLogon': 'Smartcard Logon',
    'SmartcardUser': 'Smartcard User',
    'SubCA': 'Subordinate Certification Authority',
    'User': 'User',
    'UserSignature': 'User Signature Only',
    'WebServer': 'Web Server',
    'Workstation': 'Workstation Authentication'
  }
};

/***/ }),

/***/ "./src/viewer/helpers/eq.js":
/*!**********************************!*\
  !*** ./src/viewer/helpers/eq.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = (i, j) => {
  // explicitly not === for template usage
  return i == j;
};

/***/ }),

/***/ "./src/viewer/helpers/is_web_uri.js":
/*!******************************************!*\
  !*** ./src/viewer/helpers/is_web_uri.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = _url => {
  try {
    let url = new URL(_url);

    if (url.protocol === 'http:' || url.protocol === 'https:') {
      return true;
    }
  } catch (e) {
    return false;
  }

  return false;
};

/***/ }),

/***/ "./src/viewer/helpers/link.js":
/*!************************************!*\
  !*** ./src/viewer/helpers/link.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _runtime = __webpack_require__(/*! handlebars/runtime */ "./node_modules/handlebars/dist/cjs/handlebars.runtime.js");

var Handlebars = _interopRequireWildcard(_runtime);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = (text, url) => {
  return `<a href="${new URL(url).href}">${Handlebars.Utils.escapeExpression(text)}</a>`;
};

/***/ }),

/***/ "./src/viewer/helpers/onebasedindex.js":
/*!*********************************************!*\
  !*** ./src/viewer/helpers/onebasedindex.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = index => {
  return index + 1;
};

/***/ }),

/***/ "./src/viewer/helpers/truthy.js":
/*!**************************************!*\
  !*** ./src/viewer/helpers/truthy.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = v => {
  if (v === undefined || v === null || v === 'none' || v === false) {
    return false;
  }

  // empty array or string
  if ((Array.isArray(v) || typeof v === 'string') && v.length === 0) {
    return false;
  }

  return true;
};

/***/ }),

/***/ "./src/viewer/index.handlebars":
/*!*************************************!*\
  !*** ./src/viewer/index.handlebars ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Handlebars = __webpack_require__(/*! ../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <div class=\"row section\" id=\"handshake\">\n      <div class=\"panel\">\n        <div class=\"panel-section panel-section-header\">\n          <div class=\"text-section-header\"><h1>Handshake</h1></div>\n        </div>\n        <div class=\"panel-list-item\">\n          <div class=\"text\">Protocol</div>\n          <div class=\"text\">"
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"protocolVersion") : depth0), depth0))
    + "</div>\n        </div>\n        <div class=\"panel-list-item\">\n          <div class=\"text\">Cipher Suite</div>\n          <div class=\"text breakable\">"
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"cipherSuite") : depth0), depth0))
    + "</div>\n        </div>\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias3,(depth0 != null ? lookupProperty(depth0,"keaGroupName") : depth0),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":17,"column":14},"end":{"line":17,"column":35}}}),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":17,"column":8},"end":{"line":22,"column":15}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias3,(depth0 != null ? lookupProperty(depth0,"signatureSchemeName") : depth0),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":23,"column":14},"end":{"line":23,"column":42}}}),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":23,"column":8},"end":{"line":28,"column":15}}})) != null ? stack1 : "")
    + "      </div>\n    </div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <div class=\"panel-list-item\">\n          <div class=\"text\">Key Exchange Group</div>\n          <div class=\"text\">"
    + container.escapeExpression(container.lambda((depth0 != null ? lookupProperty(depth0,"keaGroupName") : depth0), depth0))
    + "</div>\n        </div>\n";
},"4":function(container,depth0,helpers,partials,data) {
    var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <div class=\"panel-list-item\">\n          <div class=\"text\">Signature Scheme</div>\n          <div class=\"text\">"
    + container.escapeExpression(container.lambda((depth0 != null ? lookupProperty(depth0,"signatureSchemeName") : depth0), depth0))
    + "</div>\n        </div>\n";
},"6":function(container,depth0,helpers,partials,data) {
    return "b-0";
},"8":function(container,depth0,helpers,partials,data) {
    return "Certificate";
},"10":function(container,depth0,helpers,partials,data) {
    return "Certificates";
},"12":function(container,depth0,helpers,partials,data) {
    return "          <div class=\"panel-list-item-separator\"></div>\n";
},"14":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-section\" id=\"panel-section-tabs\">\n"
    + ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"certs") : depth0),{"name":"each","hash":{},"fn":container.program(15, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":47,"column":12},"end":{"line":49,"column":21}}})) != null ? stack1 : "")
    + "            <div class=\"panel-list-item-separator\"></div>\n          </div>\n";
},"15":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.lambda, alias3=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-tabs-button "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(data && lookupProperty(data,"first")),{"name":"if","hash":{},"fn":container.program(16, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":48,"column":50},"end":{"line":48,"column":79}}})) != null ? stack1 : "")
    + "\" data-certificate-index=\""
    + alias3(alias2((data && lookupProperty(data,"index")), depth0))
    + "\">"
    + alias3(alias2(((stack1 = (depth0 != null ? lookupProperty(depth0,"subject") : depth0)) != null ? lookupProperty(stack1,"cn") : stack1), depth0))
    + " "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isBuiltInRoot") : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":48,"column":139},"end":{"line":48,"column":187}}})) != null ? stack1 : "")
    + "</div>\n";
},"16":function(container,depth0,helpers,partials,data) {
    return "selected";
},"18":function(container,depth0,helpers,partials,data) {
    return "(built-in root)";
},"20":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <div class=\"certificate\" data-certificate-index=\""
    + alias2(alias1((data && lookupProperty(data,"index")), depth0))
    + "\" "
    + ((stack1 = lookupProperty(helpers,"unless").call(alias3,(data && lookupProperty(data,"first")),{"name":"unless","hash":{},"fn":container.program(21, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":55,"column":69},"end":{"line":55,"column":104}}})) != null ? stack1 : "")
    + ">\n          <div class=\"panel-section-subheader\">\n            <span>Subject Name</span>\n          </div>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"subject") : depth0)) != null ? lookupProperty(stack1,"entries") : stack1),{"name":"each","hash":{},"fn":container.program(23, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":60,"column":10},"end":{"line":65,"column":19}}})) != null ? stack1 : "")
    + "\n          <div class=\"panel-section-subheader\">\n            <span>Issuer Name</span>\n          </div>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"issuer") : depth0)) != null ? lookupProperty(stack1,"entries") : stack1),{"name":"each","hash":{},"fn":container.program(25, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":71,"column":10},"end":{"line":84,"column":19}}})) != null ? stack1 : "")
    + "\n\n          <div class=\"panel-section-subheader\">\n            <span>Validity</span>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">Not Before</div>\n            <div class=\"text\">"
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"notBefore") : depth0), depth0))
    + "</div>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">Not After</div>\n            <div class=\"text\">"
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"notAfter") : depth0), depth0))
    + "</div>\n          </div>\n\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias3,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"san") : stack1)) != null ? lookupProperty(stack1,"altNames") : stack1),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":100,"column":16},"end":{"line":100,"column":46}}}),{"name":"if","hash":{},"fn":container.program(31, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":100,"column":10},"end":{"line":114,"column":17}}})) != null ? stack1 : "")
    + "\n          <div class=\"panel-section-subheader\">\n            <span>Public Key Info</span>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">Algorithm</div>\n            <div class=\"text\">"
    + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"kty") : stack1), depth0))
    + "</div>\n          </div>\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"keysize") : stack1),{"name":"if","hash":{},"fn":container.program(36, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":124,"column":10},"end":{"line":129,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"crv") : stack1),{"name":"if","hash":{},"fn":container.program(38, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":132,"column":10},"end":{"line":137,"column":17}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"xy") : stack1),{"name":"if","hash":{},"fn":container.program(40, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":138,"column":10},"end":{"line":143,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"e") : stack1),{"name":"if","hash":{},"fn":container.program(42, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":146,"column":10},"end":{"line":151,"column":17}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"n") : stack1),{"name":"if","hash":{},"fn":container.program(44, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":152,"column":10},"end":{"line":157,"column":17}}})) != null ? stack1 : "")
    + "\n          <div class=\"panel-section-subheader\">\n            <span>Miscellaneous</span>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">Download</div>\n            <div class=\"text\"><a href=\"data:,"
    + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"files") : depth0)) != null ? lookupProperty(stack1,"pem") : stack1), depth0))
    + "\" download=\""
    + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"subject") : depth0)) != null ? lookupProperty(stack1,"cn") : stack1), depth0))
    + ".pem\">PEM (cert)</a>, <a href=\"data:,"
    + ((stack1 = lookupProperty(helpers,"each").call(alias3,(depths[1] != null ? lookupProperty(depths[1],"certs") : depths[1]),{"name":"each","hash":{},"fn":container.program(46, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":164,"column":135},"end":{"line":164,"column":182}}})) != null ? stack1 : "")
    + "\" download=\""
    + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"subject") : depth0)) != null ? lookupProperty(stack1,"cn") : stack1), depth0))
    + "-chain.pem\">PEM (chain)</a></div>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">Serial Number</div>\n            <div class=\"text long-hex long-hex-box\">"
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"serialNumber") : depth0), depth0))
    + "</div>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">Signature Algorithm</div>\n            <div class=\"text\">"
    + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"signature") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
    + "</div>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">Version</div>\n            <div class=\"text\">"
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"version") : depth0), depth0))
    + "</div>\n          </div>\n\n          <div class=\"panel-section-subheader\">\n            <span>Fingerprints</span>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">SHA-256</div>\n            <div class=\"text long-hex long-hex-box\">"
    + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"fingerprint") : depth0)) != null ? lookupProperty(stack1,"sha256") : stack1), depth0))
    + "</div>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">SHA-1</div>\n            <div class=\"text long-hex long-hex-box\">"
    + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"fingerprint") : depth0)) != null ? lookupProperty(stack1,"sha1") : stack1), depth0))
    + "</div>\n          </div>\n\n          <div class=\"panel-section-subsection\">Extensions</div>\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"basicConstraints") : stack1),{"name":"if","hash":{},"fn":container.program(48, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":194,"column":10},"end":{"line":205,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"keyUsages") : stack1),{"name":"if","hash":{},"fn":container.program(53, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":208,"column":10},"end":{"line":219,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"eKeyUsages") : stack1),{"name":"if","hash":{},"fn":container.program(57, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":222,"column":10},"end":{"line":233,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"ocspStaple") : stack1)) != null ? lookupProperty(stack1,"required") : stack1),{"name":"if","hash":{},"fn":container.program(59, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":236,"column":10},"end":{"line":247,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"sKID") : stack1),{"name":"if","hash":{},"fn":container.program(61, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":250,"column":10},"end":{"line":261,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"aKID") : stack1),{"name":"if","hash":{},"fn":container.program(63, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":264,"column":10},"end":{"line":275,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"crlPoints") : stack1),{"name":"if","hash":{},"fn":container.program(65, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":278,"column":10},"end":{"line":291,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"aia") : stack1)) != null ? lookupProperty(stack1,"descriptions") : stack1),{"name":"if","hash":{},"fn":container.program(68, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":294,"column":10},"end":{"line":312,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"cp") : stack1)) != null ? lookupProperty(stack1,"policies") : stack1),{"name":"if","hash":{},"fn":container.program(72, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":315,"column":10},"end":{"line":352,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"scts") : stack1)) != null ? lookupProperty(stack1,"timestamps") : stack1),{"name":"if","hash":{},"fn":container.program(89, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":355,"column":10},"end":{"line":381,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias3,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"exists") : stack1),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":384,"column":16},"end":{"line":384,"column":49}}}),{"name":"if","hash":{},"fn":container.program(95, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":384,"column":10},"end":{"line":467,"column":17}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias3,(depth0 != null ? lookupProperty(depth0,"unsupportedExtensions") : depth0),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":470,"column":16},"end":{"line":470,"column":51}}}),{"name":"if","hash":{},"fn":container.program(106, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":470,"column":10},"end":{"line":480,"column":17}}})) != null ? stack1 : "")
    + "\n        </div>\n";
},"21":function(container,depth0,helpers,partials,data) {
    return "hidden";
},"23":function(container,depth0,helpers,partials,data) {
    var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-list-item\">\n            <div class=\"text\">"
    + alias2(lookupProperty(helpers,"lookup").call(alias1,depth0,0,{"name":"lookup","hash":{},"data":data,"loc":{"start":{"line":62,"column":30},"end":{"line":62,"column":47}}}))
    + "</div>\n            <div class=\"text\">"
    + alias2(lookupProperty(helpers,"lookup").call(alias1,depth0,1,{"name":"lookup","hash":{},"data":data,"loc":{"start":{"line":63,"column":30},"end":{"line":63,"column":47}}}))
    + "</div>\n          </div>\n";
},"25":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-list-item\">\n              <div class=\"text\">"
    + container.escapeExpression(lookupProperty(helpers,"lookup").call(alias1,depth0,0,{"name":"lookup","hash":{},"data":data,"loc":{"start":{"line":73,"column":32},"end":{"line":73,"column":49}}}))
    + "</div>\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(data && lookupProperty(data,"last")),{"name":"if","hash":{},"fn":container.program(26, data, 0, blockParams, depths),"inverse":container.program(27, data, 0, blockParams, depths),"data":data,"loc":{"start":{"line":74,"column":14},"end":{"line":82,"column":21}}})) != null ? stack1 : "")
    + "          </div>\n";
},"26":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(container.data(data, 1) && lookupProperty(container.data(data, 1),"last")),{"name":"if","hash":{},"fn":container.program(27, data, 0, blockParams, depths),"inverse":container.program(29, data, 0, blockParams, depths),"data":data,"loc":{"start":{"line":75,"column":14},"end":{"line":79,"column":21}}})) != null ? stack1 : "");
},"27":function(container,depth0,helpers,partials,data) {
    var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"text\">"
    + container.escapeExpression(lookupProperty(helpers,"lookup").call(depth0 != null ? depth0 : (container.nullContext || {}),depth0,1,{"name":"lookup","hash":{},"data":data,"loc":{"start":{"line":76,"column":32},"end":{"line":76,"column":49}}}))
    + "</div>\n";
},"29":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var alias1=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"text\"><a class=\"issuer-link\" id=\""
    + alias1(container.lambda((container.data(data, 1) && lookupProperty(container.data(data, 1),"index")), depth0))
    + "\" href=\"#\">"
    + alias1(lookupProperty(helpers,"lookup").call(depth0 != null ? depth0 : (container.nullContext || {}),depth0,1,{"name":"lookup","hash":{},"data":data,"loc":{"start":{"line":78,"column":83},"end":{"line":78,"column":100}}}))
    + "</a></div>\n";
},"31":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"san") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":104,"column":16},"end":{"line":104,"column":258}}})) != null ? stack1 : "")
    + "Subject Alt Names\n              </span>\n            </div>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"san") : stack1)) != null ? lookupProperty(stack1,"altNames") : stack1),{"name":"each","hash":{},"fn":container.program(34, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":108,"column":12},"end":{"line":113,"column":21}}})) != null ? stack1 : "");
},"32":function(container,depth0,helpers,partials,data) {
    return "<img class=\"critical\" alt=\"critical extension\" title=\"This extension has been marked as critical, meaning that clients must reject the certificate if they don't understand it.\" src=\"../icons/critical.svg\">";
},"34":function(container,depth0,helpers,partials,data) {
    var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-list-item\">\n                <div class=\"text\">"
    + alias2(lookupProperty(helpers,"lookup").call(alias1,depth0,0,{"name":"lookup","hash":{},"data":data,"loc":{"start":{"line":110,"column":34},"end":{"line":110,"column":51}}}))
    + "</div>\n                <div class=\"text\">"
    + alias2(lookupProperty(helpers,"lookup").call(alias1,depth0,1,{"name":"lookup","hash":{},"data":data,"loc":{"start":{"line":111,"column":34},"end":{"line":111,"column":51}}}))
    + "</div>\n              </div>\n";
},"36":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-list-item\">\n            <div class=\"text\">Key size</div>\n            <div class=\"text\">"
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"keysize") : stack1), depth0))
    + " bits</div>\n          </div>\n";
},"38":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-list-item\">\n            <div class=\"text\">Curve</div>\n            <div class=\"text\">"
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"crv") : stack1), depth0))
    + "</div>\n          </div>\n";
},"40":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-list-item\">\n            <div class=\"text\">Public Value</div>\n            <div class=\"text long-hex long-hex-box\">"
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"xy") : stack1), depth0))
    + "</div>\n          </div>\n";
},"42":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-list-item\">\n            <div class=\"text\">Exponent</div>\n            <div class=\"text\">"
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"e") : stack1), depth0))
    + "</div>\n          </div>\n";
},"44":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-list-item\">\n            <div class=\"text\">Modulus</div>\n            <div class=\"text long-hex long-hex-box\">"
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"subjectPublicKeyInfo") : depth0)) != null ? lookupProperty(stack1,"n") : stack1), depth0))
    + "</div>\n          </div>\n";
},"46":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"files") : depth0)) != null ? lookupProperty(stack1,"pem") : stack1), depth0));
},"48":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"basicConstraints") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":197,"column":16},"end":{"line":197,"column":271}}})) != null ? stack1 : "")
    + "Basic Constraints\n              </span>\n            </div>\n            <div class=\"panel-list-item\">\n              <div class=\"text\">Certificate Authority</div>\n              <div class=\"text\">"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"basicConstraints") : stack1)) != null ? lookupProperty(stack1,"cA") : stack1),{"name":"if","hash":{},"fn":container.program(49, data, 0),"inverse":container.program(51, data, 0),"data":data,"loc":{"start":{"line":203,"column":32},"end":{"line":203,"column":88}}})) != null ? stack1 : "")
    + "</div>\n            </div>\n";
},"49":function(container,depth0,helpers,partials,data) {
    return "Yes";
},"51":function(container,depth0,helpers,partials,data) {
    return "No";
},"53":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"keyUsages") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":211,"column":16},"end":{"line":211,"column":264}}})) != null ? stack1 : "")
    + "Key Usages\n              </span>\n            </div>\n            <div class=\"panel-list-item\">\n              <div class=\"text\">Purposes</div>\n              <div class=\"text\">"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"keyUsages") : stack1)) != null ? lookupProperty(stack1,"purposes") : stack1),{"name":"each","hash":{},"fn":container.program(54, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":217,"column":32},"end":{"line":217,"column":118}}})) != null ? stack1 : "")
    + "</div>\n            </div>\n";
},"54":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(container.lambda(depth0, depth0))
    + ((stack1 = lookupProperty(helpers,"unless").call(depth0 != null ? depth0 : (container.nullContext || {}),(data && lookupProperty(data,"last")),{"name":"unless","hash":{},"fn":container.program(55, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":217,"column":79},"end":{"line":217,"column":109}}})) != null ? stack1 : "");
},"55":function(container,depth0,helpers,partials,data) {
    return ", ";
},"57":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"eKeyUsages") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":225,"column":16},"end":{"line":225,"column":265}}})) != null ? stack1 : "")
    + "Extended Key Usages\n              </span>\n            </div>\n            <div class=\"panel-list-item\">\n              <div class=\"text\">Purposes</div>\n              <div class=\"text\">"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"eKeyUsages") : stack1)) != null ? lookupProperty(stack1,"purposes") : stack1),{"name":"each","hash":{},"fn":container.program(54, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":231,"column":32},"end":{"line":231,"column":119}}})) != null ? stack1 : "")
    + "</div>\n            </div>\n";
},"59":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-section-subheader\">\n            <span>\n              "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"ocspStaple") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":239,"column":14},"end":{"line":239,"column":263}}})) != null ? stack1 : "")
    + "<abbr title=\"Online Certificate Status Protocol\">OCSP</abbr> Stapling\n            </span>\n          </div>\n          <div class=\"panel-list-item\">\n            <div class=\"text\">Required</div>\n            <div class=\"text\">Yes</div>\n          </div>\n";
},"61":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"sKID") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":253,"column":16},"end":{"line":253,"column":259}}})) != null ? stack1 : "")
    + "Subject Key ID\n              </span>\n            </div>\n            <div class=\"panel-list-item\">\n              <div class=\"text\">Key ID</div>\n              <div class=\"text long-hex long-hex-box\">"
    + container.escapeExpression(container.lambda(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"sKID") : stack1)) != null ? lookupProperty(stack1,"id") : stack1), depth0))
    + "</div>\n            </div>\n";
},"63":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"aKID") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":267,"column":16},"end":{"line":267,"column":259}}})) != null ? stack1 : "")
    + "Authority Key ID\n              </span>\n            </div>\n            <div class=\"panel-list-item\">\n              <div class=\"text\">Key ID</div>\n              <div class=\"text long-hex long-hex-box\">"
    + container.escapeExpression(container.lambda(((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"aKID") : stack1)) != null ? lookupProperty(stack1,"id") : stack1), depth0))
    + "</div>\n            </div>\n";
},"65":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"crlPoints") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":281,"column":16},"end":{"line":281,"column":264}}})) != null ? stack1 : "")
    + "<abbr title=\"Certificate Revocation List\">CRL</abbr> Endpoints\n              </span>\n            </div>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"crlPoints") : stack1)) != null ? lookupProperty(stack1,"points") : stack1),{"name":"each","hash":{},"fn":container.program(66, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":285,"column":12},"end":{"line":290,"column":21}}})) != null ? stack1 : "");
},"66":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-list-item\">\n                <div class=\"text\">Distribution Point "
    + container.escapeExpression(__default(__webpack_require__(/*! ./helpers/onebasedindex.js */ "./src/viewer/helpers/onebasedindex.js")).call(alias1,(data && lookupProperty(data,"index")),{"name":"onebasedindex","hash":{},"data":data,"loc":{"start":{"line":287,"column":53},"end":{"line":287,"column":77}}}))
    + "</div>\n                <div class=\"text breakable\">"
    + ((stack1 = __default(__webpack_require__(/*! ./helpers/link.js */ "./src/viewer/helpers/link.js")).call(alias1,depth0,depth0,{"name":"link","hash":{},"data":data,"loc":{"start":{"line":288,"column":44},"end":{"line":288,"column":64}}})) != null ? stack1 : "")
    + "</div>\n              </div>\n";
},"68":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"aia") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":297,"column":16},"end":{"line":297,"column":258}}})) != null ? stack1 : "")
    + "Authority Info (<abbr title=\"Authority Information Access\">AIA</abbr>)\n              </span>\n            </div>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"aia") : stack1)) != null ? lookupProperty(stack1,"descriptions") : stack1),{"name":"each","hash":{},"fn":container.program(69, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":301,"column":12},"end":{"line":311,"column":21}}})) != null ? stack1 : "");
},"69":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-list-item\">\n                <div class=\"text\">Method "
    + alias2(__default(__webpack_require__(/*! ./helpers/onebasedindex.js */ "./src/viewer/helpers/onebasedindex.js")).call(alias1,(data && lookupProperty(data,"index")),{"name":"onebasedindex","hash":{},"data":data,"loc":{"start":{"line":303,"column":41},"end":{"line":303,"column":65}}}))
    + "</div>\n                <div class=\"text\">"
    + alias2(container.lambda((depth0 != null ? lookupProperty(depth0,"method") : depth0), depth0))
    + "</div>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Location</div>\n                <div class=\"text breakable\">"
    + ((stack1 = __default(__webpack_require__(/*! ./helpers/link.js */ "./src/viewer/helpers/link.js")).call(alias1,(depth0 != null ? lookupProperty(depth0,"location") : depth0),(depth0 != null ? lookupProperty(depth0,"location") : depth0),{"name":"link","hash":{},"data":data,"loc":{"start":{"line":308,"column":44},"end":{"line":308,"column":82}}})) != null ? stack1 : "")
    + "</div>\n              </div>\n              "
    + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(data && lookupProperty(data,"last")),{"name":"unless","hash":{},"fn":container.program(70, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":310,"column":14},"end":{"line":310,"column":87}}})) != null ? stack1 : "")
    + "\n";
},"70":function(container,depth0,helpers,partials,data) {
    return "<div class=\"panel-list-item-separator\"></div>";
},"72":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"cp") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":318,"column":16},"end":{"line":318,"column":257}}})) != null ? stack1 : "")
    + "Certificate Policies\n              </span>\n            </div>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"cp") : stack1)) != null ? lookupProperty(stack1,"policies") : stack1),{"name":"each","hash":{},"fn":container.program(73, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":322,"column":12},"end":{"line":351,"column":21}}})) != null ? stack1 : "");
},"73":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-list-item\">\n                <div class=\"text\">Policy "
    + container.escapeExpression(__default(__webpack_require__(/*! ./helpers/onebasedindex.js */ "./src/viewer/helpers/onebasedindex.js")).call(alias1,(data && lookupProperty(data,"index")),{"name":"onebasedindex","hash":{},"data":data,"loc":{"start":{"line":324,"column":41},"end":{"line":324,"column":65}}}))
    + "</div>\n                <div class=\"text\">"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"name") : depth0),{"name":"if","hash":{},"fn":container.program(74, data, 0),"inverse":container.program(76, data, 0),"data":data,"loc":{"start":{"line":325,"column":34},"end":{"line":325,"column":112}}})) != null ? stack1 : "")
    + "</div>\n              </div>\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"if","hash":{},"fn":container.program(78, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":327,"column":14},"end":{"line":332,"column":21}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"qualifiers") : depth0),{"name":"if","hash":{},"fn":container.program(83, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":333,"column":14},"end":{"line":349,"column":21}}})) != null ? stack1 : "")
    + "              "
    + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(data && lookupProperty(data,"last")),{"name":"unless","hash":{},"fn":container.program(70, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":350,"column":14},"end":{"line":350,"column":87}}})) != null ? stack1 : "")
    + "\n";
},"74":function(container,depth0,helpers,partials,data) {
    var alias1=container.lambda, alias2=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return alias2(alias1((depth0 != null ? lookupProperty(depth0,"name") : depth0), depth0))
    + " ( "
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"id") : depth0), depth0))
    + " )";
},"76":function(container,depth0,helpers,partials,data) {
    var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(container.lambda((depth0 != null ? lookupProperty(depth0,"id") : depth0), depth0));
},"78":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "                <div class=\"panel-list-item\">\n                  <div class=\"text\">Value</div>\n                  <div class=\"text\">"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/is_web_uri.js */ "./src/viewer/helpers/is_web_uri.js")).call(alias1,(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"is_web_uri","hash":{},"data":data,"loc":{"start":{"line":330,"column":42},"end":{"line":330,"column":65}}}),{"name":"if","hash":{},"fn":container.program(79, data, 0),"inverse":container.program(81, data, 0),"data":data,"loc":{"start":{"line":330,"column":36},"end":{"line":330,"column":130}}})) != null ? stack1 : "")
    + "</div>\n                </div>\n";
},"79":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = __default(__webpack_require__(/*! ./helpers/link.js */ "./src/viewer/helpers/link.js")).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"value") : depth0),(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"link","hash":{},"data":data,"loc":{"start":{"line":330,"column":67},"end":{"line":330,"column":99}}})) != null ? stack1 : "");
},"81":function(container,depth0,helpers,partials,data) {
    var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(container.lambda((depth0 != null ? lookupProperty(depth0,"value") : depth0), depth0));
},"83":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"if","hash":{},"fn":container.program(84, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":334,"column":16},"end":{"line":336,"column":23}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,(depth0 != null ? lookupProperty(depth0,"qualifiers") : depth0),{"name":"each","hash":{},"fn":container.program(86, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":337,"column":16},"end":{"line":348,"column":25}}})) != null ? stack1 : "");
},"84":function(container,depth0,helpers,partials,data) {
    return "                  <div class=\"panel-list-item-separator\"></div>\n";
},"86":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "                  <div class=\"panel-list-item\">\n                    <div class=\"text\">Qualifier "
    + container.escapeExpression(__default(__webpack_require__(/*! ./helpers/onebasedindex.js */ "./src/viewer/helpers/onebasedindex.js")).call(alias1,(data && lookupProperty(data,"index")),{"name":"onebasedindex","hash":{},"data":data,"loc":{"start":{"line":339,"column":48},"end":{"line":339,"column":72}}}))
    + "</div>\n                    <div class=\"text\">"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"name") : depth0),{"name":"if","hash":{},"fn":container.program(74, data, 0),"inverse":container.program(76, data, 0),"data":data,"loc":{"start":{"line":340,"column":38},"end":{"line":340,"column":116}}})) != null ? stack1 : "")
    + "</div>\n                  </div>\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"if","hash":{},"fn":container.program(87, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":342,"column":18},"end":{"line":347,"column":25}}})) != null ? stack1 : "");
},"87":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "                    <div class=\"panel-list-item\">\n                      <div class=\"text\">Value</div>\n                      <div class=\"text breakable\">"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/is_web_uri.js */ "./src/viewer/helpers/is_web_uri.js")).call(alias1,(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"is_web_uri","hash":{},"data":data,"loc":{"start":{"line":345,"column":56},"end":{"line":345,"column":79}}}),{"name":"if","hash":{},"fn":container.program(79, data, 0),"inverse":container.program(81, data, 0),"data":data,"loc":{"start":{"line":345,"column":50},"end":{"line":345,"column":144}}})) != null ? stack1 : "")
    + "</div>\n                    </div>\n";
},"89":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subheader\">\n              <span>\n                "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"scts") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":358,"column":16},"end":{"line":358,"column":259}}})) != null ? stack1 : "")
    + "Embedded <abbr title=\"Signed Certificate Timestamp\">SCTs</abbr>\n              </span>\n            </div>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"scts") : stack1)) != null ? lookupProperty(stack1,"timestamps") : stack1),{"name":"each","hash":{},"fn":container.program(90, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":362,"column":12},"end":{"line":380,"column":21}}})) != null ? stack1 : "");
},"90":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-list-item\">\n                <div class=\"text\">Log ID</div>\n                <div class=\"text long-hex long-hex-box\">"
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"logId") : depth0), depth0))
    + "</div>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Log Name</div>\n                <div class=\"text\">"
    + ((stack1 = lookupProperty(helpers,"if").call(alias3,(depth0 != null ? lookupProperty(depth0,"name") : depth0),{"name":"if","hash":{},"fn":container.program(91, data, 0),"inverse":container.program(93, data, 0),"data":data,"loc":{"start":{"line":369,"column":34},"end":{"line":369,"column":88}}})) != null ? stack1 : "")
    + "</div>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Signature Algorithm</div>\n                <div class=\"text\">"
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"signatureAlgorithm") : depth0), depth0))
    + "</div>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Timestamp</div>\n                <div class=\"text\">"
    + alias2(alias1((depth0 != null ? lookupProperty(depth0,"timestamp") : depth0), depth0))
    + "</div>\n              </div>\n              "
    + ((stack1 = lookupProperty(helpers,"unless").call(alias3,(data && lookupProperty(data,"last")),{"name":"unless","hash":{},"fn":container.program(70, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":379,"column":14},"end":{"line":379,"column":87}}})) != null ? stack1 : "")
    + "\n";
},"91":function(container,depth0,helpers,partials,data) {
    var lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(container.lambda((depth0 != null ? lookupProperty(depth0,"name") : depth0), depth0));
},"93":function(container,depth0,helpers,partials,data) {
    return "Unknown";
},"95":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <div class=\"panel-section-subsection mt-4\">Microsoft Cryptographic Extensions</div>\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"previousHash") : stack1),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":387,"column":18},"end":{"line":387,"column":57}}}),{"name":"if","hash":{},"fn":container.program(96, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":387,"column":12},"end":{"line":398,"column":19}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificatePolicies") : stack1),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":401,"column":18},"end":{"line":401,"column":64}}}),{"name":"if","hash":{},"fn":container.program(98, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":401,"column":12},"end":{"line":412,"column":19}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificateType") : stack1),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":415,"column":18},"end":{"line":415,"column":60}}}),{"name":"if","hash":{},"fn":container.program(100, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":415,"column":12},"end":{"line":426,"column":19}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificateTemplate") : stack1),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":429,"column":18},"end":{"line":429,"column":64}}}),{"name":"if","hash":{},"fn":container.program(102, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":429,"column":12},"end":{"line":448,"column":19}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/truthy.js */ "./src/viewer/helpers/truthy.js")).call(alias1,((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"caVersion") : stack1),{"name":"truthy","hash":{},"data":data,"loc":{"start":{"line":451,"column":18},"end":{"line":451,"column":54}}}),{"name":"if","hash":{},"fn":container.program(104, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":451,"column":12},"end":{"line":466,"column":19}}})) != null ? stack1 : "");
},"96":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-section-subheader\">\n                <span>\n                  "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"previousHash") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":390,"column":18},"end":{"line":390,"column":278}}})) != null ? stack1 : "")
    + "History\n                </span>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Previous Hash</div>\n                <div class=\"text long-hex long-hex-box\">"
    + container.escapeExpression(container.lambda(((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"previousHash") : stack1)) != null ? lookupProperty(stack1,"previousHash") : stack1), depth0))
    + "</div>\n              </div>\n";
},"98":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-section-subheader\">\n                <span>\n                  "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificatePolicies") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":404,"column":18},"end":{"line":404,"column":285}}})) != null ? stack1 : "")
    + "Key Usages\n                </span>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Policies</div>\n                <div class=\"text\">"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificatePolicies") : stack1)) != null ? lookupProperty(stack1,"purposes") : stack1),{"name":"each","hash":{},"fn":container.program(54, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":410,"column":34},"end":{"line":410,"column":139}}})) != null ? stack1 : "")
    + "</div>\n              </div>\n";
},"100":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-section-subheader\">\n                <span>\n                  "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificateType") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":418,"column":18},"end":{"line":418,"column":281}}})) != null ? stack1 : "")
    + "Type\n                </span>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Certificate Type</div>\n                <div class=\"text long-hex long-hex-box\">"
    + container.escapeExpression(container.lambda(((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificateType") : stack1)) != null ? lookupProperty(stack1,"type") : stack1), depth0))
    + "</div>\n              </div>\n";
},"102":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-section-subheader\">\n                <span>\n                  "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificateTemplate") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":432,"column":18},"end":{"line":432,"column":285}}})) != null ? stack1 : "")
    + "Template\n                </span>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Identifier</div>\n                <div class=\"text long-hex long-hex-box\">"
    + alias2(alias1(((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificateTemplate") : stack1)) != null ? lookupProperty(stack1,"id") : stack1), depth0))
    + "</div>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Minor Version</div>\n                <div class=\"text\">"
    + alias2(alias1(((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificateTemplate") : stack1)) != null ? lookupProperty(stack1,"minor") : stack1), depth0))
    + "</div>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Major Version</div>\n                <div class=\"text\">"
    + alias2(alias1(((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"certificateTemplate") : stack1)) != null ? lookupProperty(stack1,"major") : stack1), depth0))
    + "</div>\n              </div>\n";
},"104":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "              <div class=\"panel-section-subheader\">\n                <span>\n                  "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"caVersion") : stack1)) != null ? lookupProperty(stack1,"critical") : stack1),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":454,"column":18},"end":{"line":454,"column":275}}})) != null ? stack1 : "")
    + "CA Renewals\n                </span>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Renewals</div>\n                <div class=\"text\">"
    + alias2(alias1(((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"caVersion") : stack1)) != null ? lookupProperty(stack1,"caRenewals") : stack1), depth0))
    + "</div>\n              </div>\n              <div class=\"panel-list-item\">\n                <div class=\"text\">Key Reuses</div>\n                <div class=\"text\">"
    + alias2(alias1(((stack1 = ((stack1 = ((stack1 = (depth0 != null ? lookupProperty(depth0,"ext") : depth0)) != null ? lookupProperty(stack1,"msCrypto") : stack1)) != null ? lookupProperty(stack1,"caVersion") : stack1)) != null ? lookupProperty(stack1,"keyReuses") : stack1), depth0))
    + "</div>\n              </div>\n";
},"106":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <div class=\"panel-section-subsection\">Unknown Extensions</div>\n            <div class=\"panel-list-item mt-3\">\n              <div class=\"text\">Identifiers</div>\n              <div class=\"text\">"
    + ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"unsupportedExtensions") : depth0),{"name":"each","hash":{},"fn":container.program(54, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":474,"column":32},"end":{"line":474,"column":117}}})) != null ? stack1 : "")
    + "</div>\n            </div>\n            <div class=\"panel-list-item\">\n              <div class=\"text\">Note</div>\n              <div class=\"text\">Please open up an issue at <a href=\"https://github.com/april/certainly-something/issues\">Certainly Something</a>, noting the website and unsupported extension identifiers. Thanks!</div>\n            </div>\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data,blockParams,depths) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div id=\"template\">\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"protocolVersion") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":2},"end":{"line":31,"column":9}}})) != null ? stack1 : "")
    + "\n  <div class=\"row section\" id=\"certificates\">\n    <div class=\"panel\">\n      <div class=\"panel-section panel-section-header "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/eq.js */ "./src/viewer/helpers/eq.js")).call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"certs") : depth0)) != null ? lookupProperty(stack1,"length") : stack1),1,{"name":"eq","hash":{},"data":data,"loc":{"start":{"line":36,"column":59},"end":{"line":36,"column":78}}}),{"name":"if","hash":{},"fn":container.program(6, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":36,"column":53},"end":{"line":36,"column":90}}})) != null ? stack1 : "")
    + "\">\n        <div class=\"text-section-header\"><h1>"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/eq.js */ "./src/viewer/helpers/eq.js")).call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"certs") : depth0)) != null ? lookupProperty(stack1,"length") : stack1),1,{"name":"eq","hash":{},"data":data,"loc":{"start":{"line":37,"column":51},"end":{"line":37,"column":70}}}),{"name":"if","hash":{},"fn":container.program(8, data, 0, blockParams, depths),"inverse":container.program(10, data, 0, blockParams, depths),"data":data,"loc":{"start":{"line":37,"column":45},"end":{"line":37,"column":110}}})) != null ? stack1 : "")
    + "</h1></div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"certificate-panel panel\">\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,__default(__webpack_require__(/*! ./helpers/eq.js */ "./src/viewer/helpers/eq.js")).call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"certs") : depth0)) != null ? lookupProperty(stack1,"length") : stack1),1,{"name":"eq","hash":{},"data":data,"loc":{"start":{"line":43,"column":14},"end":{"line":43,"column":33}}}),{"name":"if","hash":{},"fn":container.program(12, data, 0, blockParams, depths),"inverse":container.program(14, data, 0, blockParams, depths),"data":data,"loc":{"start":{"line":43,"column":8},"end":{"line":52,"column":15}}})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,(depth0 != null ? lookupProperty(depth0,"certs") : depth0),{"name":"each","hash":{},"fn":container.program(20, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":54,"column":8},"end":{"line":483,"column":17}}})) != null ? stack1 : "")
    + "      </div>\n    </div>\n  </div>\n\n</div>\n";
},"useData":true,"useDepths":true});

/***/ }),

/***/ "./src/viewer/js/ctlognames.js":
/*!*************************************!*\
  !*** ./src/viewer/js/ctlognames.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const ctLogNames = exports.ctLogNames = {
  "9606c02c690033aa1d145f59c6e2648d0549f0df96aab8db915a70d8ecf390a5": "Akamai CT",
  "39376f545f7b4607f59742d768cd5d2437bf3473b6534a4834bcf72e681c83c9": "Alpha CT",
  "a577ac9ced7548dd8f025b67a241089df86e0f476ec203c2ecbedb185f282638": "CNNIC CT",
  "cdb5179b7fc1c046feea31136a3f8f002e6182faf8896fecc8b2f5b5ab604900": "Certly.IO",
  "1fbc36e002ede97f40199e86b3573b8a4217d80187746ad0da03a06054d20df4": "Cloudflare Nimbus2017",
  "db74afeecb29ecb1feca3e716d2ce5b9aabb36f7847183c75d9d4f37b61fbf64": "Cloudflare Nimbus2018",
  "747eda8331ad331091219cce254f4270c2bffd5e422008c6373579e6107bcc56": "Cloudflare Nimbus2019",
  "5ea773f9df56c0e7b536487dd049e0327a919a0c84a112128418759681714558": "Cloudflare Nimbus2020",
  "4494652eb0eeceafc44007d8a8fe28c0dae682bed8cb31b53fd33396b5b681a8": "Cloudflare Nimbus2021",
  "41c8cab1df22464a10c6a13a0942875e4e318b1b03ebeb4bc768f090629606f6": "Cloudflare Nimbus2022",
  "7a328c54d8b72db620ea38e0521ee98416703213854d3bd22bc13a57a352eb52": "Cloudflare Nimbus2023",
  "6ff141b5647e4222f7ef052cefae7c21fd608e27d2af5a6e9f4b8a37d6633ee5": "DigiCert Nessie2018",
  "fe446108b1d01ab78a62ccfeab6ab2b2babff3abdad80a4d8b30df2d0008830c": "DigiCert Nessie2019",
  "c652a0ec48ceb3fcab170992c43a87413309e80065a26252401ba3362a17c565": "DigiCert Nessie2020",
  "eec095ee8d72640f92e3c3b91bc712a3696a097b4b6a1a1438e647b2cbedc5f9": "DigiCert Nessie2021",
  "51a3b0f5fd01799c566db837788f0ca47acc1b27cbf79e88429a0dfed48b05e5": "DigiCert Nessie2022",
  "b3737707e18450f86386d605a9dc11094a792db1670c0b87dcf0030e7936a59a": "DigiCert Nessie2023",
  "5614069a2fd7c2ecd3f5e1bd44b23ec74676b9bc99115cc0ef949855d689d0dd": "DigiCert Server",
  "8775bfe7597cf88c43995fbdf36eff568d475636ff4ab560c1b4eaff5ea0830f": "DigiCert Server 2",
  "c1164ae0a772d2d4392dc80ac10770d4f0c49bde991a4840c1fa075164f63360": "DigiCert Yeti2018",
  "e2694bae26e8e94009e8861bb63b83d43ee7fe7488fba48f2893019dddf1dbfe": "DigiCert Yeti2019",
  "f095a459f200d18240102d2f93888ead4bfe1d47e399e1d034a6b0a8aa8eb273": "DigiCert Yeti2020",
  "5cdc4392fee6ab4544b15e9ad456e61037fbd5fa47dca17394b25ee6f6c70eca": "DigiCert Yeti2021",
  "2245450759552456963fa12ff1f76d86e0232663adc04b7f5dc6835c6ee20f02": "DigiCert Yeti2022",
  "35cf191bbfb16c57bf0fad4c6d42cbbbb627202651ea3fe12aefa803c33bd64c": "DigiCert Yeti2023",
  "717ea7420975be84a2723553f1777c26dd51af4e102144094d9019b462fb6668": "GDCA 1",
  "14308d90ccd030135005c01ca526d81e84e87624e39b6248e08f724aea3bb42a": "GDCA 2",
  "c9cf890a21109c666cc17a3ed065c930d0e0135a9feba85af14210b8072421aa": "GDCA CT #1",
  "924a30f909336ff435d6993a10ac75a2c641728e7fc2d659ae6188ffad40ce01": "GDCA CT #2",
  "fad4c97cc49ee2f8ac85c5ea5cea09d0220dbbf4e49c6b50662ff868f86b8c28": "Google Argon2017",
  "a4501269055a15545e6211ab37bc103f62ae5576a45e4b1714453e1b22106a25": "Google Argon2018",
  "63f2dbcde83bcc2ccf0b728427576b33a48d61778fbd75a638b1c768544bd88d": "Google Argon2019",
  "b21e05cc8ba2cd8a204e8766f92bb98a2520676bdafa70e7b249532def8b905e": "Google Argon2020",
  "f65c942fd1773022145418083094568ee34d131933bfdf0c2f200bcc4ef164e3": "Google Argon2021",
  "2979bef09e393921f056739f63a577e5be577d9c600af8f94d5d265c255dc784": "Google Argon2022",
  "68f698f81f6482be3a8ceeb9281d4cfc71515d6793d444d10a67acbb4f4ffbc4": "Google Aviator",
  "c3bf03a7e1ca8841c607bae3ff4270fca5ec45b186ebbe4e2cf3fc778630f5f6": "Google Crucible",
  "1d024b8eb1498b344dfd87ea3efc0996f7506f235d1d497061a4773c439c25fb": "Google Daedalus",
  "293c519654c83965baaa50fc5807d4b76fbf587a2972dca4c30cf4e54547f478": "Google Icarus",
  "a4b90990b418581487bb13a2cc67700a3c359804f91bdfb8e377cd0ec80ddc10": "Google Pilot",
  "ee4bbdb775ce60bae142691fabe19e66a30f7e5fb072d88300c47b897aa8fdcb": "Google Rocketeer",
  "bbd9dfbc1f8a71b593942397aa927b473857950aab52e81a909664368e1ed185": "Google Skydiver",
  "52eb4b225ec896974850675f23e43bc1d021e3214ce52ecd5fa87c203cdfca03": "Google Solera2018",
  "0b760e9a8b9a682f88985b15e947501a56446bba8830785c3842994386450c00": "Google Solera2019",
  "1fc72ce5a1b799f400c359bff96ca3913548e8644220610952e9ba1774f7bac7": "Google Solera2020",
  "a3c99845e80ab7ce00157b3742df0207dd272b2b602ecf98ee2c12db9c5ae7e7": "Google Solera2021",
  "697aafca1a6b536fae21205046debad7e0eaea13d2432e6e9d8fb379f2b9aaf3": "Google Solera2022",
  "a899d8780c9290aaf462f31880ccfbd52451e970d0fbf591ef75b0d99b645681": "Google Submariner",
  "b0cc83e5a5f97d6baf7c09cc284904872ac7e88b132c6350b7c6fd26e16c6c77": "Google Testtube",
  "b10cd559a6d67846811f7df9a51532739ac48d703bea0323da5d38755bc0ad4e": "Google Xenon2018",
  "084114980071532c16190460bcfc47fdc2653afa292c72b37ff863ae29ccc9f0": "Google Xenon2019",
  "07b75c1be57d68fff1b0c61d2315c7bae6577c5794b76aeebc613a1a69d3a21c": "Google Xenon2020",
  "7d3ef2f88fff88556824c2c0ca9e5289792bc50e78097f2e6a9768997e22f0d7": "Google Xenon2021",
  "46a555eb75fa912030b5a28969f4f37d112c4174befd49b885abf2fc70fe6d47": "Google Xenon2022",
  "7461b4a09cfb3d41d75159575b2e7649a445a8d27709b0cc564a6482b7eb41a3": "Izenpe",
  "8941449c70742e06b9fc9ce7b116ba0024aa36d59af44f0204404f00f7ea8566": "Izenpe Argi",
  "296afa2d568bca0d2ea844956ae9721fc35fa355ecda99693aafd458a71aefdd": "Lets Encrypt Clicky",
  "537b69a3564335a9c04904e39593b2c298eb8d7a6e83023635c627248cd6b440": "Nordu flimsy",
  "aae70b7f3cb8d566c86c2f16979c9f445f69ab0eb4535589b2f77a030104f3cd": "Nordu plausible",
  "e0127629e90496564e3d0147984498aa48f8adb16600eb7902a1ef9909906273": "PuChuangSiDa CT",
  "cf55e28923497c340d5206d05353aeb25834b52f1f8dc9526809f212efdd7ca6": "SHECA CT 1",
  "32dc59c2d4c41968d56e14bc61ac8f0e45db39faf3c155aa4252f5001fa0c623": "SHECA CT 2",
  "db76fdadac65e7d09508886e2159bd8b90352f5fead3e3dc5e22eb350acc7b98": "Sectigo (Comodo) Dodo CT",
  "6f5376ac31f03119d89900a45115ff77151c11d902c10029068db2089a37d913": "Sectigo (Comodo) Mammoth CT",
  "5581d4c2169036014aea0b9b573c53f0c0e43878702508172fa3aa1d0713d30c": "Sectigo (Comodo) Sabre CT",
  "34bb6ad6c3df9c03eea8a499ff7891486c9d5e5cac92d01f7bfd1bce19db48ef": "StartCom",
  "ddeb1d2b7a0d4fa6208b81ad8168707e2e8e9d01d55c888d3d11c4cdb6ecbecc": "Symantec",
  "a7ce4a4e6207e0addee5fdaa4b1f86768767b5d002a55d47310e7e670a95eab2": "Symantec Deneb",
  "15970488d7b997a05beb52512adee8d2e8b4a3165264121a9fabfbd5f85ad93f": "Symantec Sirius",
  "bc78e1dfc5f63c684649334da10fa15f0979692009c081b4f3f6917f3ed9b8a5": "Symantec Vega",
  "b0b784bc81c0ddc47544e883f05985bb9077d134d8ab88b2b2e533980b8e508b": "Up In The Air Behind the Sofa",
  "ac3b9aed7fa9674757159e6d7d575672f9d98100941e9bdeffeca1313b75782d": "Venafi",
  "03019df3fd85a69a8ebd1facc6da9ba73e469774fe77f579fc5a08b8328c1d6b": "Venafi Gen2 CT",
  "41b2dc2e89e63ce4af1ba7bb29bf68c6dee6f9f1cc047e30dffae3b3ba259263": "WoSign",
  "63d0006026dde10bb0601f452446965ee2b6ea2cd4fbc95ac866a550af9075b7": "WoSign 2",
  "9e4ff73dc3ce220b69217c899e468076abf8d78636d5ccfc85a31a75628ba88b": "WoSign CT #1"
};

/***/ }),

/***/ "./src/viewer/js/der.js":
/*!******************************!*\
  !*** ./src/viewer/js/der.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = undefined;

var _asn1js = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");

var asn1js = _interopRequireWildcard(_asn1js);

var _pkijs = __webpack_require__(/*! pkijs */ "./node_modules/pkijs/src/index.js");

var _ctlognames = __webpack_require__(/*! ./ctlognames.js */ "./src/viewer/js/ctlognames.js");

var _strings = __webpack_require__(/*! ../../i18n/strings.js */ "./src/i18n/strings.js");

var _utils = __webpack_require__(/*! ./utils.js */ "./src/viewer/js/utils.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const getX509Ext = (extensions, v) => {
  for (var extension in extensions) {
    if (extensions[extension].extnID === v) {
      return extensions[extension];
    }
  }

  return {
    extnValue: undefined,
    parsedValue: undefined
  };
};

const parseSubsidiary = distinguishedNames => {
  const subsidiary = {
    cn: '',
    dn: [],
    entries: []
  };

  distinguishedNames.forEach(dn => {
    const name = _strings.strings.names[dn.type];
    const value = dn.value.valueBlock.value;

    if (name === undefined) {
      subsidiary.dn.push(`OID.${dn.type}=${value}`);
      subsidiary.entries.push([`OID.${dn.type}`, value]);
    } else if (name.short === undefined) {
      subsidiary.dn.push(`OID.${dn.type}=${value}`);
      subsidiary.entries.push([name.long, value]);
    } else {
      subsidiary.dn.push(`${name.short}=${value}`);
      subsidiary.entries.push([name.long, value]);

      // add the common name for tab display
      if (name.short === 'cn') {
        subsidiary.cn = value;
      }
    }
  });

  // turn path into a string
  subsidiary.dn = subsidiary.dn.join(', ');

  return subsidiary;
};

const parse = exports.parse = async certificate => {
  const supportedExtensions = ['1.3.6.1.4.1.311.20.2', // microsoft certificate type
  '1.3.6.1.4.1.311.21.2', // microsoft certificate previous hash
  '1.3.6.1.4.1.311.21.7', // microsoft certificate template
  '1.3.6.1.4.1.311.21.1', // microsoft certification authority renewal
  '1.3.6.1.4.1.311.21.10', // microsoft certificate policies
  '1.3.6.1.4.1.11129.2.4.2', // embedded scts
  '1.3.6.1.5.5.7.1.1', // authority info access
  '1.3.6.1.5.5.7.1.24', // ocsp stapling
  '1.3.101.77', // ct redaction - deprecated and not displayed
  '2.5.29.14', // subject key identifier
  '2.5.29.15', // key usages
  '2.5.29.17', // subject alt names
  '2.5.29.19', // basic constraints
  '2.5.29.31', // crl points
  '2.5.29.32', // certificate policies
  '2.5.29.35', // authority key identifier
  '2.5.29.37'];

  // get the current time zone - note that there are some time zones that this doesn't easily
  // match, for whatever reason.  https://github.com/april/certainly-something/issues/21
  let timeZone = new Date().toString().match(/\(([A-Za-z\s].*)\)/);
  if (timeZone === null) {
    // America/Chicago
    timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  } else if (timeZone.length > 1) {
    timeZone = timeZone[1]; // Central Daylight Time
  } else {
    timeZone = 'Local Time'; // not sure if this is right, but let's go with it for now
  }

  // parse the certificate
  const asn1 = asn1js.fromBER(certificate);

  let x509 = new _pkijs.Certificate({ schema: asn1.result });
  x509 = x509.toJSON();

  // convert the cert to PEM
  const certBTOA = window.btoa(String.fromCharCode.apply(null, new Uint8Array(certificate))).match(/.{1,64}/g).join('\r\n');

  // get which extensions are critical
  const criticalExtensions = [];
  x509.extensions.forEach(ext => {
    if (ext.hasOwnProperty('critical') && ext.critical === true) {
      criticalExtensions.push(ext.extnID);
    }
  });

  // get the public key info
  let spki = Object.assign({
    crv: undefined,
    e: undefined,
    kty: undefined,
    n: undefined,
    keysize: undefined,
    x: undefined,
    xy: undefined,
    y: undefined
  }, x509.subjectPublicKeyInfo);

  if (spki.kty === 'RSA') {
    spki.e = (0, _utils.b64urltodec)(spki.e); // exponent
    spki.keysize = (0, _utils.b64urltohex)(spki.n).length * 8; // key size in bits
    spki.n = (0, _utils.hashify)((0, _utils.b64urltohex)(spki.n)); // modulus
  } else if (spki.kty === 'EC') {
    spki.kty = 'Elliptic Curve';
    spki.keysize = parseInt(spki.crv.split('-')[1]); // this is a bit hacky
    spki.x = (0, _utils.hashify)((0, _utils.b64urltohex)(spki.x)); // x coordinate
    spki.y = (0, _utils.hashify)((0, _utils.b64urltohex)(spki.y)); // y coordinate
    spki.xy = `04:${spki.x}:${spki.y}`; // 04 (uncompressed) public key
  }

  // get the keyUsages
  const keyUsages = {
    critical: criticalExtensions.includes('2.5.29.15'),
    purposes: []
  };

  let keyUsagesBS = getX509Ext(x509.extensions, '2.5.29.15').parsedValue;
  if (keyUsagesBS !== undefined) {
    // parse the bit string, shifting as necessary
    let unusedBits = keyUsagesBS.valueBlock.unusedBits;
    keyUsagesBS = parseInt(keyUsagesBS.valueBlock.valueHex, 16) >> unusedBits;

    // iterate through the bit string
    _strings.strings.keyUsages.slice(unusedBits - 1).forEach(usage => {
      if (keyUsagesBS & 1) {
        keyUsages.purposes.push(usage);
      }

      keyUsagesBS = keyUsagesBS >> 1;
    });

    // reverse the order for legibility
    keyUsages.purposes.reverse();
  };

  // get the subjectAltNames
  let san = getX509Ext(x509.extensions, '2.5.29.17').parsedValue;
  if (san && san.hasOwnProperty('altNames')) {
    san = Object.keys(san.altNames).map(x => {
      const type = san.altNames[x].type;

      switch (type) {
        case 4:
          // directory
          return [_strings.strings.san[type], parseSubsidiary(san.altNames[x].value.typesAndValues).dn];
        case 7:
          // ip address
          let address = san.altNames[x].value.valueBlock.valueHex;

          if (address.length === 8) {
            // ipv4
            return [_strings.strings.san[type], address.match(/.{1,2}/g).map(x => parseInt(x, 16)).join('.')];
          } else if (address.length === 32) {
            // ipv6
            return [_strings.strings.san[type], address.toLowerCase().match(/.{1,4}/g).join(':').replace(/\b:?(?:0+:?){2,}/, '::')];
          } else {
            return [_strings.strings.san[type], 'Unknown IP address'];
          }
        default:
          return [_strings.strings.san[type], san.altNames[x].value];
      }
    });
  } else {
    san = [];
  }

  san = {
    altNames: san,
    critical: criticalExtensions.includes('2.5.29.17')
  };

  // get the embedded SCTs
  let scts = getX509Ext(x509.extensions, '1.3.6.1.4.1.11129.2.4.2').parsedValue;

  console.log(scts);
  /*const BOM = new Uint8Array([0xEF,0xBB,0xBF]);
    var blob = new Blob([BOM, scts], {
            encoding: 'UTF-8',
            type: 'text/plain;charset=UTF-8'
          });
          var url = URL.createObjectURL(blob);
          var options = {
      filename: "fileName",
      url: url,
    };
          browser.downloads.download(options)
  */
  /*
    if (scts) {
      scts = Object.keys(scts.timestamps).map(x => {
        let logId = scts.timestamps[x].logID.toLowerCase();
        return {
          logId: hashify(logId),
          name: ctLogNames.hasOwnProperty(logId) ? ctLogNames[logId] : undefined,
          signatureAlgorithm: `${scts.timestamps[x].hashAlgorithm.replace('sha', 'SHA-')} ${scts.timestamps[x].signatureAlgorithm.toUpperCase()}`,
          timestamp: `${scts.timestamps[x].timestamp.toLocaleString()} (${timeZone})`,
          version: scts.timestamps[x].version + 1,
        }
      });
    } else {
      scts = [];
    }
  
    scts = {
      critical: criticalExtensions.includes('1.3.6.1.4.1.11129.2.4.2'),
      timestamps: scts,
    }*/
};

/***/ }),

/***/ "./src/viewer/js/index.js":
/*!********************************!*\
  !*** ./src/viewer/js/index.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./render.js */ "./src/viewer/js/render.js");

/***/ }),

/***/ "./src/viewer/js/render.js":
/*!*********************************!*\
  !*** ./src/viewer/js/render.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _der = __webpack_require__(/*! ./der.js */ "./src/viewer/js/der.js");

var _utils = __webpack_require__(/*! ./utils.js */ "./src/viewer/js/utils.js");

let template = __webpack_require__(/*! ../index.handlebars */ "./src/viewer/index.handlebars");

// returns an object with a certs array: it either inserts them into an existing securityInfo
// object, or it creates a new object containing only the certs
const buildChain = async chain => {
  let builtChain;

  // probably a PEM encoded certificate
  if (typeof chain === 'string' && chain.includes('-----BEGIN CERTIFICATE-----')) {
    builtChain = chain.trim().replace(/\r|\n|\0/g, '').split(/-----BEGIN CERTIFICATE-----|-----END CERTIFICATE-----/g).filter(v => v.startsWith('MII'));

    builtChain = builtChain.map(cert => {
      return (0, _utils.pemToBER)(cert);
    });
  } else if (chain.buffer) {
    // DER encoded
    builtChain = [chain.buffer];
  } else if (typeof chain === 'object' && Array.isArray(chain)) {
    builtChain = chain.map(cert => {
      return new Uint8Array(cert.rawDER).buffer;
    });
  }

  // now we need to parse each of the certificates, and return the parsed chain
  return await Promise.all(builtChain.map(cert => (0, _der.parse)(cert)));
};

const handleDOMContentLoaded = async () => {

  const tid = window.location.search.split('=')[1];

  chrome.runtime.sendMessage({
    'action': 'getSecurityInfo',
    'tabId': tid
  }, async response => {

    // stuff the parsed certificate chain into securityInfo
    response['certs'] = await buildChain(response['certificates']);
  });
};

// initialize the document
document.addEventListener('DOMContentLoaded', () => {
  handleDOMContentLoaded();
});

/***/ }),

/***/ "./src/viewer/js/utils.js":
/*!********************************!*\
  !*** ./src/viewer/js/utils.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pemToBER = exports.hashify = exports.hash = exports.getObjPath = exports.b64urltohex = exports.b64urltodec = undefined;

var _asn1js = __webpack_require__(/*! asn1js */ "./node_modules/asn1js/src/asn1.js");

var asn1js = _interopRequireWildcard(_asn1js);

var _pvutils = __webpack_require__(/*! pvutils */ "./node_modules/pvutils/build/utils.es.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const b64urltodec = exports.b64urltodec = b64 => {
  return new asn1js.Integer({ valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)('AQAB', true, true)) }).valueBlock._valueDec;
};

const b64urltohex = exports.b64urltohex = b64 => {
  const hexBuffer = new asn1js.Integer({ valueHex: (0, _pvutils.stringToArrayBuffer)((0, _pvutils.fromBase64)(b64, true, true)) }).valueBlock._valueHex;
  const hexArray = Array.from(new Uint8Array(hexBuffer));

  return hexArray.map(b => ('00' + b.toString(16)).slice(-2));
};

// this particular prototype override makes it easy to chain down complex objects
const getObjPath = exports.getObjPath = (obj, path) => {
  for (var i = 0, path = path.split('.'), len = path.length; i < len; i++) {
    if (Array.isArray(obj[path[i]])) {
      obj = obj[path[i]][path[i + 1]];
      i++;
    } else {
      obj = obj[path[i]];
    }
  };

  return obj;
};

const hash = exports.hash = async (algo, buffer) => {
  const hashBuffer = await crypto.subtle.digest(algo, buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));

  return hashArray.map(b => ('00' + b.toString(16)).slice(-2)).join(':').toUpperCase();
};

const hashify = exports.hashify = hash => {
  if (typeof hash === 'string') {
    return hash.match(/.{2}/g).join(':').toUpperCase();
  } else {
    return hash.join(':').toUpperCase();
  }
};

const pemToBER = exports.pemToBER = pem => {
  return (0, _pvutils.stringToArrayBuffer)(window.atob(pem));
};

/***/ })

/******/ });
//# sourceMappingURL=index.js.map